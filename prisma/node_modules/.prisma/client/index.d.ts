
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Employee
 * 
 */
export type Employee = $Result.DefaultSelection<Prisma.$EmployeePayload>
/**
 * Model TrainingType
 * 
 */
export type TrainingType = $Result.DefaultSelection<Prisma.$TrainingTypePayload>
/**
 * Model TrainingRecord
 * 
 */
export type TrainingRecord = $Result.DefaultSelection<Prisma.$TrainingRecordPayload>
/**
 * Model PpeRecord
 * 
 */
export type PpeRecord = $Result.DefaultSelection<Prisma.$PpeRecordPayload>
/**
 * Model AsoRecord
 * 
 */
export type AsoRecord = $Result.DefaultSelection<Prisma.$AsoRecordPayload>
/**
 * Model ChemicalRecord
 * 
 */
export type ChemicalRecord = $Result.DefaultSelection<Prisma.$ChemicalRecordPayload>
/**
 * Model JsaRecord
 * 
 */
export type JsaRecord = $Result.DefaultSelection<Prisma.$JsaRecordPayload>
/**
 * Model RiskItem
 * 
 */
export type RiskItem = $Result.DefaultSelection<Prisma.$RiskItemPayload>
/**
 * Model CipaMeeting
 * 
 */
export type CipaMeeting = $Result.DefaultSelection<Prisma.$CipaMeetingPayload>
/**
 * Model CipaAction
 * 
 */
export type CipaAction = $Result.DefaultSelection<Prisma.$CipaActionPayload>
/**
 * Model PreventiveAction
 * 
 */
export type PreventiveAction = $Result.DefaultSelection<Prisma.$PreventiveActionPayload>
/**
 * Model DocumentRecord
 * 
 */
export type DocumentRecord = $Result.DefaultSelection<Prisma.$DocumentRecordPayload>
/**
 * Model DocumentAction
 * 
 */
export type DocumentAction = $Result.DefaultSelection<Prisma.$DocumentActionPayload>
/**
 * Model LawsuitRecord
 * 
 */
export type LawsuitRecord = $Result.DefaultSelection<Prisma.$LawsuitRecordPayload>
/**
 * Model AccidentRecord
 * 
 */
export type AccidentRecord = $Result.DefaultSelection<Prisma.$AccidentRecordPayload>
/**
 * Model OccupationalDiseaseRecord
 * 
 */
export type OccupationalDiseaseRecord = $Result.DefaultSelection<Prisma.$OccupationalDiseaseRecordPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Employees
 * const employees = await prisma.employee.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Employees
   * const employees = await prisma.employee.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.employee`: Exposes CRUD operations for the **Employee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employee.findMany()
    * ```
    */
  get employee(): Prisma.EmployeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trainingType`: Exposes CRUD operations for the **TrainingType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrainingTypes
    * const trainingTypes = await prisma.trainingType.findMany()
    * ```
    */
  get trainingType(): Prisma.TrainingTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trainingRecord`: Exposes CRUD operations for the **TrainingRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrainingRecords
    * const trainingRecords = await prisma.trainingRecord.findMany()
    * ```
    */
  get trainingRecord(): Prisma.TrainingRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ppeRecord`: Exposes CRUD operations for the **PpeRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PpeRecords
    * const ppeRecords = await prisma.ppeRecord.findMany()
    * ```
    */
  get ppeRecord(): Prisma.PpeRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.asoRecord`: Exposes CRUD operations for the **AsoRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AsoRecords
    * const asoRecords = await prisma.asoRecord.findMany()
    * ```
    */
  get asoRecord(): Prisma.AsoRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chemicalRecord`: Exposes CRUD operations for the **ChemicalRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChemicalRecords
    * const chemicalRecords = await prisma.chemicalRecord.findMany()
    * ```
    */
  get chemicalRecord(): Prisma.ChemicalRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jsaRecord`: Exposes CRUD operations for the **JsaRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JsaRecords
    * const jsaRecords = await prisma.jsaRecord.findMany()
    * ```
    */
  get jsaRecord(): Prisma.JsaRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.riskItem`: Exposes CRUD operations for the **RiskItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RiskItems
    * const riskItems = await prisma.riskItem.findMany()
    * ```
    */
  get riskItem(): Prisma.RiskItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cipaMeeting`: Exposes CRUD operations for the **CipaMeeting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CipaMeetings
    * const cipaMeetings = await prisma.cipaMeeting.findMany()
    * ```
    */
  get cipaMeeting(): Prisma.CipaMeetingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cipaAction`: Exposes CRUD operations for the **CipaAction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CipaActions
    * const cipaActions = await prisma.cipaAction.findMany()
    * ```
    */
  get cipaAction(): Prisma.CipaActionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.preventiveAction`: Exposes CRUD operations for the **PreventiveAction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PreventiveActions
    * const preventiveActions = await prisma.preventiveAction.findMany()
    * ```
    */
  get preventiveAction(): Prisma.PreventiveActionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.documentRecord`: Exposes CRUD operations for the **DocumentRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DocumentRecords
    * const documentRecords = await prisma.documentRecord.findMany()
    * ```
    */
  get documentRecord(): Prisma.DocumentRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.documentAction`: Exposes CRUD operations for the **DocumentAction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DocumentActions
    * const documentActions = await prisma.documentAction.findMany()
    * ```
    */
  get documentAction(): Prisma.DocumentActionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lawsuitRecord`: Exposes CRUD operations for the **LawsuitRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LawsuitRecords
    * const lawsuitRecords = await prisma.lawsuitRecord.findMany()
    * ```
    */
  get lawsuitRecord(): Prisma.LawsuitRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.accidentRecord`: Exposes CRUD operations for the **AccidentRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccidentRecords
    * const accidentRecords = await prisma.accidentRecord.findMany()
    * ```
    */
  get accidentRecord(): Prisma.AccidentRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.occupationalDiseaseRecord`: Exposes CRUD operations for the **OccupationalDiseaseRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OccupationalDiseaseRecords
    * const occupationalDiseaseRecords = await prisma.occupationalDiseaseRecord.findMany()
    * ```
    */
  get occupationalDiseaseRecord(): Prisma.OccupationalDiseaseRecordDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Employee: 'Employee',
    TrainingType: 'TrainingType',
    TrainingRecord: 'TrainingRecord',
    PpeRecord: 'PpeRecord',
    AsoRecord: 'AsoRecord',
    ChemicalRecord: 'ChemicalRecord',
    JsaRecord: 'JsaRecord',
    RiskItem: 'RiskItem',
    CipaMeeting: 'CipaMeeting',
    CipaAction: 'CipaAction',
    PreventiveAction: 'PreventiveAction',
    DocumentRecord: 'DocumentRecord',
    DocumentAction: 'DocumentAction',
    LawsuitRecord: 'LawsuitRecord',
    AccidentRecord: 'AccidentRecord',
    OccupationalDiseaseRecord: 'OccupationalDiseaseRecord'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "employee" | "trainingType" | "trainingRecord" | "ppeRecord" | "asoRecord" | "chemicalRecord" | "jsaRecord" | "riskItem" | "cipaMeeting" | "cipaAction" | "preventiveAction" | "documentRecord" | "documentAction" | "lawsuitRecord" | "accidentRecord" | "occupationalDiseaseRecord"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Employee: {
        payload: Prisma.$EmployeePayload<ExtArgs>
        fields: Prisma.EmployeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findFirst: {
            args: Prisma.EmployeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findMany: {
            args: Prisma.EmployeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          create: {
            args: Prisma.EmployeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          createMany: {
            args: Prisma.EmployeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          delete: {
            args: Prisma.EmployeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          update: {
            args: Prisma.EmployeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployeeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          upsert: {
            args: Prisma.EmployeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          aggregate: {
            args: Prisma.EmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployee>
          }
          groupBy: {
            args: Prisma.EmployeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeCountAggregateOutputType> | number
          }
        }
      }
      TrainingType: {
        payload: Prisma.$TrainingTypePayload<ExtArgs>
        fields: Prisma.TrainingTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainingTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingTypePayload>
          }
          findFirst: {
            args: Prisma.TrainingTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingTypePayload>
          }
          findMany: {
            args: Prisma.TrainingTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingTypePayload>[]
          }
          create: {
            args: Prisma.TrainingTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingTypePayload>
          }
          createMany: {
            args: Prisma.TrainingTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrainingTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingTypePayload>[]
          }
          delete: {
            args: Prisma.TrainingTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingTypePayload>
          }
          update: {
            args: Prisma.TrainingTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingTypePayload>
          }
          deleteMany: {
            args: Prisma.TrainingTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TrainingTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingTypePayload>[]
          }
          upsert: {
            args: Prisma.TrainingTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingTypePayload>
          }
          aggregate: {
            args: Prisma.TrainingTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrainingType>
          }
          groupBy: {
            args: Prisma.TrainingTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainingTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainingTypeCountArgs<ExtArgs>
            result: $Utils.Optional<TrainingTypeCountAggregateOutputType> | number
          }
        }
      }
      TrainingRecord: {
        payload: Prisma.$TrainingRecordPayload<ExtArgs>
        fields: Prisma.TrainingRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainingRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingRecordPayload>
          }
          findFirst: {
            args: Prisma.TrainingRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingRecordPayload>
          }
          findMany: {
            args: Prisma.TrainingRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingRecordPayload>[]
          }
          create: {
            args: Prisma.TrainingRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingRecordPayload>
          }
          createMany: {
            args: Prisma.TrainingRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrainingRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingRecordPayload>[]
          }
          delete: {
            args: Prisma.TrainingRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingRecordPayload>
          }
          update: {
            args: Prisma.TrainingRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingRecordPayload>
          }
          deleteMany: {
            args: Prisma.TrainingRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TrainingRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingRecordPayload>[]
          }
          upsert: {
            args: Prisma.TrainingRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingRecordPayload>
          }
          aggregate: {
            args: Prisma.TrainingRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrainingRecord>
          }
          groupBy: {
            args: Prisma.TrainingRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainingRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainingRecordCountArgs<ExtArgs>
            result: $Utils.Optional<TrainingRecordCountAggregateOutputType> | number
          }
        }
      }
      PpeRecord: {
        payload: Prisma.$PpeRecordPayload<ExtArgs>
        fields: Prisma.PpeRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PpeRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PpeRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PpeRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PpeRecordPayload>
          }
          findFirst: {
            args: Prisma.PpeRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PpeRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PpeRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PpeRecordPayload>
          }
          findMany: {
            args: Prisma.PpeRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PpeRecordPayload>[]
          }
          create: {
            args: Prisma.PpeRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PpeRecordPayload>
          }
          createMany: {
            args: Prisma.PpeRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PpeRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PpeRecordPayload>[]
          }
          delete: {
            args: Prisma.PpeRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PpeRecordPayload>
          }
          update: {
            args: Prisma.PpeRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PpeRecordPayload>
          }
          deleteMany: {
            args: Prisma.PpeRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PpeRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PpeRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PpeRecordPayload>[]
          }
          upsert: {
            args: Prisma.PpeRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PpeRecordPayload>
          }
          aggregate: {
            args: Prisma.PpeRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePpeRecord>
          }
          groupBy: {
            args: Prisma.PpeRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<PpeRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.PpeRecordCountArgs<ExtArgs>
            result: $Utils.Optional<PpeRecordCountAggregateOutputType> | number
          }
        }
      }
      AsoRecord: {
        payload: Prisma.$AsoRecordPayload<ExtArgs>
        fields: Prisma.AsoRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AsoRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AsoRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AsoRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AsoRecordPayload>
          }
          findFirst: {
            args: Prisma.AsoRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AsoRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AsoRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AsoRecordPayload>
          }
          findMany: {
            args: Prisma.AsoRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AsoRecordPayload>[]
          }
          create: {
            args: Prisma.AsoRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AsoRecordPayload>
          }
          createMany: {
            args: Prisma.AsoRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AsoRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AsoRecordPayload>[]
          }
          delete: {
            args: Prisma.AsoRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AsoRecordPayload>
          }
          update: {
            args: Prisma.AsoRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AsoRecordPayload>
          }
          deleteMany: {
            args: Prisma.AsoRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AsoRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AsoRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AsoRecordPayload>[]
          }
          upsert: {
            args: Prisma.AsoRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AsoRecordPayload>
          }
          aggregate: {
            args: Prisma.AsoRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAsoRecord>
          }
          groupBy: {
            args: Prisma.AsoRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<AsoRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.AsoRecordCountArgs<ExtArgs>
            result: $Utils.Optional<AsoRecordCountAggregateOutputType> | number
          }
        }
      }
      ChemicalRecord: {
        payload: Prisma.$ChemicalRecordPayload<ExtArgs>
        fields: Prisma.ChemicalRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChemicalRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChemicalRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChemicalRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChemicalRecordPayload>
          }
          findFirst: {
            args: Prisma.ChemicalRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChemicalRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChemicalRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChemicalRecordPayload>
          }
          findMany: {
            args: Prisma.ChemicalRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChemicalRecordPayload>[]
          }
          create: {
            args: Prisma.ChemicalRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChemicalRecordPayload>
          }
          createMany: {
            args: Prisma.ChemicalRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChemicalRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChemicalRecordPayload>[]
          }
          delete: {
            args: Prisma.ChemicalRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChemicalRecordPayload>
          }
          update: {
            args: Prisma.ChemicalRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChemicalRecordPayload>
          }
          deleteMany: {
            args: Prisma.ChemicalRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChemicalRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChemicalRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChemicalRecordPayload>[]
          }
          upsert: {
            args: Prisma.ChemicalRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChemicalRecordPayload>
          }
          aggregate: {
            args: Prisma.ChemicalRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChemicalRecord>
          }
          groupBy: {
            args: Prisma.ChemicalRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChemicalRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChemicalRecordCountArgs<ExtArgs>
            result: $Utils.Optional<ChemicalRecordCountAggregateOutputType> | number
          }
        }
      }
      JsaRecord: {
        payload: Prisma.$JsaRecordPayload<ExtArgs>
        fields: Prisma.JsaRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JsaRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JsaRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JsaRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JsaRecordPayload>
          }
          findFirst: {
            args: Prisma.JsaRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JsaRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JsaRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JsaRecordPayload>
          }
          findMany: {
            args: Prisma.JsaRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JsaRecordPayload>[]
          }
          create: {
            args: Prisma.JsaRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JsaRecordPayload>
          }
          createMany: {
            args: Prisma.JsaRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JsaRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JsaRecordPayload>[]
          }
          delete: {
            args: Prisma.JsaRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JsaRecordPayload>
          }
          update: {
            args: Prisma.JsaRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JsaRecordPayload>
          }
          deleteMany: {
            args: Prisma.JsaRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JsaRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JsaRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JsaRecordPayload>[]
          }
          upsert: {
            args: Prisma.JsaRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JsaRecordPayload>
          }
          aggregate: {
            args: Prisma.JsaRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJsaRecord>
          }
          groupBy: {
            args: Prisma.JsaRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<JsaRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.JsaRecordCountArgs<ExtArgs>
            result: $Utils.Optional<JsaRecordCountAggregateOutputType> | number
          }
        }
      }
      RiskItem: {
        payload: Prisma.$RiskItemPayload<ExtArgs>
        fields: Prisma.RiskItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RiskItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RiskItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskItemPayload>
          }
          findFirst: {
            args: Prisma.RiskItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RiskItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskItemPayload>
          }
          findMany: {
            args: Prisma.RiskItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskItemPayload>[]
          }
          create: {
            args: Prisma.RiskItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskItemPayload>
          }
          createMany: {
            args: Prisma.RiskItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RiskItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskItemPayload>[]
          }
          delete: {
            args: Prisma.RiskItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskItemPayload>
          }
          update: {
            args: Prisma.RiskItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskItemPayload>
          }
          deleteMany: {
            args: Prisma.RiskItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RiskItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RiskItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskItemPayload>[]
          }
          upsert: {
            args: Prisma.RiskItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskItemPayload>
          }
          aggregate: {
            args: Prisma.RiskItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRiskItem>
          }
          groupBy: {
            args: Prisma.RiskItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<RiskItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.RiskItemCountArgs<ExtArgs>
            result: $Utils.Optional<RiskItemCountAggregateOutputType> | number
          }
        }
      }
      CipaMeeting: {
        payload: Prisma.$CipaMeetingPayload<ExtArgs>
        fields: Prisma.CipaMeetingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CipaMeetingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CipaMeetingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CipaMeetingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CipaMeetingPayload>
          }
          findFirst: {
            args: Prisma.CipaMeetingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CipaMeetingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CipaMeetingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CipaMeetingPayload>
          }
          findMany: {
            args: Prisma.CipaMeetingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CipaMeetingPayload>[]
          }
          create: {
            args: Prisma.CipaMeetingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CipaMeetingPayload>
          }
          createMany: {
            args: Prisma.CipaMeetingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CipaMeetingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CipaMeetingPayload>[]
          }
          delete: {
            args: Prisma.CipaMeetingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CipaMeetingPayload>
          }
          update: {
            args: Prisma.CipaMeetingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CipaMeetingPayload>
          }
          deleteMany: {
            args: Prisma.CipaMeetingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CipaMeetingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CipaMeetingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CipaMeetingPayload>[]
          }
          upsert: {
            args: Prisma.CipaMeetingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CipaMeetingPayload>
          }
          aggregate: {
            args: Prisma.CipaMeetingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCipaMeeting>
          }
          groupBy: {
            args: Prisma.CipaMeetingGroupByArgs<ExtArgs>
            result: $Utils.Optional<CipaMeetingGroupByOutputType>[]
          }
          count: {
            args: Prisma.CipaMeetingCountArgs<ExtArgs>
            result: $Utils.Optional<CipaMeetingCountAggregateOutputType> | number
          }
        }
      }
      CipaAction: {
        payload: Prisma.$CipaActionPayload<ExtArgs>
        fields: Prisma.CipaActionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CipaActionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CipaActionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CipaActionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CipaActionPayload>
          }
          findFirst: {
            args: Prisma.CipaActionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CipaActionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CipaActionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CipaActionPayload>
          }
          findMany: {
            args: Prisma.CipaActionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CipaActionPayload>[]
          }
          create: {
            args: Prisma.CipaActionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CipaActionPayload>
          }
          createMany: {
            args: Prisma.CipaActionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CipaActionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CipaActionPayload>[]
          }
          delete: {
            args: Prisma.CipaActionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CipaActionPayload>
          }
          update: {
            args: Prisma.CipaActionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CipaActionPayload>
          }
          deleteMany: {
            args: Prisma.CipaActionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CipaActionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CipaActionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CipaActionPayload>[]
          }
          upsert: {
            args: Prisma.CipaActionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CipaActionPayload>
          }
          aggregate: {
            args: Prisma.CipaActionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCipaAction>
          }
          groupBy: {
            args: Prisma.CipaActionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CipaActionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CipaActionCountArgs<ExtArgs>
            result: $Utils.Optional<CipaActionCountAggregateOutputType> | number
          }
        }
      }
      PreventiveAction: {
        payload: Prisma.$PreventiveActionPayload<ExtArgs>
        fields: Prisma.PreventiveActionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PreventiveActionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreventiveActionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PreventiveActionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreventiveActionPayload>
          }
          findFirst: {
            args: Prisma.PreventiveActionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreventiveActionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PreventiveActionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreventiveActionPayload>
          }
          findMany: {
            args: Prisma.PreventiveActionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreventiveActionPayload>[]
          }
          create: {
            args: Prisma.PreventiveActionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreventiveActionPayload>
          }
          createMany: {
            args: Prisma.PreventiveActionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PreventiveActionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreventiveActionPayload>[]
          }
          delete: {
            args: Prisma.PreventiveActionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreventiveActionPayload>
          }
          update: {
            args: Prisma.PreventiveActionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreventiveActionPayload>
          }
          deleteMany: {
            args: Prisma.PreventiveActionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PreventiveActionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PreventiveActionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreventiveActionPayload>[]
          }
          upsert: {
            args: Prisma.PreventiveActionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreventiveActionPayload>
          }
          aggregate: {
            args: Prisma.PreventiveActionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePreventiveAction>
          }
          groupBy: {
            args: Prisma.PreventiveActionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PreventiveActionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PreventiveActionCountArgs<ExtArgs>
            result: $Utils.Optional<PreventiveActionCountAggregateOutputType> | number
          }
        }
      }
      DocumentRecord: {
        payload: Prisma.$DocumentRecordPayload<ExtArgs>
        fields: Prisma.DocumentRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentRecordPayload>
          }
          findFirst: {
            args: Prisma.DocumentRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentRecordPayload>
          }
          findMany: {
            args: Prisma.DocumentRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentRecordPayload>[]
          }
          create: {
            args: Prisma.DocumentRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentRecordPayload>
          }
          createMany: {
            args: Prisma.DocumentRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentRecordPayload>[]
          }
          delete: {
            args: Prisma.DocumentRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentRecordPayload>
          }
          update: {
            args: Prisma.DocumentRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentRecordPayload>
          }
          deleteMany: {
            args: Prisma.DocumentRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentRecordPayload>[]
          }
          upsert: {
            args: Prisma.DocumentRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentRecordPayload>
          }
          aggregate: {
            args: Prisma.DocumentRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocumentRecord>
          }
          groupBy: {
            args: Prisma.DocumentRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentRecordCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentRecordCountAggregateOutputType> | number
          }
        }
      }
      DocumentAction: {
        payload: Prisma.$DocumentActionPayload<ExtArgs>
        fields: Prisma.DocumentActionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentActionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentActionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentActionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentActionPayload>
          }
          findFirst: {
            args: Prisma.DocumentActionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentActionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentActionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentActionPayload>
          }
          findMany: {
            args: Prisma.DocumentActionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentActionPayload>[]
          }
          create: {
            args: Prisma.DocumentActionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentActionPayload>
          }
          createMany: {
            args: Prisma.DocumentActionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentActionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentActionPayload>[]
          }
          delete: {
            args: Prisma.DocumentActionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentActionPayload>
          }
          update: {
            args: Prisma.DocumentActionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentActionPayload>
          }
          deleteMany: {
            args: Prisma.DocumentActionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentActionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentActionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentActionPayload>[]
          }
          upsert: {
            args: Prisma.DocumentActionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentActionPayload>
          }
          aggregate: {
            args: Prisma.DocumentActionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocumentAction>
          }
          groupBy: {
            args: Prisma.DocumentActionGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentActionGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentActionCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentActionCountAggregateOutputType> | number
          }
        }
      }
      LawsuitRecord: {
        payload: Prisma.$LawsuitRecordPayload<ExtArgs>
        fields: Prisma.LawsuitRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LawsuitRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LawsuitRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LawsuitRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LawsuitRecordPayload>
          }
          findFirst: {
            args: Prisma.LawsuitRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LawsuitRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LawsuitRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LawsuitRecordPayload>
          }
          findMany: {
            args: Prisma.LawsuitRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LawsuitRecordPayload>[]
          }
          create: {
            args: Prisma.LawsuitRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LawsuitRecordPayload>
          }
          createMany: {
            args: Prisma.LawsuitRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LawsuitRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LawsuitRecordPayload>[]
          }
          delete: {
            args: Prisma.LawsuitRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LawsuitRecordPayload>
          }
          update: {
            args: Prisma.LawsuitRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LawsuitRecordPayload>
          }
          deleteMany: {
            args: Prisma.LawsuitRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LawsuitRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LawsuitRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LawsuitRecordPayload>[]
          }
          upsert: {
            args: Prisma.LawsuitRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LawsuitRecordPayload>
          }
          aggregate: {
            args: Prisma.LawsuitRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLawsuitRecord>
          }
          groupBy: {
            args: Prisma.LawsuitRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<LawsuitRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.LawsuitRecordCountArgs<ExtArgs>
            result: $Utils.Optional<LawsuitRecordCountAggregateOutputType> | number
          }
        }
      }
      AccidentRecord: {
        payload: Prisma.$AccidentRecordPayload<ExtArgs>
        fields: Prisma.AccidentRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccidentRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccidentRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccidentRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccidentRecordPayload>
          }
          findFirst: {
            args: Prisma.AccidentRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccidentRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccidentRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccidentRecordPayload>
          }
          findMany: {
            args: Prisma.AccidentRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccidentRecordPayload>[]
          }
          create: {
            args: Prisma.AccidentRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccidentRecordPayload>
          }
          createMany: {
            args: Prisma.AccidentRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccidentRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccidentRecordPayload>[]
          }
          delete: {
            args: Prisma.AccidentRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccidentRecordPayload>
          }
          update: {
            args: Prisma.AccidentRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccidentRecordPayload>
          }
          deleteMany: {
            args: Prisma.AccidentRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccidentRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccidentRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccidentRecordPayload>[]
          }
          upsert: {
            args: Prisma.AccidentRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccidentRecordPayload>
          }
          aggregate: {
            args: Prisma.AccidentRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccidentRecord>
          }
          groupBy: {
            args: Prisma.AccidentRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccidentRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccidentRecordCountArgs<ExtArgs>
            result: $Utils.Optional<AccidentRecordCountAggregateOutputType> | number
          }
        }
      }
      OccupationalDiseaseRecord: {
        payload: Prisma.$OccupationalDiseaseRecordPayload<ExtArgs>
        fields: Prisma.OccupationalDiseaseRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OccupationalDiseaseRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OccupationalDiseaseRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OccupationalDiseaseRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OccupationalDiseaseRecordPayload>
          }
          findFirst: {
            args: Prisma.OccupationalDiseaseRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OccupationalDiseaseRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OccupationalDiseaseRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OccupationalDiseaseRecordPayload>
          }
          findMany: {
            args: Prisma.OccupationalDiseaseRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OccupationalDiseaseRecordPayload>[]
          }
          create: {
            args: Prisma.OccupationalDiseaseRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OccupationalDiseaseRecordPayload>
          }
          createMany: {
            args: Prisma.OccupationalDiseaseRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OccupationalDiseaseRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OccupationalDiseaseRecordPayload>[]
          }
          delete: {
            args: Prisma.OccupationalDiseaseRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OccupationalDiseaseRecordPayload>
          }
          update: {
            args: Prisma.OccupationalDiseaseRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OccupationalDiseaseRecordPayload>
          }
          deleteMany: {
            args: Prisma.OccupationalDiseaseRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OccupationalDiseaseRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OccupationalDiseaseRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OccupationalDiseaseRecordPayload>[]
          }
          upsert: {
            args: Prisma.OccupationalDiseaseRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OccupationalDiseaseRecordPayload>
          }
          aggregate: {
            args: Prisma.OccupationalDiseaseRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOccupationalDiseaseRecord>
          }
          groupBy: {
            args: Prisma.OccupationalDiseaseRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<OccupationalDiseaseRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.OccupationalDiseaseRecordCountArgs<ExtArgs>
            result: $Utils.Optional<OccupationalDiseaseRecordCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    employee?: EmployeeOmit
    trainingType?: TrainingTypeOmit
    trainingRecord?: TrainingRecordOmit
    ppeRecord?: PpeRecordOmit
    asoRecord?: AsoRecordOmit
    chemicalRecord?: ChemicalRecordOmit
    jsaRecord?: JsaRecordOmit
    riskItem?: RiskItemOmit
    cipaMeeting?: CipaMeetingOmit
    cipaAction?: CipaActionOmit
    preventiveAction?: PreventiveActionOmit
    documentRecord?: DocumentRecordOmit
    documentAction?: DocumentActionOmit
    lawsuitRecord?: LawsuitRecordOmit
    accidentRecord?: AccidentRecordOmit
    occupationalDiseaseRecord?: OccupationalDiseaseRecordOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type EmployeeCountOutputType
   */

  export type EmployeeCountOutputType = {
    ppeRecords: number
    asoRecords: number
    trainings: number
    accidents: number
    diseases: number
  }

  export type EmployeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ppeRecords?: boolean | EmployeeCountOutputTypeCountPpeRecordsArgs
    asoRecords?: boolean | EmployeeCountOutputTypeCountAsoRecordsArgs
    trainings?: boolean | EmployeeCountOutputTypeCountTrainingsArgs
    accidents?: boolean | EmployeeCountOutputTypeCountAccidentsArgs
    diseases?: boolean | EmployeeCountOutputTypeCountDiseasesArgs
  }

  // Custom InputTypes
  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeCountOutputType
     */
    select?: EmployeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountPpeRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PpeRecordWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountAsoRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AsoRecordWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountTrainingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingRecordWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountAccidentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccidentRecordWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountDiseasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OccupationalDiseaseRecordWhereInput
  }


  /**
   * Count Type TrainingTypeCountOutputType
   */

  export type TrainingTypeCountOutputType = {
    trainingRecords: number
  }

  export type TrainingTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trainingRecords?: boolean | TrainingTypeCountOutputTypeCountTrainingRecordsArgs
  }

  // Custom InputTypes
  /**
   * TrainingTypeCountOutputType without action
   */
  export type TrainingTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingTypeCountOutputType
     */
    select?: TrainingTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TrainingTypeCountOutputType without action
   */
  export type TrainingTypeCountOutputTypeCountTrainingRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingRecordWhereInput
  }


  /**
   * Count Type JsaRecordCountOutputType
   */

  export type JsaRecordCountOutputType = {
    risks: number
  }

  export type JsaRecordCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    risks?: boolean | JsaRecordCountOutputTypeCountRisksArgs
  }

  // Custom InputTypes
  /**
   * JsaRecordCountOutputType without action
   */
  export type JsaRecordCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JsaRecordCountOutputType
     */
    select?: JsaRecordCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JsaRecordCountOutputType without action
   */
  export type JsaRecordCountOutputTypeCountRisksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RiskItemWhereInput
  }


  /**
   * Count Type CipaMeetingCountOutputType
   */

  export type CipaMeetingCountOutputType = {
    actionsDefined: number
  }

  export type CipaMeetingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actionsDefined?: boolean | CipaMeetingCountOutputTypeCountActionsDefinedArgs
  }

  // Custom InputTypes
  /**
   * CipaMeetingCountOutputType without action
   */
  export type CipaMeetingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CipaMeetingCountOutputType
     */
    select?: CipaMeetingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CipaMeetingCountOutputType without action
   */
  export type CipaMeetingCountOutputTypeCountActionsDefinedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CipaActionWhereInput
  }


  /**
   * Count Type DocumentRecordCountOutputType
   */

  export type DocumentRecordCountOutputType = {
    relatedActions: number
  }

  export type DocumentRecordCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    relatedActions?: boolean | DocumentRecordCountOutputTypeCountRelatedActionsArgs
  }

  // Custom InputTypes
  /**
   * DocumentRecordCountOutputType without action
   */
  export type DocumentRecordCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRecordCountOutputType
     */
    select?: DocumentRecordCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DocumentRecordCountOutputType without action
   */
  export type DocumentRecordCountOutputTypeCountRelatedActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentActionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Employee
   */

  export type AggregateEmployee = {
    _count: EmployeeCountAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  export type EmployeeMinAggregateOutputType = {
    id: string | null
    name: string | null
    department: string | null
    position: string | null
    hireDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    department: string | null
    position: string | null
    hireDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeCountAggregateOutputType = {
    id: number
    name: number
    department: number
    position: number
    hireDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmployeeMinAggregateInputType = {
    id?: true
    name?: true
    department?: true
    position?: true
    hireDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeMaxAggregateInputType = {
    id?: true
    name?: true
    department?: true
    position?: true
    hireDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeCountAggregateInputType = {
    id?: true
    name?: true
    department?: true
    position?: true
    hireDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employee to aggregate.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Employees
    **/
    _count?: true | EmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeMaxAggregateInputType
  }

  export type GetEmployeeAggregateType<T extends EmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee[P]>
      : GetScalarType<T[P], AggregateEmployee[P]>
  }




  export type EmployeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithAggregationInput | EmployeeOrderByWithAggregationInput[]
    by: EmployeeScalarFieldEnum[] | EmployeeScalarFieldEnum
    having?: EmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeCountAggregateInputType | true
    _min?: EmployeeMinAggregateInputType
    _max?: EmployeeMaxAggregateInputType
  }

  export type EmployeeGroupByOutputType = {
    id: string
    name: string
    department: string | null
    position: string | null
    hireDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: EmployeeCountAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  type GetEmployeeGroupByPayload<T extends EmployeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    department?: boolean
    position?: boolean
    hireDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ppeRecords?: boolean | Employee$ppeRecordsArgs<ExtArgs>
    asoRecords?: boolean | Employee$asoRecordsArgs<ExtArgs>
    trainings?: boolean | Employee$trainingsArgs<ExtArgs>
    accidents?: boolean | Employee$accidentsArgs<ExtArgs>
    diseases?: boolean | Employee$diseasesArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    department?: boolean
    position?: boolean
    hireDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    department?: boolean
    position?: boolean
    hireDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectScalar = {
    id?: boolean
    name?: boolean
    department?: boolean
    position?: boolean
    hireDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmployeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "department" | "position" | "hireDate" | "createdAt" | "updatedAt", ExtArgs["result"]["employee"]>
  export type EmployeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ppeRecords?: boolean | Employee$ppeRecordsArgs<ExtArgs>
    asoRecords?: boolean | Employee$asoRecordsArgs<ExtArgs>
    trainings?: boolean | Employee$trainingsArgs<ExtArgs>
    accidents?: boolean | Employee$accidentsArgs<ExtArgs>
    diseases?: boolean | Employee$diseasesArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmployeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type EmployeeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EmployeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Employee"
    objects: {
      ppeRecords: Prisma.$PpeRecordPayload<ExtArgs>[]
      asoRecords: Prisma.$AsoRecordPayload<ExtArgs>[]
      trainings: Prisma.$TrainingRecordPayload<ExtArgs>[]
      accidents: Prisma.$AccidentRecordPayload<ExtArgs>[]
      diseases: Prisma.$OccupationalDiseaseRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      department: string | null
      position: string | null
      hireDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["employee"]>
    composites: {}
  }

  type EmployeeGetPayload<S extends boolean | null | undefined | EmployeeDefaultArgs> = $Result.GetResult<Prisma.$EmployeePayload, S>

  type EmployeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeCountAggregateInputType | true
    }

  export interface EmployeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Employee'], meta: { name: 'Employee' } }
    /**
     * Find zero or one Employee that matches the filter.
     * @param {EmployeeFindUniqueArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeFindUniqueArgs>(args: SelectSubset<T, EmployeeFindUniqueArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Employee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeFindUniqueOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeFindFirstArgs>(args?: SelectSubset<T, EmployeeFindFirstArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employee.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeWithIdOnly = await prisma.employee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeFindManyArgs>(args?: SelectSubset<T, EmployeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Employee.
     * @param {EmployeeCreateArgs} args - Arguments to create a Employee.
     * @example
     * // Create one Employee
     * const Employee = await prisma.employee.create({
     *   data: {
     *     // ... data to create a Employee
     *   }
     * })
     * 
     */
    create<T extends EmployeeCreateArgs>(args: SelectSubset<T, EmployeeCreateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Employees.
     * @param {EmployeeCreateManyArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeCreateManyArgs>(args?: SelectSubset<T, EmployeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Employees and returns the data saved in the database.
     * @param {EmployeeCreateManyAndReturnArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Employee.
     * @param {EmployeeDeleteArgs} args - Arguments to delete one Employee.
     * @example
     * // Delete one Employee
     * const Employee = await prisma.employee.delete({
     *   where: {
     *     // ... filter to delete one Employee
     *   }
     * })
     * 
     */
    delete<T extends EmployeeDeleteArgs>(args: SelectSubset<T, EmployeeDeleteArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Employee.
     * @param {EmployeeUpdateArgs} args - Arguments to update one Employee.
     * @example
     * // Update one Employee
     * const employee = await prisma.employee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeUpdateArgs>(args: SelectSubset<T, EmployeeUpdateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Employees.
     * @param {EmployeeDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeDeleteManyArgs>(args?: SelectSubset<T, EmployeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeUpdateManyArgs>(args: SelectSubset<T, EmployeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees and returns the data updated in the database.
     * @param {EmployeeUpdateManyAndReturnArgs} args - Arguments to update many Employees.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployeeUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployeeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Employee.
     * @param {EmployeeUpsertArgs} args - Arguments to update or create a Employee.
     * @example
     * // Update or create a Employee
     * const employee = await prisma.employee.upsert({
     *   create: {
     *     // ... data to create a Employee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeUpsertArgs>(args: SelectSubset<T, EmployeeUpsertArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employee.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends EmployeeCountArgs>(
      args?: Subset<T, EmployeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeAggregateArgs>(args: Subset<T, EmployeeAggregateArgs>): Prisma.PrismaPromise<GetEmployeeAggregateType<T>>

    /**
     * Group by Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Employee model
   */
  readonly fields: EmployeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Employee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ppeRecords<T extends Employee$ppeRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$ppeRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PpeRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    asoRecords<T extends Employee$asoRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$asoRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AsoRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    trainings<T extends Employee$trainingsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$trainingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accidents<T extends Employee$accidentsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$accidentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccidentRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    diseases<T extends Employee$diseasesArgs<ExtArgs> = {}>(args?: Subset<T, Employee$diseasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OccupationalDiseaseRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Employee model
   */
  interface EmployeeFieldRefs {
    readonly id: FieldRef<"Employee", 'String'>
    readonly name: FieldRef<"Employee", 'String'>
    readonly department: FieldRef<"Employee", 'String'>
    readonly position: FieldRef<"Employee", 'String'>
    readonly hireDate: FieldRef<"Employee", 'DateTime'>
    readonly createdAt: FieldRef<"Employee", 'DateTime'>
    readonly updatedAt: FieldRef<"Employee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Employee findUnique
   */
  export type EmployeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findUniqueOrThrow
   */
  export type EmployeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findFirst
   */
  export type EmployeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findFirstOrThrow
   */
  export type EmployeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findMany
   */
  export type EmployeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee create
   */
  export type EmployeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to create a Employee.
     */
    data: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
  }

  /**
   * Employee createMany
   */
  export type EmployeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
  }

  /**
   * Employee createManyAndReturn
   */
  export type EmployeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
  }

  /**
   * Employee update
   */
  export type EmployeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to update a Employee.
     */
    data: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
    /**
     * Choose, which Employee to update.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee updateMany
   */
  export type EmployeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
  }

  /**
   * Employee updateManyAndReturn
   */
  export type EmployeeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
  }

  /**
   * Employee upsert
   */
  export type EmployeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The filter to search for the Employee to update in case it exists.
     */
    where: EmployeeWhereUniqueInput
    /**
     * In case the Employee found by the `where` argument doesn't exist, create a new Employee with this data.
     */
    create: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
    /**
     * In case the Employee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
  }

  /**
   * Employee delete
   */
  export type EmployeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter which Employee to delete.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee deleteMany
   */
  export type EmployeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employees to delete
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to delete.
     */
    limit?: number
  }

  /**
   * Employee.ppeRecords
   */
  export type Employee$ppeRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PpeRecord
     */
    select?: PpeRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PpeRecord
     */
    omit?: PpeRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PpeRecordInclude<ExtArgs> | null
    where?: PpeRecordWhereInput
    orderBy?: PpeRecordOrderByWithRelationInput | PpeRecordOrderByWithRelationInput[]
    cursor?: PpeRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PpeRecordScalarFieldEnum | PpeRecordScalarFieldEnum[]
  }

  /**
   * Employee.asoRecords
   */
  export type Employee$asoRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AsoRecord
     */
    select?: AsoRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AsoRecord
     */
    omit?: AsoRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsoRecordInclude<ExtArgs> | null
    where?: AsoRecordWhereInput
    orderBy?: AsoRecordOrderByWithRelationInput | AsoRecordOrderByWithRelationInput[]
    cursor?: AsoRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AsoRecordScalarFieldEnum | AsoRecordScalarFieldEnum[]
  }

  /**
   * Employee.trainings
   */
  export type Employee$trainingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingRecord
     */
    select?: TrainingRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingRecord
     */
    omit?: TrainingRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingRecordInclude<ExtArgs> | null
    where?: TrainingRecordWhereInput
    orderBy?: TrainingRecordOrderByWithRelationInput | TrainingRecordOrderByWithRelationInput[]
    cursor?: TrainingRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingRecordScalarFieldEnum | TrainingRecordScalarFieldEnum[]
  }

  /**
   * Employee.accidents
   */
  export type Employee$accidentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccidentRecord
     */
    select?: AccidentRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccidentRecord
     */
    omit?: AccidentRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccidentRecordInclude<ExtArgs> | null
    where?: AccidentRecordWhereInput
    orderBy?: AccidentRecordOrderByWithRelationInput | AccidentRecordOrderByWithRelationInput[]
    cursor?: AccidentRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccidentRecordScalarFieldEnum | AccidentRecordScalarFieldEnum[]
  }

  /**
   * Employee.diseases
   */
  export type Employee$diseasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OccupationalDiseaseRecord
     */
    select?: OccupationalDiseaseRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OccupationalDiseaseRecord
     */
    omit?: OccupationalDiseaseRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccupationalDiseaseRecordInclude<ExtArgs> | null
    where?: OccupationalDiseaseRecordWhereInput
    orderBy?: OccupationalDiseaseRecordOrderByWithRelationInput | OccupationalDiseaseRecordOrderByWithRelationInput[]
    cursor?: OccupationalDiseaseRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OccupationalDiseaseRecordScalarFieldEnum | OccupationalDiseaseRecordScalarFieldEnum[]
  }

  /**
   * Employee without action
   */
  export type EmployeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
  }


  /**
   * Model TrainingType
   */

  export type AggregateTrainingType = {
    _count: TrainingTypeCountAggregateOutputType | null
    _avg: TrainingTypeAvgAggregateOutputType | null
    _sum: TrainingTypeSumAggregateOutputType | null
    _min: TrainingTypeMinAggregateOutputType | null
    _max: TrainingTypeMaxAggregateOutputType | null
  }

  export type TrainingTypeAvgAggregateOutputType = {
    validityMonths: number | null
    defaultDuration: number | null
    defaultCost: number | null
  }

  export type TrainingTypeSumAggregateOutputType = {
    validityMonths: number | null
    defaultDuration: number | null
    defaultCost: number | null
  }

  export type TrainingTypeMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    validityMonths: number | null
    requiredNrsJson: string | null
    defaultDuration: number | null
    defaultLocation: string | null
    defaultCost: number | null
    instructorsJson: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingTypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    validityMonths: number | null
    requiredNrsJson: string | null
    defaultDuration: number | null
    defaultLocation: string | null
    defaultCost: number | null
    instructorsJson: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingTypeCountAggregateOutputType = {
    id: number
    name: number
    description: number
    validityMonths: number
    requiredNrsJson: number
    defaultDuration: number
    defaultLocation: number
    defaultCost: number
    instructorsJson: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TrainingTypeAvgAggregateInputType = {
    validityMonths?: true
    defaultDuration?: true
    defaultCost?: true
  }

  export type TrainingTypeSumAggregateInputType = {
    validityMonths?: true
    defaultDuration?: true
    defaultCost?: true
  }

  export type TrainingTypeMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    validityMonths?: true
    requiredNrsJson?: true
    defaultDuration?: true
    defaultLocation?: true
    defaultCost?: true
    instructorsJson?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingTypeMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    validityMonths?: true
    requiredNrsJson?: true
    defaultDuration?: true
    defaultLocation?: true
    defaultCost?: true
    instructorsJson?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingTypeCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    validityMonths?: true
    requiredNrsJson?: true
    defaultDuration?: true
    defaultLocation?: true
    defaultCost?: true
    instructorsJson?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TrainingTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingType to aggregate.
     */
    where?: TrainingTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingTypes to fetch.
     */
    orderBy?: TrainingTypeOrderByWithRelationInput | TrainingTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrainingTypes
    **/
    _count?: true | TrainingTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrainingTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrainingTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingTypeMaxAggregateInputType
  }

  export type GetTrainingTypeAggregateType<T extends TrainingTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainingType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainingType[P]>
      : GetScalarType<T[P], AggregateTrainingType[P]>
  }




  export type TrainingTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingTypeWhereInput
    orderBy?: TrainingTypeOrderByWithAggregationInput | TrainingTypeOrderByWithAggregationInput[]
    by: TrainingTypeScalarFieldEnum[] | TrainingTypeScalarFieldEnum
    having?: TrainingTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingTypeCountAggregateInputType | true
    _avg?: TrainingTypeAvgAggregateInputType
    _sum?: TrainingTypeSumAggregateInputType
    _min?: TrainingTypeMinAggregateInputType
    _max?: TrainingTypeMaxAggregateInputType
  }

  export type TrainingTypeGroupByOutputType = {
    id: string
    name: string
    description: string | null
    validityMonths: number | null
    requiredNrsJson: string | null
    defaultDuration: number | null
    defaultLocation: string | null
    defaultCost: number | null
    instructorsJson: string | null
    createdAt: Date
    updatedAt: Date
    _count: TrainingTypeCountAggregateOutputType | null
    _avg: TrainingTypeAvgAggregateOutputType | null
    _sum: TrainingTypeSumAggregateOutputType | null
    _min: TrainingTypeMinAggregateOutputType | null
    _max: TrainingTypeMaxAggregateOutputType | null
  }

  type GetTrainingTypeGroupByPayload<T extends TrainingTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingTypeGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingTypeGroupByOutputType[P]>
        }
      >
    >


  export type TrainingTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    validityMonths?: boolean
    requiredNrsJson?: boolean
    defaultDuration?: boolean
    defaultLocation?: boolean
    defaultCost?: boolean
    instructorsJson?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trainingRecords?: boolean | TrainingType$trainingRecordsArgs<ExtArgs>
    _count?: boolean | TrainingTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingType"]>

  export type TrainingTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    validityMonths?: boolean
    requiredNrsJson?: boolean
    defaultDuration?: boolean
    defaultLocation?: boolean
    defaultCost?: boolean
    instructorsJson?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["trainingType"]>

  export type TrainingTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    validityMonths?: boolean
    requiredNrsJson?: boolean
    defaultDuration?: boolean
    defaultLocation?: boolean
    defaultCost?: boolean
    instructorsJson?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["trainingType"]>

  export type TrainingTypeSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    validityMonths?: boolean
    requiredNrsJson?: boolean
    defaultDuration?: boolean
    defaultLocation?: boolean
    defaultCost?: boolean
    instructorsJson?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TrainingTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "validityMonths" | "requiredNrsJson" | "defaultDuration" | "defaultLocation" | "defaultCost" | "instructorsJson" | "createdAt" | "updatedAt", ExtArgs["result"]["trainingType"]>
  export type TrainingTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trainingRecords?: boolean | TrainingType$trainingRecordsArgs<ExtArgs>
    _count?: boolean | TrainingTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TrainingTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TrainingTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TrainingTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrainingType"
    objects: {
      trainingRecords: Prisma.$TrainingRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      validityMonths: number | null
      requiredNrsJson: string | null
      defaultDuration: number | null
      defaultLocation: string | null
      defaultCost: number | null
      instructorsJson: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["trainingType"]>
    composites: {}
  }

  type TrainingTypeGetPayload<S extends boolean | null | undefined | TrainingTypeDefaultArgs> = $Result.GetResult<Prisma.$TrainingTypePayload, S>

  type TrainingTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrainingTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrainingTypeCountAggregateInputType | true
    }

  export interface TrainingTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrainingType'], meta: { name: 'TrainingType' } }
    /**
     * Find zero or one TrainingType that matches the filter.
     * @param {TrainingTypeFindUniqueArgs} args - Arguments to find a TrainingType
     * @example
     * // Get one TrainingType
     * const trainingType = await prisma.trainingType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrainingTypeFindUniqueArgs>(args: SelectSubset<T, TrainingTypeFindUniqueArgs<ExtArgs>>): Prisma__TrainingTypeClient<$Result.GetResult<Prisma.$TrainingTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TrainingType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrainingTypeFindUniqueOrThrowArgs} args - Arguments to find a TrainingType
     * @example
     * // Get one TrainingType
     * const trainingType = await prisma.trainingType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrainingTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, TrainingTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrainingTypeClient<$Result.GetResult<Prisma.$TrainingTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingTypeFindFirstArgs} args - Arguments to find a TrainingType
     * @example
     * // Get one TrainingType
     * const trainingType = await prisma.trainingType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrainingTypeFindFirstArgs>(args?: SelectSubset<T, TrainingTypeFindFirstArgs<ExtArgs>>): Prisma__TrainingTypeClient<$Result.GetResult<Prisma.$TrainingTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingTypeFindFirstOrThrowArgs} args - Arguments to find a TrainingType
     * @example
     * // Get one TrainingType
     * const trainingType = await prisma.trainingType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrainingTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, TrainingTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrainingTypeClient<$Result.GetResult<Prisma.$TrainingTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TrainingTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrainingTypes
     * const trainingTypes = await prisma.trainingType.findMany()
     * 
     * // Get first 10 TrainingTypes
     * const trainingTypes = await prisma.trainingType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingTypeWithIdOnly = await prisma.trainingType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrainingTypeFindManyArgs>(args?: SelectSubset<T, TrainingTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TrainingType.
     * @param {TrainingTypeCreateArgs} args - Arguments to create a TrainingType.
     * @example
     * // Create one TrainingType
     * const TrainingType = await prisma.trainingType.create({
     *   data: {
     *     // ... data to create a TrainingType
     *   }
     * })
     * 
     */
    create<T extends TrainingTypeCreateArgs>(args: SelectSubset<T, TrainingTypeCreateArgs<ExtArgs>>): Prisma__TrainingTypeClient<$Result.GetResult<Prisma.$TrainingTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TrainingTypes.
     * @param {TrainingTypeCreateManyArgs} args - Arguments to create many TrainingTypes.
     * @example
     * // Create many TrainingTypes
     * const trainingType = await prisma.trainingType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrainingTypeCreateManyArgs>(args?: SelectSubset<T, TrainingTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrainingTypes and returns the data saved in the database.
     * @param {TrainingTypeCreateManyAndReturnArgs} args - Arguments to create many TrainingTypes.
     * @example
     * // Create many TrainingTypes
     * const trainingType = await prisma.trainingType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrainingTypes and only return the `id`
     * const trainingTypeWithIdOnly = await prisma.trainingType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrainingTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, TrainingTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TrainingType.
     * @param {TrainingTypeDeleteArgs} args - Arguments to delete one TrainingType.
     * @example
     * // Delete one TrainingType
     * const TrainingType = await prisma.trainingType.delete({
     *   where: {
     *     // ... filter to delete one TrainingType
     *   }
     * })
     * 
     */
    delete<T extends TrainingTypeDeleteArgs>(args: SelectSubset<T, TrainingTypeDeleteArgs<ExtArgs>>): Prisma__TrainingTypeClient<$Result.GetResult<Prisma.$TrainingTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TrainingType.
     * @param {TrainingTypeUpdateArgs} args - Arguments to update one TrainingType.
     * @example
     * // Update one TrainingType
     * const trainingType = await prisma.trainingType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrainingTypeUpdateArgs>(args: SelectSubset<T, TrainingTypeUpdateArgs<ExtArgs>>): Prisma__TrainingTypeClient<$Result.GetResult<Prisma.$TrainingTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TrainingTypes.
     * @param {TrainingTypeDeleteManyArgs} args - Arguments to filter TrainingTypes to delete.
     * @example
     * // Delete a few TrainingTypes
     * const { count } = await prisma.trainingType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrainingTypeDeleteManyArgs>(args?: SelectSubset<T, TrainingTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrainingTypes
     * const trainingType = await prisma.trainingType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrainingTypeUpdateManyArgs>(args: SelectSubset<T, TrainingTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingTypes and returns the data updated in the database.
     * @param {TrainingTypeUpdateManyAndReturnArgs} args - Arguments to update many TrainingTypes.
     * @example
     * // Update many TrainingTypes
     * const trainingType = await prisma.trainingType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TrainingTypes and only return the `id`
     * const trainingTypeWithIdOnly = await prisma.trainingType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TrainingTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, TrainingTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TrainingType.
     * @param {TrainingTypeUpsertArgs} args - Arguments to update or create a TrainingType.
     * @example
     * // Update or create a TrainingType
     * const trainingType = await prisma.trainingType.upsert({
     *   create: {
     *     // ... data to create a TrainingType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrainingType we want to update
     *   }
     * })
     */
    upsert<T extends TrainingTypeUpsertArgs>(args: SelectSubset<T, TrainingTypeUpsertArgs<ExtArgs>>): Prisma__TrainingTypeClient<$Result.GetResult<Prisma.$TrainingTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TrainingTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingTypeCountArgs} args - Arguments to filter TrainingTypes to count.
     * @example
     * // Count the number of TrainingTypes
     * const count = await prisma.trainingType.count({
     *   where: {
     *     // ... the filter for the TrainingTypes we want to count
     *   }
     * })
    **/
    count<T extends TrainingTypeCountArgs>(
      args?: Subset<T, TrainingTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrainingType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingTypeAggregateArgs>(args: Subset<T, TrainingTypeAggregateArgs>): Prisma.PrismaPromise<GetTrainingTypeAggregateType<T>>

    /**
     * Group by TrainingType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingTypeGroupByArgs['orderBy'] }
        : { orderBy?: TrainingTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrainingType model
   */
  readonly fields: TrainingTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrainingType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainingTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    trainingRecords<T extends TrainingType$trainingRecordsArgs<ExtArgs> = {}>(args?: Subset<T, TrainingType$trainingRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrainingType model
   */
  interface TrainingTypeFieldRefs {
    readonly id: FieldRef<"TrainingType", 'String'>
    readonly name: FieldRef<"TrainingType", 'String'>
    readonly description: FieldRef<"TrainingType", 'String'>
    readonly validityMonths: FieldRef<"TrainingType", 'Int'>
    readonly requiredNrsJson: FieldRef<"TrainingType", 'String'>
    readonly defaultDuration: FieldRef<"TrainingType", 'Int'>
    readonly defaultLocation: FieldRef<"TrainingType", 'String'>
    readonly defaultCost: FieldRef<"TrainingType", 'Float'>
    readonly instructorsJson: FieldRef<"TrainingType", 'String'>
    readonly createdAt: FieldRef<"TrainingType", 'DateTime'>
    readonly updatedAt: FieldRef<"TrainingType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrainingType findUnique
   */
  export type TrainingTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingType
     */
    select?: TrainingTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingType
     */
    omit?: TrainingTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingTypeInclude<ExtArgs> | null
    /**
     * Filter, which TrainingType to fetch.
     */
    where: TrainingTypeWhereUniqueInput
  }

  /**
   * TrainingType findUniqueOrThrow
   */
  export type TrainingTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingType
     */
    select?: TrainingTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingType
     */
    omit?: TrainingTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingTypeInclude<ExtArgs> | null
    /**
     * Filter, which TrainingType to fetch.
     */
    where: TrainingTypeWhereUniqueInput
  }

  /**
   * TrainingType findFirst
   */
  export type TrainingTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingType
     */
    select?: TrainingTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingType
     */
    omit?: TrainingTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingTypeInclude<ExtArgs> | null
    /**
     * Filter, which TrainingType to fetch.
     */
    where?: TrainingTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingTypes to fetch.
     */
    orderBy?: TrainingTypeOrderByWithRelationInput | TrainingTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingTypes.
     */
    cursor?: TrainingTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingTypes.
     */
    distinct?: TrainingTypeScalarFieldEnum | TrainingTypeScalarFieldEnum[]
  }

  /**
   * TrainingType findFirstOrThrow
   */
  export type TrainingTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingType
     */
    select?: TrainingTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingType
     */
    omit?: TrainingTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingTypeInclude<ExtArgs> | null
    /**
     * Filter, which TrainingType to fetch.
     */
    where?: TrainingTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingTypes to fetch.
     */
    orderBy?: TrainingTypeOrderByWithRelationInput | TrainingTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingTypes.
     */
    cursor?: TrainingTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingTypes.
     */
    distinct?: TrainingTypeScalarFieldEnum | TrainingTypeScalarFieldEnum[]
  }

  /**
   * TrainingType findMany
   */
  export type TrainingTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingType
     */
    select?: TrainingTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingType
     */
    omit?: TrainingTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingTypeInclude<ExtArgs> | null
    /**
     * Filter, which TrainingTypes to fetch.
     */
    where?: TrainingTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingTypes to fetch.
     */
    orderBy?: TrainingTypeOrderByWithRelationInput | TrainingTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrainingTypes.
     */
    cursor?: TrainingTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingTypes.
     */
    skip?: number
    distinct?: TrainingTypeScalarFieldEnum | TrainingTypeScalarFieldEnum[]
  }

  /**
   * TrainingType create
   */
  export type TrainingTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingType
     */
    select?: TrainingTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingType
     */
    omit?: TrainingTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a TrainingType.
     */
    data: XOR<TrainingTypeCreateInput, TrainingTypeUncheckedCreateInput>
  }

  /**
   * TrainingType createMany
   */
  export type TrainingTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrainingTypes.
     */
    data: TrainingTypeCreateManyInput | TrainingTypeCreateManyInput[]
  }

  /**
   * TrainingType createManyAndReturn
   */
  export type TrainingTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingType
     */
    select?: TrainingTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingType
     */
    omit?: TrainingTypeOmit<ExtArgs> | null
    /**
     * The data used to create many TrainingTypes.
     */
    data: TrainingTypeCreateManyInput | TrainingTypeCreateManyInput[]
  }

  /**
   * TrainingType update
   */
  export type TrainingTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingType
     */
    select?: TrainingTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingType
     */
    omit?: TrainingTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a TrainingType.
     */
    data: XOR<TrainingTypeUpdateInput, TrainingTypeUncheckedUpdateInput>
    /**
     * Choose, which TrainingType to update.
     */
    where: TrainingTypeWhereUniqueInput
  }

  /**
   * TrainingType updateMany
   */
  export type TrainingTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrainingTypes.
     */
    data: XOR<TrainingTypeUpdateManyMutationInput, TrainingTypeUncheckedUpdateManyInput>
    /**
     * Filter which TrainingTypes to update
     */
    where?: TrainingTypeWhereInput
    /**
     * Limit how many TrainingTypes to update.
     */
    limit?: number
  }

  /**
   * TrainingType updateManyAndReturn
   */
  export type TrainingTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingType
     */
    select?: TrainingTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingType
     */
    omit?: TrainingTypeOmit<ExtArgs> | null
    /**
     * The data used to update TrainingTypes.
     */
    data: XOR<TrainingTypeUpdateManyMutationInput, TrainingTypeUncheckedUpdateManyInput>
    /**
     * Filter which TrainingTypes to update
     */
    where?: TrainingTypeWhereInput
    /**
     * Limit how many TrainingTypes to update.
     */
    limit?: number
  }

  /**
   * TrainingType upsert
   */
  export type TrainingTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingType
     */
    select?: TrainingTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingType
     */
    omit?: TrainingTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the TrainingType to update in case it exists.
     */
    where: TrainingTypeWhereUniqueInput
    /**
     * In case the TrainingType found by the `where` argument doesn't exist, create a new TrainingType with this data.
     */
    create: XOR<TrainingTypeCreateInput, TrainingTypeUncheckedCreateInput>
    /**
     * In case the TrainingType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingTypeUpdateInput, TrainingTypeUncheckedUpdateInput>
  }

  /**
   * TrainingType delete
   */
  export type TrainingTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingType
     */
    select?: TrainingTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingType
     */
    omit?: TrainingTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingTypeInclude<ExtArgs> | null
    /**
     * Filter which TrainingType to delete.
     */
    where: TrainingTypeWhereUniqueInput
  }

  /**
   * TrainingType deleteMany
   */
  export type TrainingTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingTypes to delete
     */
    where?: TrainingTypeWhereInput
    /**
     * Limit how many TrainingTypes to delete.
     */
    limit?: number
  }

  /**
   * TrainingType.trainingRecords
   */
  export type TrainingType$trainingRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingRecord
     */
    select?: TrainingRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingRecord
     */
    omit?: TrainingRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingRecordInclude<ExtArgs> | null
    where?: TrainingRecordWhereInput
    orderBy?: TrainingRecordOrderByWithRelationInput | TrainingRecordOrderByWithRelationInput[]
    cursor?: TrainingRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingRecordScalarFieldEnum | TrainingRecordScalarFieldEnum[]
  }

  /**
   * TrainingType without action
   */
  export type TrainingTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingType
     */
    select?: TrainingTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingType
     */
    omit?: TrainingTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingTypeInclude<ExtArgs> | null
  }


  /**
   * Model TrainingRecord
   */

  export type AggregateTrainingRecord = {
    _count: TrainingRecordCountAggregateOutputType | null
    _min: TrainingRecordMinAggregateOutputType | null
    _max: TrainingRecordMaxAggregateOutputType | null
  }

  export type TrainingRecordMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    trainingTypeId: string | null
    trainingDate: Date | null
    expiryDate: Date | null
    status: string | null
    attendanceListUrl: string | null
    certificateUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingRecordMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    trainingTypeId: string | null
    trainingDate: Date | null
    expiryDate: Date | null
    status: string | null
    attendanceListUrl: string | null
    certificateUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingRecordCountAggregateOutputType = {
    id: number
    employeeId: number
    trainingTypeId: number
    trainingDate: number
    expiryDate: number
    status: number
    attendanceListUrl: number
    certificateUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TrainingRecordMinAggregateInputType = {
    id?: true
    employeeId?: true
    trainingTypeId?: true
    trainingDate?: true
    expiryDate?: true
    status?: true
    attendanceListUrl?: true
    certificateUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingRecordMaxAggregateInputType = {
    id?: true
    employeeId?: true
    trainingTypeId?: true
    trainingDate?: true
    expiryDate?: true
    status?: true
    attendanceListUrl?: true
    certificateUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingRecordCountAggregateInputType = {
    id?: true
    employeeId?: true
    trainingTypeId?: true
    trainingDate?: true
    expiryDate?: true
    status?: true
    attendanceListUrl?: true
    certificateUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TrainingRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingRecord to aggregate.
     */
    where?: TrainingRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingRecords to fetch.
     */
    orderBy?: TrainingRecordOrderByWithRelationInput | TrainingRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrainingRecords
    **/
    _count?: true | TrainingRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingRecordMaxAggregateInputType
  }

  export type GetTrainingRecordAggregateType<T extends TrainingRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainingRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainingRecord[P]>
      : GetScalarType<T[P], AggregateTrainingRecord[P]>
  }




  export type TrainingRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingRecordWhereInput
    orderBy?: TrainingRecordOrderByWithAggregationInput | TrainingRecordOrderByWithAggregationInput[]
    by: TrainingRecordScalarFieldEnum[] | TrainingRecordScalarFieldEnum
    having?: TrainingRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingRecordCountAggregateInputType | true
    _min?: TrainingRecordMinAggregateInputType
    _max?: TrainingRecordMaxAggregateInputType
  }

  export type TrainingRecordGroupByOutputType = {
    id: string
    employeeId: string
    trainingTypeId: string
    trainingDate: Date
    expiryDate: Date | null
    status: string
    attendanceListUrl: string | null
    certificateUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: TrainingRecordCountAggregateOutputType | null
    _min: TrainingRecordMinAggregateOutputType | null
    _max: TrainingRecordMaxAggregateOutputType | null
  }

  type GetTrainingRecordGroupByPayload<T extends TrainingRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingRecordGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingRecordGroupByOutputType[P]>
        }
      >
    >


  export type TrainingRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    trainingTypeId?: boolean
    trainingDate?: boolean
    expiryDate?: boolean
    status?: boolean
    attendanceListUrl?: boolean
    certificateUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    trainingType?: boolean | TrainingTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingRecord"]>

  export type TrainingRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    trainingTypeId?: boolean
    trainingDate?: boolean
    expiryDate?: boolean
    status?: boolean
    attendanceListUrl?: boolean
    certificateUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    trainingType?: boolean | TrainingTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingRecord"]>

  export type TrainingRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    trainingTypeId?: boolean
    trainingDate?: boolean
    expiryDate?: boolean
    status?: boolean
    attendanceListUrl?: boolean
    certificateUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    trainingType?: boolean | TrainingTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingRecord"]>

  export type TrainingRecordSelectScalar = {
    id?: boolean
    employeeId?: boolean
    trainingTypeId?: boolean
    trainingDate?: boolean
    expiryDate?: boolean
    status?: boolean
    attendanceListUrl?: boolean
    certificateUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TrainingRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "trainingTypeId" | "trainingDate" | "expiryDate" | "status" | "attendanceListUrl" | "certificateUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["trainingRecord"]>
  export type TrainingRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    trainingType?: boolean | TrainingTypeDefaultArgs<ExtArgs>
  }
  export type TrainingRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    trainingType?: boolean | TrainingTypeDefaultArgs<ExtArgs>
  }
  export type TrainingRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    trainingType?: boolean | TrainingTypeDefaultArgs<ExtArgs>
  }

  export type $TrainingRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrainingRecord"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
      trainingType: Prisma.$TrainingTypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      trainingTypeId: string
      trainingDate: Date
      expiryDate: Date | null
      status: string
      attendanceListUrl: string | null
      certificateUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["trainingRecord"]>
    composites: {}
  }

  type TrainingRecordGetPayload<S extends boolean | null | undefined | TrainingRecordDefaultArgs> = $Result.GetResult<Prisma.$TrainingRecordPayload, S>

  type TrainingRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrainingRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrainingRecordCountAggregateInputType | true
    }

  export interface TrainingRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrainingRecord'], meta: { name: 'TrainingRecord' } }
    /**
     * Find zero or one TrainingRecord that matches the filter.
     * @param {TrainingRecordFindUniqueArgs} args - Arguments to find a TrainingRecord
     * @example
     * // Get one TrainingRecord
     * const trainingRecord = await prisma.trainingRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrainingRecordFindUniqueArgs>(args: SelectSubset<T, TrainingRecordFindUniqueArgs<ExtArgs>>): Prisma__TrainingRecordClient<$Result.GetResult<Prisma.$TrainingRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TrainingRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrainingRecordFindUniqueOrThrowArgs} args - Arguments to find a TrainingRecord
     * @example
     * // Get one TrainingRecord
     * const trainingRecord = await prisma.trainingRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrainingRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, TrainingRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrainingRecordClient<$Result.GetResult<Prisma.$TrainingRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingRecordFindFirstArgs} args - Arguments to find a TrainingRecord
     * @example
     * // Get one TrainingRecord
     * const trainingRecord = await prisma.trainingRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrainingRecordFindFirstArgs>(args?: SelectSubset<T, TrainingRecordFindFirstArgs<ExtArgs>>): Prisma__TrainingRecordClient<$Result.GetResult<Prisma.$TrainingRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingRecordFindFirstOrThrowArgs} args - Arguments to find a TrainingRecord
     * @example
     * // Get one TrainingRecord
     * const trainingRecord = await prisma.trainingRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrainingRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, TrainingRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrainingRecordClient<$Result.GetResult<Prisma.$TrainingRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TrainingRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrainingRecords
     * const trainingRecords = await prisma.trainingRecord.findMany()
     * 
     * // Get first 10 TrainingRecords
     * const trainingRecords = await prisma.trainingRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingRecordWithIdOnly = await prisma.trainingRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrainingRecordFindManyArgs>(args?: SelectSubset<T, TrainingRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TrainingRecord.
     * @param {TrainingRecordCreateArgs} args - Arguments to create a TrainingRecord.
     * @example
     * // Create one TrainingRecord
     * const TrainingRecord = await prisma.trainingRecord.create({
     *   data: {
     *     // ... data to create a TrainingRecord
     *   }
     * })
     * 
     */
    create<T extends TrainingRecordCreateArgs>(args: SelectSubset<T, TrainingRecordCreateArgs<ExtArgs>>): Prisma__TrainingRecordClient<$Result.GetResult<Prisma.$TrainingRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TrainingRecords.
     * @param {TrainingRecordCreateManyArgs} args - Arguments to create many TrainingRecords.
     * @example
     * // Create many TrainingRecords
     * const trainingRecord = await prisma.trainingRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrainingRecordCreateManyArgs>(args?: SelectSubset<T, TrainingRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrainingRecords and returns the data saved in the database.
     * @param {TrainingRecordCreateManyAndReturnArgs} args - Arguments to create many TrainingRecords.
     * @example
     * // Create many TrainingRecords
     * const trainingRecord = await prisma.trainingRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrainingRecords and only return the `id`
     * const trainingRecordWithIdOnly = await prisma.trainingRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrainingRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, TrainingRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TrainingRecord.
     * @param {TrainingRecordDeleteArgs} args - Arguments to delete one TrainingRecord.
     * @example
     * // Delete one TrainingRecord
     * const TrainingRecord = await prisma.trainingRecord.delete({
     *   where: {
     *     // ... filter to delete one TrainingRecord
     *   }
     * })
     * 
     */
    delete<T extends TrainingRecordDeleteArgs>(args: SelectSubset<T, TrainingRecordDeleteArgs<ExtArgs>>): Prisma__TrainingRecordClient<$Result.GetResult<Prisma.$TrainingRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TrainingRecord.
     * @param {TrainingRecordUpdateArgs} args - Arguments to update one TrainingRecord.
     * @example
     * // Update one TrainingRecord
     * const trainingRecord = await prisma.trainingRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrainingRecordUpdateArgs>(args: SelectSubset<T, TrainingRecordUpdateArgs<ExtArgs>>): Prisma__TrainingRecordClient<$Result.GetResult<Prisma.$TrainingRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TrainingRecords.
     * @param {TrainingRecordDeleteManyArgs} args - Arguments to filter TrainingRecords to delete.
     * @example
     * // Delete a few TrainingRecords
     * const { count } = await prisma.trainingRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrainingRecordDeleteManyArgs>(args?: SelectSubset<T, TrainingRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrainingRecords
     * const trainingRecord = await prisma.trainingRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrainingRecordUpdateManyArgs>(args: SelectSubset<T, TrainingRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingRecords and returns the data updated in the database.
     * @param {TrainingRecordUpdateManyAndReturnArgs} args - Arguments to update many TrainingRecords.
     * @example
     * // Update many TrainingRecords
     * const trainingRecord = await prisma.trainingRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TrainingRecords and only return the `id`
     * const trainingRecordWithIdOnly = await prisma.trainingRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TrainingRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, TrainingRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TrainingRecord.
     * @param {TrainingRecordUpsertArgs} args - Arguments to update or create a TrainingRecord.
     * @example
     * // Update or create a TrainingRecord
     * const trainingRecord = await prisma.trainingRecord.upsert({
     *   create: {
     *     // ... data to create a TrainingRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrainingRecord we want to update
     *   }
     * })
     */
    upsert<T extends TrainingRecordUpsertArgs>(args: SelectSubset<T, TrainingRecordUpsertArgs<ExtArgs>>): Prisma__TrainingRecordClient<$Result.GetResult<Prisma.$TrainingRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TrainingRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingRecordCountArgs} args - Arguments to filter TrainingRecords to count.
     * @example
     * // Count the number of TrainingRecords
     * const count = await prisma.trainingRecord.count({
     *   where: {
     *     // ... the filter for the TrainingRecords we want to count
     *   }
     * })
    **/
    count<T extends TrainingRecordCountArgs>(
      args?: Subset<T, TrainingRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrainingRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingRecordAggregateArgs>(args: Subset<T, TrainingRecordAggregateArgs>): Prisma.PrismaPromise<GetTrainingRecordAggregateType<T>>

    /**
     * Group by TrainingRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingRecordGroupByArgs['orderBy'] }
        : { orderBy?: TrainingRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrainingRecord model
   */
  readonly fields: TrainingRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrainingRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainingRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    trainingType<T extends TrainingTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrainingTypeDefaultArgs<ExtArgs>>): Prisma__TrainingTypeClient<$Result.GetResult<Prisma.$TrainingTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrainingRecord model
   */
  interface TrainingRecordFieldRefs {
    readonly id: FieldRef<"TrainingRecord", 'String'>
    readonly employeeId: FieldRef<"TrainingRecord", 'String'>
    readonly trainingTypeId: FieldRef<"TrainingRecord", 'String'>
    readonly trainingDate: FieldRef<"TrainingRecord", 'DateTime'>
    readonly expiryDate: FieldRef<"TrainingRecord", 'DateTime'>
    readonly status: FieldRef<"TrainingRecord", 'String'>
    readonly attendanceListUrl: FieldRef<"TrainingRecord", 'String'>
    readonly certificateUrl: FieldRef<"TrainingRecord", 'String'>
    readonly createdAt: FieldRef<"TrainingRecord", 'DateTime'>
    readonly updatedAt: FieldRef<"TrainingRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrainingRecord findUnique
   */
  export type TrainingRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingRecord
     */
    select?: TrainingRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingRecord
     */
    omit?: TrainingRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingRecordInclude<ExtArgs> | null
    /**
     * Filter, which TrainingRecord to fetch.
     */
    where: TrainingRecordWhereUniqueInput
  }

  /**
   * TrainingRecord findUniqueOrThrow
   */
  export type TrainingRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingRecord
     */
    select?: TrainingRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingRecord
     */
    omit?: TrainingRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingRecordInclude<ExtArgs> | null
    /**
     * Filter, which TrainingRecord to fetch.
     */
    where: TrainingRecordWhereUniqueInput
  }

  /**
   * TrainingRecord findFirst
   */
  export type TrainingRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingRecord
     */
    select?: TrainingRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingRecord
     */
    omit?: TrainingRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingRecordInclude<ExtArgs> | null
    /**
     * Filter, which TrainingRecord to fetch.
     */
    where?: TrainingRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingRecords to fetch.
     */
    orderBy?: TrainingRecordOrderByWithRelationInput | TrainingRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingRecords.
     */
    cursor?: TrainingRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingRecords.
     */
    distinct?: TrainingRecordScalarFieldEnum | TrainingRecordScalarFieldEnum[]
  }

  /**
   * TrainingRecord findFirstOrThrow
   */
  export type TrainingRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingRecord
     */
    select?: TrainingRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingRecord
     */
    omit?: TrainingRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingRecordInclude<ExtArgs> | null
    /**
     * Filter, which TrainingRecord to fetch.
     */
    where?: TrainingRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingRecords to fetch.
     */
    orderBy?: TrainingRecordOrderByWithRelationInput | TrainingRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingRecords.
     */
    cursor?: TrainingRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingRecords.
     */
    distinct?: TrainingRecordScalarFieldEnum | TrainingRecordScalarFieldEnum[]
  }

  /**
   * TrainingRecord findMany
   */
  export type TrainingRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingRecord
     */
    select?: TrainingRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingRecord
     */
    omit?: TrainingRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingRecordInclude<ExtArgs> | null
    /**
     * Filter, which TrainingRecords to fetch.
     */
    where?: TrainingRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingRecords to fetch.
     */
    orderBy?: TrainingRecordOrderByWithRelationInput | TrainingRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrainingRecords.
     */
    cursor?: TrainingRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingRecords.
     */
    skip?: number
    distinct?: TrainingRecordScalarFieldEnum | TrainingRecordScalarFieldEnum[]
  }

  /**
   * TrainingRecord create
   */
  export type TrainingRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingRecord
     */
    select?: TrainingRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingRecord
     */
    omit?: TrainingRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a TrainingRecord.
     */
    data: XOR<TrainingRecordCreateInput, TrainingRecordUncheckedCreateInput>
  }

  /**
   * TrainingRecord createMany
   */
  export type TrainingRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrainingRecords.
     */
    data: TrainingRecordCreateManyInput | TrainingRecordCreateManyInput[]
  }

  /**
   * TrainingRecord createManyAndReturn
   */
  export type TrainingRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingRecord
     */
    select?: TrainingRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingRecord
     */
    omit?: TrainingRecordOmit<ExtArgs> | null
    /**
     * The data used to create many TrainingRecords.
     */
    data: TrainingRecordCreateManyInput | TrainingRecordCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingRecord update
   */
  export type TrainingRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingRecord
     */
    select?: TrainingRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingRecord
     */
    omit?: TrainingRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a TrainingRecord.
     */
    data: XOR<TrainingRecordUpdateInput, TrainingRecordUncheckedUpdateInput>
    /**
     * Choose, which TrainingRecord to update.
     */
    where: TrainingRecordWhereUniqueInput
  }

  /**
   * TrainingRecord updateMany
   */
  export type TrainingRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrainingRecords.
     */
    data: XOR<TrainingRecordUpdateManyMutationInput, TrainingRecordUncheckedUpdateManyInput>
    /**
     * Filter which TrainingRecords to update
     */
    where?: TrainingRecordWhereInput
    /**
     * Limit how many TrainingRecords to update.
     */
    limit?: number
  }

  /**
   * TrainingRecord updateManyAndReturn
   */
  export type TrainingRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingRecord
     */
    select?: TrainingRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingRecord
     */
    omit?: TrainingRecordOmit<ExtArgs> | null
    /**
     * The data used to update TrainingRecords.
     */
    data: XOR<TrainingRecordUpdateManyMutationInput, TrainingRecordUncheckedUpdateManyInput>
    /**
     * Filter which TrainingRecords to update
     */
    where?: TrainingRecordWhereInput
    /**
     * Limit how many TrainingRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingRecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingRecord upsert
   */
  export type TrainingRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingRecord
     */
    select?: TrainingRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingRecord
     */
    omit?: TrainingRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the TrainingRecord to update in case it exists.
     */
    where: TrainingRecordWhereUniqueInput
    /**
     * In case the TrainingRecord found by the `where` argument doesn't exist, create a new TrainingRecord with this data.
     */
    create: XOR<TrainingRecordCreateInput, TrainingRecordUncheckedCreateInput>
    /**
     * In case the TrainingRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingRecordUpdateInput, TrainingRecordUncheckedUpdateInput>
  }

  /**
   * TrainingRecord delete
   */
  export type TrainingRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingRecord
     */
    select?: TrainingRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingRecord
     */
    omit?: TrainingRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingRecordInclude<ExtArgs> | null
    /**
     * Filter which TrainingRecord to delete.
     */
    where: TrainingRecordWhereUniqueInput
  }

  /**
   * TrainingRecord deleteMany
   */
  export type TrainingRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingRecords to delete
     */
    where?: TrainingRecordWhereInput
    /**
     * Limit how many TrainingRecords to delete.
     */
    limit?: number
  }

  /**
   * TrainingRecord without action
   */
  export type TrainingRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingRecord
     */
    select?: TrainingRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingRecord
     */
    omit?: TrainingRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingRecordInclude<ExtArgs> | null
  }


  /**
   * Model PpeRecord
   */

  export type AggregatePpeRecord = {
    _count: PpeRecordCountAggregateOutputType | null
    _avg: PpeRecordAvgAggregateOutputType | null
    _sum: PpeRecordSumAggregateOutputType | null
    _min: PpeRecordMinAggregateOutputType | null
    _max: PpeRecordMaxAggregateOutputType | null
  }

  export type PpeRecordAvgAggregateOutputType = {
    quantity: number | null
  }

  export type PpeRecordSumAggregateOutputType = {
    quantity: number | null
  }

  export type PpeRecordMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    ppeType: string | null
    caNumber: string | null
    deliveryDate: Date | null
    quantity: number | null
    returnDate: Date | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PpeRecordMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    ppeType: string | null
    caNumber: string | null
    deliveryDate: Date | null
    quantity: number | null
    returnDate: Date | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PpeRecordCountAggregateOutputType = {
    id: number
    employeeId: number
    ppeType: number
    caNumber: number
    deliveryDate: number
    quantity: number
    returnDate: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PpeRecordAvgAggregateInputType = {
    quantity?: true
  }

  export type PpeRecordSumAggregateInputType = {
    quantity?: true
  }

  export type PpeRecordMinAggregateInputType = {
    id?: true
    employeeId?: true
    ppeType?: true
    caNumber?: true
    deliveryDate?: true
    quantity?: true
    returnDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PpeRecordMaxAggregateInputType = {
    id?: true
    employeeId?: true
    ppeType?: true
    caNumber?: true
    deliveryDate?: true
    quantity?: true
    returnDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PpeRecordCountAggregateInputType = {
    id?: true
    employeeId?: true
    ppeType?: true
    caNumber?: true
    deliveryDate?: true
    quantity?: true
    returnDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PpeRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PpeRecord to aggregate.
     */
    where?: PpeRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PpeRecords to fetch.
     */
    orderBy?: PpeRecordOrderByWithRelationInput | PpeRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PpeRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PpeRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PpeRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PpeRecords
    **/
    _count?: true | PpeRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PpeRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PpeRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PpeRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PpeRecordMaxAggregateInputType
  }

  export type GetPpeRecordAggregateType<T extends PpeRecordAggregateArgs> = {
        [P in keyof T & keyof AggregatePpeRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePpeRecord[P]>
      : GetScalarType<T[P], AggregatePpeRecord[P]>
  }




  export type PpeRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PpeRecordWhereInput
    orderBy?: PpeRecordOrderByWithAggregationInput | PpeRecordOrderByWithAggregationInput[]
    by: PpeRecordScalarFieldEnum[] | PpeRecordScalarFieldEnum
    having?: PpeRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PpeRecordCountAggregateInputType | true
    _avg?: PpeRecordAvgAggregateInputType
    _sum?: PpeRecordSumAggregateInputType
    _min?: PpeRecordMinAggregateInputType
    _max?: PpeRecordMaxAggregateInputType
  }

  export type PpeRecordGroupByOutputType = {
    id: string
    employeeId: string
    ppeType: string
    caNumber: string | null
    deliveryDate: Date
    quantity: number
    returnDate: Date | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: PpeRecordCountAggregateOutputType | null
    _avg: PpeRecordAvgAggregateOutputType | null
    _sum: PpeRecordSumAggregateOutputType | null
    _min: PpeRecordMinAggregateOutputType | null
    _max: PpeRecordMaxAggregateOutputType | null
  }

  type GetPpeRecordGroupByPayload<T extends PpeRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PpeRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PpeRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PpeRecordGroupByOutputType[P]>
            : GetScalarType<T[P], PpeRecordGroupByOutputType[P]>
        }
      >
    >


  export type PpeRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    ppeType?: boolean
    caNumber?: boolean
    deliveryDate?: boolean
    quantity?: boolean
    returnDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ppeRecord"]>

  export type PpeRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    ppeType?: boolean
    caNumber?: boolean
    deliveryDate?: boolean
    quantity?: boolean
    returnDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ppeRecord"]>

  export type PpeRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    ppeType?: boolean
    caNumber?: boolean
    deliveryDate?: boolean
    quantity?: boolean
    returnDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ppeRecord"]>

  export type PpeRecordSelectScalar = {
    id?: boolean
    employeeId?: boolean
    ppeType?: boolean
    caNumber?: boolean
    deliveryDate?: boolean
    quantity?: boolean
    returnDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PpeRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "ppeType" | "caNumber" | "deliveryDate" | "quantity" | "returnDate" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["ppeRecord"]>
  export type PpeRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type PpeRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type PpeRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $PpeRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PpeRecord"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      ppeType: string
      caNumber: string | null
      deliveryDate: Date
      quantity: number
      returnDate: Date | null
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ppeRecord"]>
    composites: {}
  }

  type PpeRecordGetPayload<S extends boolean | null | undefined | PpeRecordDefaultArgs> = $Result.GetResult<Prisma.$PpeRecordPayload, S>

  type PpeRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PpeRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PpeRecordCountAggregateInputType | true
    }

  export interface PpeRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PpeRecord'], meta: { name: 'PpeRecord' } }
    /**
     * Find zero or one PpeRecord that matches the filter.
     * @param {PpeRecordFindUniqueArgs} args - Arguments to find a PpeRecord
     * @example
     * // Get one PpeRecord
     * const ppeRecord = await prisma.ppeRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PpeRecordFindUniqueArgs>(args: SelectSubset<T, PpeRecordFindUniqueArgs<ExtArgs>>): Prisma__PpeRecordClient<$Result.GetResult<Prisma.$PpeRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PpeRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PpeRecordFindUniqueOrThrowArgs} args - Arguments to find a PpeRecord
     * @example
     * // Get one PpeRecord
     * const ppeRecord = await prisma.ppeRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PpeRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, PpeRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PpeRecordClient<$Result.GetResult<Prisma.$PpeRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PpeRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PpeRecordFindFirstArgs} args - Arguments to find a PpeRecord
     * @example
     * // Get one PpeRecord
     * const ppeRecord = await prisma.ppeRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PpeRecordFindFirstArgs>(args?: SelectSubset<T, PpeRecordFindFirstArgs<ExtArgs>>): Prisma__PpeRecordClient<$Result.GetResult<Prisma.$PpeRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PpeRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PpeRecordFindFirstOrThrowArgs} args - Arguments to find a PpeRecord
     * @example
     * // Get one PpeRecord
     * const ppeRecord = await prisma.ppeRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PpeRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, PpeRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__PpeRecordClient<$Result.GetResult<Prisma.$PpeRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PpeRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PpeRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PpeRecords
     * const ppeRecords = await prisma.ppeRecord.findMany()
     * 
     * // Get first 10 PpeRecords
     * const ppeRecords = await prisma.ppeRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ppeRecordWithIdOnly = await prisma.ppeRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PpeRecordFindManyArgs>(args?: SelectSubset<T, PpeRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PpeRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PpeRecord.
     * @param {PpeRecordCreateArgs} args - Arguments to create a PpeRecord.
     * @example
     * // Create one PpeRecord
     * const PpeRecord = await prisma.ppeRecord.create({
     *   data: {
     *     // ... data to create a PpeRecord
     *   }
     * })
     * 
     */
    create<T extends PpeRecordCreateArgs>(args: SelectSubset<T, PpeRecordCreateArgs<ExtArgs>>): Prisma__PpeRecordClient<$Result.GetResult<Prisma.$PpeRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PpeRecords.
     * @param {PpeRecordCreateManyArgs} args - Arguments to create many PpeRecords.
     * @example
     * // Create many PpeRecords
     * const ppeRecord = await prisma.ppeRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PpeRecordCreateManyArgs>(args?: SelectSubset<T, PpeRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PpeRecords and returns the data saved in the database.
     * @param {PpeRecordCreateManyAndReturnArgs} args - Arguments to create many PpeRecords.
     * @example
     * // Create many PpeRecords
     * const ppeRecord = await prisma.ppeRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PpeRecords and only return the `id`
     * const ppeRecordWithIdOnly = await prisma.ppeRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PpeRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, PpeRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PpeRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PpeRecord.
     * @param {PpeRecordDeleteArgs} args - Arguments to delete one PpeRecord.
     * @example
     * // Delete one PpeRecord
     * const PpeRecord = await prisma.ppeRecord.delete({
     *   where: {
     *     // ... filter to delete one PpeRecord
     *   }
     * })
     * 
     */
    delete<T extends PpeRecordDeleteArgs>(args: SelectSubset<T, PpeRecordDeleteArgs<ExtArgs>>): Prisma__PpeRecordClient<$Result.GetResult<Prisma.$PpeRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PpeRecord.
     * @param {PpeRecordUpdateArgs} args - Arguments to update one PpeRecord.
     * @example
     * // Update one PpeRecord
     * const ppeRecord = await prisma.ppeRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PpeRecordUpdateArgs>(args: SelectSubset<T, PpeRecordUpdateArgs<ExtArgs>>): Prisma__PpeRecordClient<$Result.GetResult<Prisma.$PpeRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PpeRecords.
     * @param {PpeRecordDeleteManyArgs} args - Arguments to filter PpeRecords to delete.
     * @example
     * // Delete a few PpeRecords
     * const { count } = await prisma.ppeRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PpeRecordDeleteManyArgs>(args?: SelectSubset<T, PpeRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PpeRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PpeRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PpeRecords
     * const ppeRecord = await prisma.ppeRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PpeRecordUpdateManyArgs>(args: SelectSubset<T, PpeRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PpeRecords and returns the data updated in the database.
     * @param {PpeRecordUpdateManyAndReturnArgs} args - Arguments to update many PpeRecords.
     * @example
     * // Update many PpeRecords
     * const ppeRecord = await prisma.ppeRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PpeRecords and only return the `id`
     * const ppeRecordWithIdOnly = await prisma.ppeRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PpeRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, PpeRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PpeRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PpeRecord.
     * @param {PpeRecordUpsertArgs} args - Arguments to update or create a PpeRecord.
     * @example
     * // Update or create a PpeRecord
     * const ppeRecord = await prisma.ppeRecord.upsert({
     *   create: {
     *     // ... data to create a PpeRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PpeRecord we want to update
     *   }
     * })
     */
    upsert<T extends PpeRecordUpsertArgs>(args: SelectSubset<T, PpeRecordUpsertArgs<ExtArgs>>): Prisma__PpeRecordClient<$Result.GetResult<Prisma.$PpeRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PpeRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PpeRecordCountArgs} args - Arguments to filter PpeRecords to count.
     * @example
     * // Count the number of PpeRecords
     * const count = await prisma.ppeRecord.count({
     *   where: {
     *     // ... the filter for the PpeRecords we want to count
     *   }
     * })
    **/
    count<T extends PpeRecordCountArgs>(
      args?: Subset<T, PpeRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PpeRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PpeRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PpeRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PpeRecordAggregateArgs>(args: Subset<T, PpeRecordAggregateArgs>): Prisma.PrismaPromise<GetPpeRecordAggregateType<T>>

    /**
     * Group by PpeRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PpeRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PpeRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PpeRecordGroupByArgs['orderBy'] }
        : { orderBy?: PpeRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PpeRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPpeRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PpeRecord model
   */
  readonly fields: PpeRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PpeRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PpeRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PpeRecord model
   */
  interface PpeRecordFieldRefs {
    readonly id: FieldRef<"PpeRecord", 'String'>
    readonly employeeId: FieldRef<"PpeRecord", 'String'>
    readonly ppeType: FieldRef<"PpeRecord", 'String'>
    readonly caNumber: FieldRef<"PpeRecord", 'String'>
    readonly deliveryDate: FieldRef<"PpeRecord", 'DateTime'>
    readonly quantity: FieldRef<"PpeRecord", 'Int'>
    readonly returnDate: FieldRef<"PpeRecord", 'DateTime'>
    readonly status: FieldRef<"PpeRecord", 'String'>
    readonly createdAt: FieldRef<"PpeRecord", 'DateTime'>
    readonly updatedAt: FieldRef<"PpeRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PpeRecord findUnique
   */
  export type PpeRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PpeRecord
     */
    select?: PpeRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PpeRecord
     */
    omit?: PpeRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PpeRecordInclude<ExtArgs> | null
    /**
     * Filter, which PpeRecord to fetch.
     */
    where: PpeRecordWhereUniqueInput
  }

  /**
   * PpeRecord findUniqueOrThrow
   */
  export type PpeRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PpeRecord
     */
    select?: PpeRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PpeRecord
     */
    omit?: PpeRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PpeRecordInclude<ExtArgs> | null
    /**
     * Filter, which PpeRecord to fetch.
     */
    where: PpeRecordWhereUniqueInput
  }

  /**
   * PpeRecord findFirst
   */
  export type PpeRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PpeRecord
     */
    select?: PpeRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PpeRecord
     */
    omit?: PpeRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PpeRecordInclude<ExtArgs> | null
    /**
     * Filter, which PpeRecord to fetch.
     */
    where?: PpeRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PpeRecords to fetch.
     */
    orderBy?: PpeRecordOrderByWithRelationInput | PpeRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PpeRecords.
     */
    cursor?: PpeRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PpeRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PpeRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PpeRecords.
     */
    distinct?: PpeRecordScalarFieldEnum | PpeRecordScalarFieldEnum[]
  }

  /**
   * PpeRecord findFirstOrThrow
   */
  export type PpeRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PpeRecord
     */
    select?: PpeRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PpeRecord
     */
    omit?: PpeRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PpeRecordInclude<ExtArgs> | null
    /**
     * Filter, which PpeRecord to fetch.
     */
    where?: PpeRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PpeRecords to fetch.
     */
    orderBy?: PpeRecordOrderByWithRelationInput | PpeRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PpeRecords.
     */
    cursor?: PpeRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PpeRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PpeRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PpeRecords.
     */
    distinct?: PpeRecordScalarFieldEnum | PpeRecordScalarFieldEnum[]
  }

  /**
   * PpeRecord findMany
   */
  export type PpeRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PpeRecord
     */
    select?: PpeRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PpeRecord
     */
    omit?: PpeRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PpeRecordInclude<ExtArgs> | null
    /**
     * Filter, which PpeRecords to fetch.
     */
    where?: PpeRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PpeRecords to fetch.
     */
    orderBy?: PpeRecordOrderByWithRelationInput | PpeRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PpeRecords.
     */
    cursor?: PpeRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PpeRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PpeRecords.
     */
    skip?: number
    distinct?: PpeRecordScalarFieldEnum | PpeRecordScalarFieldEnum[]
  }

  /**
   * PpeRecord create
   */
  export type PpeRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PpeRecord
     */
    select?: PpeRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PpeRecord
     */
    omit?: PpeRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PpeRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a PpeRecord.
     */
    data: XOR<PpeRecordCreateInput, PpeRecordUncheckedCreateInput>
  }

  /**
   * PpeRecord createMany
   */
  export type PpeRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PpeRecords.
     */
    data: PpeRecordCreateManyInput | PpeRecordCreateManyInput[]
  }

  /**
   * PpeRecord createManyAndReturn
   */
  export type PpeRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PpeRecord
     */
    select?: PpeRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PpeRecord
     */
    omit?: PpeRecordOmit<ExtArgs> | null
    /**
     * The data used to create many PpeRecords.
     */
    data: PpeRecordCreateManyInput | PpeRecordCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PpeRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PpeRecord update
   */
  export type PpeRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PpeRecord
     */
    select?: PpeRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PpeRecord
     */
    omit?: PpeRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PpeRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a PpeRecord.
     */
    data: XOR<PpeRecordUpdateInput, PpeRecordUncheckedUpdateInput>
    /**
     * Choose, which PpeRecord to update.
     */
    where: PpeRecordWhereUniqueInput
  }

  /**
   * PpeRecord updateMany
   */
  export type PpeRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PpeRecords.
     */
    data: XOR<PpeRecordUpdateManyMutationInput, PpeRecordUncheckedUpdateManyInput>
    /**
     * Filter which PpeRecords to update
     */
    where?: PpeRecordWhereInput
    /**
     * Limit how many PpeRecords to update.
     */
    limit?: number
  }

  /**
   * PpeRecord updateManyAndReturn
   */
  export type PpeRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PpeRecord
     */
    select?: PpeRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PpeRecord
     */
    omit?: PpeRecordOmit<ExtArgs> | null
    /**
     * The data used to update PpeRecords.
     */
    data: XOR<PpeRecordUpdateManyMutationInput, PpeRecordUncheckedUpdateManyInput>
    /**
     * Filter which PpeRecords to update
     */
    where?: PpeRecordWhereInput
    /**
     * Limit how many PpeRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PpeRecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PpeRecord upsert
   */
  export type PpeRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PpeRecord
     */
    select?: PpeRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PpeRecord
     */
    omit?: PpeRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PpeRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the PpeRecord to update in case it exists.
     */
    where: PpeRecordWhereUniqueInput
    /**
     * In case the PpeRecord found by the `where` argument doesn't exist, create a new PpeRecord with this data.
     */
    create: XOR<PpeRecordCreateInput, PpeRecordUncheckedCreateInput>
    /**
     * In case the PpeRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PpeRecordUpdateInput, PpeRecordUncheckedUpdateInput>
  }

  /**
   * PpeRecord delete
   */
  export type PpeRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PpeRecord
     */
    select?: PpeRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PpeRecord
     */
    omit?: PpeRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PpeRecordInclude<ExtArgs> | null
    /**
     * Filter which PpeRecord to delete.
     */
    where: PpeRecordWhereUniqueInput
  }

  /**
   * PpeRecord deleteMany
   */
  export type PpeRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PpeRecords to delete
     */
    where?: PpeRecordWhereInput
    /**
     * Limit how many PpeRecords to delete.
     */
    limit?: number
  }

  /**
   * PpeRecord without action
   */
  export type PpeRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PpeRecord
     */
    select?: PpeRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PpeRecord
     */
    omit?: PpeRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PpeRecordInclude<ExtArgs> | null
  }


  /**
   * Model AsoRecord
   */

  export type AggregateAsoRecord = {
    _count: AsoRecordCountAggregateOutputType | null
    _min: AsoRecordMinAggregateOutputType | null
    _max: AsoRecordMaxAggregateOutputType | null
  }

  export type AsoRecordMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    examType: string | null
    examDate: Date | null
    expiryDate: Date | null
    result: string | null
    status: string | null
    attachmentUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AsoRecordMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    examType: string | null
    examDate: Date | null
    expiryDate: Date | null
    result: string | null
    status: string | null
    attachmentUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AsoRecordCountAggregateOutputType = {
    id: number
    employeeId: number
    examType: number
    examDate: number
    expiryDate: number
    result: number
    status: number
    attachmentUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AsoRecordMinAggregateInputType = {
    id?: true
    employeeId?: true
    examType?: true
    examDate?: true
    expiryDate?: true
    result?: true
    status?: true
    attachmentUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AsoRecordMaxAggregateInputType = {
    id?: true
    employeeId?: true
    examType?: true
    examDate?: true
    expiryDate?: true
    result?: true
    status?: true
    attachmentUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AsoRecordCountAggregateInputType = {
    id?: true
    employeeId?: true
    examType?: true
    examDate?: true
    expiryDate?: true
    result?: true
    status?: true
    attachmentUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AsoRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AsoRecord to aggregate.
     */
    where?: AsoRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AsoRecords to fetch.
     */
    orderBy?: AsoRecordOrderByWithRelationInput | AsoRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AsoRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AsoRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AsoRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AsoRecords
    **/
    _count?: true | AsoRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AsoRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AsoRecordMaxAggregateInputType
  }

  export type GetAsoRecordAggregateType<T extends AsoRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateAsoRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAsoRecord[P]>
      : GetScalarType<T[P], AggregateAsoRecord[P]>
  }




  export type AsoRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AsoRecordWhereInput
    orderBy?: AsoRecordOrderByWithAggregationInput | AsoRecordOrderByWithAggregationInput[]
    by: AsoRecordScalarFieldEnum[] | AsoRecordScalarFieldEnum
    having?: AsoRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AsoRecordCountAggregateInputType | true
    _min?: AsoRecordMinAggregateInputType
    _max?: AsoRecordMaxAggregateInputType
  }

  export type AsoRecordGroupByOutputType = {
    id: string
    employeeId: string
    examType: string
    examDate: Date
    expiryDate: Date
    result: string
    status: string
    attachmentUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: AsoRecordCountAggregateOutputType | null
    _min: AsoRecordMinAggregateOutputType | null
    _max: AsoRecordMaxAggregateOutputType | null
  }

  type GetAsoRecordGroupByPayload<T extends AsoRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AsoRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AsoRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AsoRecordGroupByOutputType[P]>
            : GetScalarType<T[P], AsoRecordGroupByOutputType[P]>
        }
      >
    >


  export type AsoRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    examType?: boolean
    examDate?: boolean
    expiryDate?: boolean
    result?: boolean
    status?: boolean
    attachmentUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["asoRecord"]>

  export type AsoRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    examType?: boolean
    examDate?: boolean
    expiryDate?: boolean
    result?: boolean
    status?: boolean
    attachmentUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["asoRecord"]>

  export type AsoRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    examType?: boolean
    examDate?: boolean
    expiryDate?: boolean
    result?: boolean
    status?: boolean
    attachmentUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["asoRecord"]>

  export type AsoRecordSelectScalar = {
    id?: boolean
    employeeId?: boolean
    examType?: boolean
    examDate?: boolean
    expiryDate?: boolean
    result?: boolean
    status?: boolean
    attachmentUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AsoRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "examType" | "examDate" | "expiryDate" | "result" | "status" | "attachmentUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["asoRecord"]>
  export type AsoRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type AsoRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type AsoRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $AsoRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AsoRecord"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      examType: string
      examDate: Date
      expiryDate: Date
      result: string
      status: string
      attachmentUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["asoRecord"]>
    composites: {}
  }

  type AsoRecordGetPayload<S extends boolean | null | undefined | AsoRecordDefaultArgs> = $Result.GetResult<Prisma.$AsoRecordPayload, S>

  type AsoRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AsoRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AsoRecordCountAggregateInputType | true
    }

  export interface AsoRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AsoRecord'], meta: { name: 'AsoRecord' } }
    /**
     * Find zero or one AsoRecord that matches the filter.
     * @param {AsoRecordFindUniqueArgs} args - Arguments to find a AsoRecord
     * @example
     * // Get one AsoRecord
     * const asoRecord = await prisma.asoRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AsoRecordFindUniqueArgs>(args: SelectSubset<T, AsoRecordFindUniqueArgs<ExtArgs>>): Prisma__AsoRecordClient<$Result.GetResult<Prisma.$AsoRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AsoRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AsoRecordFindUniqueOrThrowArgs} args - Arguments to find a AsoRecord
     * @example
     * // Get one AsoRecord
     * const asoRecord = await prisma.asoRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AsoRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, AsoRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AsoRecordClient<$Result.GetResult<Prisma.$AsoRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AsoRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AsoRecordFindFirstArgs} args - Arguments to find a AsoRecord
     * @example
     * // Get one AsoRecord
     * const asoRecord = await prisma.asoRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AsoRecordFindFirstArgs>(args?: SelectSubset<T, AsoRecordFindFirstArgs<ExtArgs>>): Prisma__AsoRecordClient<$Result.GetResult<Prisma.$AsoRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AsoRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AsoRecordFindFirstOrThrowArgs} args - Arguments to find a AsoRecord
     * @example
     * // Get one AsoRecord
     * const asoRecord = await prisma.asoRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AsoRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, AsoRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__AsoRecordClient<$Result.GetResult<Prisma.$AsoRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AsoRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AsoRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AsoRecords
     * const asoRecords = await prisma.asoRecord.findMany()
     * 
     * // Get first 10 AsoRecords
     * const asoRecords = await prisma.asoRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const asoRecordWithIdOnly = await prisma.asoRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AsoRecordFindManyArgs>(args?: SelectSubset<T, AsoRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AsoRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AsoRecord.
     * @param {AsoRecordCreateArgs} args - Arguments to create a AsoRecord.
     * @example
     * // Create one AsoRecord
     * const AsoRecord = await prisma.asoRecord.create({
     *   data: {
     *     // ... data to create a AsoRecord
     *   }
     * })
     * 
     */
    create<T extends AsoRecordCreateArgs>(args: SelectSubset<T, AsoRecordCreateArgs<ExtArgs>>): Prisma__AsoRecordClient<$Result.GetResult<Prisma.$AsoRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AsoRecords.
     * @param {AsoRecordCreateManyArgs} args - Arguments to create many AsoRecords.
     * @example
     * // Create many AsoRecords
     * const asoRecord = await prisma.asoRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AsoRecordCreateManyArgs>(args?: SelectSubset<T, AsoRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AsoRecords and returns the data saved in the database.
     * @param {AsoRecordCreateManyAndReturnArgs} args - Arguments to create many AsoRecords.
     * @example
     * // Create many AsoRecords
     * const asoRecord = await prisma.asoRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AsoRecords and only return the `id`
     * const asoRecordWithIdOnly = await prisma.asoRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AsoRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, AsoRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AsoRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AsoRecord.
     * @param {AsoRecordDeleteArgs} args - Arguments to delete one AsoRecord.
     * @example
     * // Delete one AsoRecord
     * const AsoRecord = await prisma.asoRecord.delete({
     *   where: {
     *     // ... filter to delete one AsoRecord
     *   }
     * })
     * 
     */
    delete<T extends AsoRecordDeleteArgs>(args: SelectSubset<T, AsoRecordDeleteArgs<ExtArgs>>): Prisma__AsoRecordClient<$Result.GetResult<Prisma.$AsoRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AsoRecord.
     * @param {AsoRecordUpdateArgs} args - Arguments to update one AsoRecord.
     * @example
     * // Update one AsoRecord
     * const asoRecord = await prisma.asoRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AsoRecordUpdateArgs>(args: SelectSubset<T, AsoRecordUpdateArgs<ExtArgs>>): Prisma__AsoRecordClient<$Result.GetResult<Prisma.$AsoRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AsoRecords.
     * @param {AsoRecordDeleteManyArgs} args - Arguments to filter AsoRecords to delete.
     * @example
     * // Delete a few AsoRecords
     * const { count } = await prisma.asoRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AsoRecordDeleteManyArgs>(args?: SelectSubset<T, AsoRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AsoRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AsoRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AsoRecords
     * const asoRecord = await prisma.asoRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AsoRecordUpdateManyArgs>(args: SelectSubset<T, AsoRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AsoRecords and returns the data updated in the database.
     * @param {AsoRecordUpdateManyAndReturnArgs} args - Arguments to update many AsoRecords.
     * @example
     * // Update many AsoRecords
     * const asoRecord = await prisma.asoRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AsoRecords and only return the `id`
     * const asoRecordWithIdOnly = await prisma.asoRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AsoRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, AsoRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AsoRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AsoRecord.
     * @param {AsoRecordUpsertArgs} args - Arguments to update or create a AsoRecord.
     * @example
     * // Update or create a AsoRecord
     * const asoRecord = await prisma.asoRecord.upsert({
     *   create: {
     *     // ... data to create a AsoRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AsoRecord we want to update
     *   }
     * })
     */
    upsert<T extends AsoRecordUpsertArgs>(args: SelectSubset<T, AsoRecordUpsertArgs<ExtArgs>>): Prisma__AsoRecordClient<$Result.GetResult<Prisma.$AsoRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AsoRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AsoRecordCountArgs} args - Arguments to filter AsoRecords to count.
     * @example
     * // Count the number of AsoRecords
     * const count = await prisma.asoRecord.count({
     *   where: {
     *     // ... the filter for the AsoRecords we want to count
     *   }
     * })
    **/
    count<T extends AsoRecordCountArgs>(
      args?: Subset<T, AsoRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AsoRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AsoRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AsoRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AsoRecordAggregateArgs>(args: Subset<T, AsoRecordAggregateArgs>): Prisma.PrismaPromise<GetAsoRecordAggregateType<T>>

    /**
     * Group by AsoRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AsoRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AsoRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AsoRecordGroupByArgs['orderBy'] }
        : { orderBy?: AsoRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AsoRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAsoRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AsoRecord model
   */
  readonly fields: AsoRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AsoRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AsoRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AsoRecord model
   */
  interface AsoRecordFieldRefs {
    readonly id: FieldRef<"AsoRecord", 'String'>
    readonly employeeId: FieldRef<"AsoRecord", 'String'>
    readonly examType: FieldRef<"AsoRecord", 'String'>
    readonly examDate: FieldRef<"AsoRecord", 'DateTime'>
    readonly expiryDate: FieldRef<"AsoRecord", 'DateTime'>
    readonly result: FieldRef<"AsoRecord", 'String'>
    readonly status: FieldRef<"AsoRecord", 'String'>
    readonly attachmentUrl: FieldRef<"AsoRecord", 'String'>
    readonly createdAt: FieldRef<"AsoRecord", 'DateTime'>
    readonly updatedAt: FieldRef<"AsoRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AsoRecord findUnique
   */
  export type AsoRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AsoRecord
     */
    select?: AsoRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AsoRecord
     */
    omit?: AsoRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsoRecordInclude<ExtArgs> | null
    /**
     * Filter, which AsoRecord to fetch.
     */
    where: AsoRecordWhereUniqueInput
  }

  /**
   * AsoRecord findUniqueOrThrow
   */
  export type AsoRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AsoRecord
     */
    select?: AsoRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AsoRecord
     */
    omit?: AsoRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsoRecordInclude<ExtArgs> | null
    /**
     * Filter, which AsoRecord to fetch.
     */
    where: AsoRecordWhereUniqueInput
  }

  /**
   * AsoRecord findFirst
   */
  export type AsoRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AsoRecord
     */
    select?: AsoRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AsoRecord
     */
    omit?: AsoRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsoRecordInclude<ExtArgs> | null
    /**
     * Filter, which AsoRecord to fetch.
     */
    where?: AsoRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AsoRecords to fetch.
     */
    orderBy?: AsoRecordOrderByWithRelationInput | AsoRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AsoRecords.
     */
    cursor?: AsoRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AsoRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AsoRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AsoRecords.
     */
    distinct?: AsoRecordScalarFieldEnum | AsoRecordScalarFieldEnum[]
  }

  /**
   * AsoRecord findFirstOrThrow
   */
  export type AsoRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AsoRecord
     */
    select?: AsoRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AsoRecord
     */
    omit?: AsoRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsoRecordInclude<ExtArgs> | null
    /**
     * Filter, which AsoRecord to fetch.
     */
    where?: AsoRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AsoRecords to fetch.
     */
    orderBy?: AsoRecordOrderByWithRelationInput | AsoRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AsoRecords.
     */
    cursor?: AsoRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AsoRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AsoRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AsoRecords.
     */
    distinct?: AsoRecordScalarFieldEnum | AsoRecordScalarFieldEnum[]
  }

  /**
   * AsoRecord findMany
   */
  export type AsoRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AsoRecord
     */
    select?: AsoRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AsoRecord
     */
    omit?: AsoRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsoRecordInclude<ExtArgs> | null
    /**
     * Filter, which AsoRecords to fetch.
     */
    where?: AsoRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AsoRecords to fetch.
     */
    orderBy?: AsoRecordOrderByWithRelationInput | AsoRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AsoRecords.
     */
    cursor?: AsoRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AsoRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AsoRecords.
     */
    skip?: number
    distinct?: AsoRecordScalarFieldEnum | AsoRecordScalarFieldEnum[]
  }

  /**
   * AsoRecord create
   */
  export type AsoRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AsoRecord
     */
    select?: AsoRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AsoRecord
     */
    omit?: AsoRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsoRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a AsoRecord.
     */
    data: XOR<AsoRecordCreateInput, AsoRecordUncheckedCreateInput>
  }

  /**
   * AsoRecord createMany
   */
  export type AsoRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AsoRecords.
     */
    data: AsoRecordCreateManyInput | AsoRecordCreateManyInput[]
  }

  /**
   * AsoRecord createManyAndReturn
   */
  export type AsoRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AsoRecord
     */
    select?: AsoRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AsoRecord
     */
    omit?: AsoRecordOmit<ExtArgs> | null
    /**
     * The data used to create many AsoRecords.
     */
    data: AsoRecordCreateManyInput | AsoRecordCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsoRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AsoRecord update
   */
  export type AsoRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AsoRecord
     */
    select?: AsoRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AsoRecord
     */
    omit?: AsoRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsoRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a AsoRecord.
     */
    data: XOR<AsoRecordUpdateInput, AsoRecordUncheckedUpdateInput>
    /**
     * Choose, which AsoRecord to update.
     */
    where: AsoRecordWhereUniqueInput
  }

  /**
   * AsoRecord updateMany
   */
  export type AsoRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AsoRecords.
     */
    data: XOR<AsoRecordUpdateManyMutationInput, AsoRecordUncheckedUpdateManyInput>
    /**
     * Filter which AsoRecords to update
     */
    where?: AsoRecordWhereInput
    /**
     * Limit how many AsoRecords to update.
     */
    limit?: number
  }

  /**
   * AsoRecord updateManyAndReturn
   */
  export type AsoRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AsoRecord
     */
    select?: AsoRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AsoRecord
     */
    omit?: AsoRecordOmit<ExtArgs> | null
    /**
     * The data used to update AsoRecords.
     */
    data: XOR<AsoRecordUpdateManyMutationInput, AsoRecordUncheckedUpdateManyInput>
    /**
     * Filter which AsoRecords to update
     */
    where?: AsoRecordWhereInput
    /**
     * Limit how many AsoRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsoRecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AsoRecord upsert
   */
  export type AsoRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AsoRecord
     */
    select?: AsoRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AsoRecord
     */
    omit?: AsoRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsoRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the AsoRecord to update in case it exists.
     */
    where: AsoRecordWhereUniqueInput
    /**
     * In case the AsoRecord found by the `where` argument doesn't exist, create a new AsoRecord with this data.
     */
    create: XOR<AsoRecordCreateInput, AsoRecordUncheckedCreateInput>
    /**
     * In case the AsoRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AsoRecordUpdateInput, AsoRecordUncheckedUpdateInput>
  }

  /**
   * AsoRecord delete
   */
  export type AsoRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AsoRecord
     */
    select?: AsoRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AsoRecord
     */
    omit?: AsoRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsoRecordInclude<ExtArgs> | null
    /**
     * Filter which AsoRecord to delete.
     */
    where: AsoRecordWhereUniqueInput
  }

  /**
   * AsoRecord deleteMany
   */
  export type AsoRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AsoRecords to delete
     */
    where?: AsoRecordWhereInput
    /**
     * Limit how many AsoRecords to delete.
     */
    limit?: number
  }

  /**
   * AsoRecord without action
   */
  export type AsoRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AsoRecord
     */
    select?: AsoRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AsoRecord
     */
    omit?: AsoRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsoRecordInclude<ExtArgs> | null
  }


  /**
   * Model ChemicalRecord
   */

  export type AggregateChemicalRecord = {
    _count: ChemicalRecordCountAggregateOutputType | null
    _avg: ChemicalRecordAvgAggregateOutputType | null
    _sum: ChemicalRecordSumAggregateOutputType | null
    _min: ChemicalRecordMinAggregateOutputType | null
    _max: ChemicalRecordMaxAggregateOutputType | null
  }

  export type ChemicalRecordAvgAggregateOutputType = {
    quantity: number | null
  }

  export type ChemicalRecordSumAggregateOutputType = {
    quantity: number | null
  }

  export type ChemicalRecordMinAggregateOutputType = {
    id: string | null
    productName: string | null
    casNumber: string | null
    location: string | null
    quantity: number | null
    unit: string | null
    sdsUrl: string | null
    lastUpdated: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChemicalRecordMaxAggregateOutputType = {
    id: string | null
    productName: string | null
    casNumber: string | null
    location: string | null
    quantity: number | null
    unit: string | null
    sdsUrl: string | null
    lastUpdated: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChemicalRecordCountAggregateOutputType = {
    id: number
    productName: number
    casNumber: number
    location: number
    quantity: number
    unit: number
    sdsUrl: number
    lastUpdated: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChemicalRecordAvgAggregateInputType = {
    quantity?: true
  }

  export type ChemicalRecordSumAggregateInputType = {
    quantity?: true
  }

  export type ChemicalRecordMinAggregateInputType = {
    id?: true
    productName?: true
    casNumber?: true
    location?: true
    quantity?: true
    unit?: true
    sdsUrl?: true
    lastUpdated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChemicalRecordMaxAggregateInputType = {
    id?: true
    productName?: true
    casNumber?: true
    location?: true
    quantity?: true
    unit?: true
    sdsUrl?: true
    lastUpdated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChemicalRecordCountAggregateInputType = {
    id?: true
    productName?: true
    casNumber?: true
    location?: true
    quantity?: true
    unit?: true
    sdsUrl?: true
    lastUpdated?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChemicalRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChemicalRecord to aggregate.
     */
    where?: ChemicalRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChemicalRecords to fetch.
     */
    orderBy?: ChemicalRecordOrderByWithRelationInput | ChemicalRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChemicalRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChemicalRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChemicalRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChemicalRecords
    **/
    _count?: true | ChemicalRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChemicalRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChemicalRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChemicalRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChemicalRecordMaxAggregateInputType
  }

  export type GetChemicalRecordAggregateType<T extends ChemicalRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateChemicalRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChemicalRecord[P]>
      : GetScalarType<T[P], AggregateChemicalRecord[P]>
  }




  export type ChemicalRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChemicalRecordWhereInput
    orderBy?: ChemicalRecordOrderByWithAggregationInput | ChemicalRecordOrderByWithAggregationInput[]
    by: ChemicalRecordScalarFieldEnum[] | ChemicalRecordScalarFieldEnum
    having?: ChemicalRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChemicalRecordCountAggregateInputType | true
    _avg?: ChemicalRecordAvgAggregateInputType
    _sum?: ChemicalRecordSumAggregateInputType
    _min?: ChemicalRecordMinAggregateInputType
    _max?: ChemicalRecordMaxAggregateInputType
  }

  export type ChemicalRecordGroupByOutputType = {
    id: string
    productName: string
    casNumber: string | null
    location: string
    quantity: number
    unit: string
    sdsUrl: string | null
    lastUpdated: Date
    createdAt: Date
    updatedAt: Date
    _count: ChemicalRecordCountAggregateOutputType | null
    _avg: ChemicalRecordAvgAggregateOutputType | null
    _sum: ChemicalRecordSumAggregateOutputType | null
    _min: ChemicalRecordMinAggregateOutputType | null
    _max: ChemicalRecordMaxAggregateOutputType | null
  }

  type GetChemicalRecordGroupByPayload<T extends ChemicalRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChemicalRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChemicalRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChemicalRecordGroupByOutputType[P]>
            : GetScalarType<T[P], ChemicalRecordGroupByOutputType[P]>
        }
      >
    >


  export type ChemicalRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productName?: boolean
    casNumber?: boolean
    location?: boolean
    quantity?: boolean
    unit?: boolean
    sdsUrl?: boolean
    lastUpdated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["chemicalRecord"]>

  export type ChemicalRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productName?: boolean
    casNumber?: boolean
    location?: boolean
    quantity?: boolean
    unit?: boolean
    sdsUrl?: boolean
    lastUpdated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["chemicalRecord"]>

  export type ChemicalRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productName?: boolean
    casNumber?: boolean
    location?: boolean
    quantity?: boolean
    unit?: boolean
    sdsUrl?: boolean
    lastUpdated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["chemicalRecord"]>

  export type ChemicalRecordSelectScalar = {
    id?: boolean
    productName?: boolean
    casNumber?: boolean
    location?: boolean
    quantity?: boolean
    unit?: boolean
    sdsUrl?: boolean
    lastUpdated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ChemicalRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productName" | "casNumber" | "location" | "quantity" | "unit" | "sdsUrl" | "lastUpdated" | "createdAt" | "updatedAt", ExtArgs["result"]["chemicalRecord"]>

  export type $ChemicalRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChemicalRecord"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productName: string
      casNumber: string | null
      location: string
      quantity: number
      unit: string
      sdsUrl: string | null
      lastUpdated: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["chemicalRecord"]>
    composites: {}
  }

  type ChemicalRecordGetPayload<S extends boolean | null | undefined | ChemicalRecordDefaultArgs> = $Result.GetResult<Prisma.$ChemicalRecordPayload, S>

  type ChemicalRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChemicalRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChemicalRecordCountAggregateInputType | true
    }

  export interface ChemicalRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChemicalRecord'], meta: { name: 'ChemicalRecord' } }
    /**
     * Find zero or one ChemicalRecord that matches the filter.
     * @param {ChemicalRecordFindUniqueArgs} args - Arguments to find a ChemicalRecord
     * @example
     * // Get one ChemicalRecord
     * const chemicalRecord = await prisma.chemicalRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChemicalRecordFindUniqueArgs>(args: SelectSubset<T, ChemicalRecordFindUniqueArgs<ExtArgs>>): Prisma__ChemicalRecordClient<$Result.GetResult<Prisma.$ChemicalRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChemicalRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChemicalRecordFindUniqueOrThrowArgs} args - Arguments to find a ChemicalRecord
     * @example
     * // Get one ChemicalRecord
     * const chemicalRecord = await prisma.chemicalRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChemicalRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, ChemicalRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChemicalRecordClient<$Result.GetResult<Prisma.$ChemicalRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChemicalRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChemicalRecordFindFirstArgs} args - Arguments to find a ChemicalRecord
     * @example
     * // Get one ChemicalRecord
     * const chemicalRecord = await prisma.chemicalRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChemicalRecordFindFirstArgs>(args?: SelectSubset<T, ChemicalRecordFindFirstArgs<ExtArgs>>): Prisma__ChemicalRecordClient<$Result.GetResult<Prisma.$ChemicalRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChemicalRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChemicalRecordFindFirstOrThrowArgs} args - Arguments to find a ChemicalRecord
     * @example
     * // Get one ChemicalRecord
     * const chemicalRecord = await prisma.chemicalRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChemicalRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, ChemicalRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChemicalRecordClient<$Result.GetResult<Prisma.$ChemicalRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChemicalRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChemicalRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChemicalRecords
     * const chemicalRecords = await prisma.chemicalRecord.findMany()
     * 
     * // Get first 10 ChemicalRecords
     * const chemicalRecords = await prisma.chemicalRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chemicalRecordWithIdOnly = await prisma.chemicalRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChemicalRecordFindManyArgs>(args?: SelectSubset<T, ChemicalRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChemicalRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChemicalRecord.
     * @param {ChemicalRecordCreateArgs} args - Arguments to create a ChemicalRecord.
     * @example
     * // Create one ChemicalRecord
     * const ChemicalRecord = await prisma.chemicalRecord.create({
     *   data: {
     *     // ... data to create a ChemicalRecord
     *   }
     * })
     * 
     */
    create<T extends ChemicalRecordCreateArgs>(args: SelectSubset<T, ChemicalRecordCreateArgs<ExtArgs>>): Prisma__ChemicalRecordClient<$Result.GetResult<Prisma.$ChemicalRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChemicalRecords.
     * @param {ChemicalRecordCreateManyArgs} args - Arguments to create many ChemicalRecords.
     * @example
     * // Create many ChemicalRecords
     * const chemicalRecord = await prisma.chemicalRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChemicalRecordCreateManyArgs>(args?: SelectSubset<T, ChemicalRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChemicalRecords and returns the data saved in the database.
     * @param {ChemicalRecordCreateManyAndReturnArgs} args - Arguments to create many ChemicalRecords.
     * @example
     * // Create many ChemicalRecords
     * const chemicalRecord = await prisma.chemicalRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChemicalRecords and only return the `id`
     * const chemicalRecordWithIdOnly = await prisma.chemicalRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChemicalRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, ChemicalRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChemicalRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChemicalRecord.
     * @param {ChemicalRecordDeleteArgs} args - Arguments to delete one ChemicalRecord.
     * @example
     * // Delete one ChemicalRecord
     * const ChemicalRecord = await prisma.chemicalRecord.delete({
     *   where: {
     *     // ... filter to delete one ChemicalRecord
     *   }
     * })
     * 
     */
    delete<T extends ChemicalRecordDeleteArgs>(args: SelectSubset<T, ChemicalRecordDeleteArgs<ExtArgs>>): Prisma__ChemicalRecordClient<$Result.GetResult<Prisma.$ChemicalRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChemicalRecord.
     * @param {ChemicalRecordUpdateArgs} args - Arguments to update one ChemicalRecord.
     * @example
     * // Update one ChemicalRecord
     * const chemicalRecord = await prisma.chemicalRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChemicalRecordUpdateArgs>(args: SelectSubset<T, ChemicalRecordUpdateArgs<ExtArgs>>): Prisma__ChemicalRecordClient<$Result.GetResult<Prisma.$ChemicalRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChemicalRecords.
     * @param {ChemicalRecordDeleteManyArgs} args - Arguments to filter ChemicalRecords to delete.
     * @example
     * // Delete a few ChemicalRecords
     * const { count } = await prisma.chemicalRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChemicalRecordDeleteManyArgs>(args?: SelectSubset<T, ChemicalRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChemicalRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChemicalRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChemicalRecords
     * const chemicalRecord = await prisma.chemicalRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChemicalRecordUpdateManyArgs>(args: SelectSubset<T, ChemicalRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChemicalRecords and returns the data updated in the database.
     * @param {ChemicalRecordUpdateManyAndReturnArgs} args - Arguments to update many ChemicalRecords.
     * @example
     * // Update many ChemicalRecords
     * const chemicalRecord = await prisma.chemicalRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChemicalRecords and only return the `id`
     * const chemicalRecordWithIdOnly = await prisma.chemicalRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChemicalRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, ChemicalRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChemicalRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChemicalRecord.
     * @param {ChemicalRecordUpsertArgs} args - Arguments to update or create a ChemicalRecord.
     * @example
     * // Update or create a ChemicalRecord
     * const chemicalRecord = await prisma.chemicalRecord.upsert({
     *   create: {
     *     // ... data to create a ChemicalRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChemicalRecord we want to update
     *   }
     * })
     */
    upsert<T extends ChemicalRecordUpsertArgs>(args: SelectSubset<T, ChemicalRecordUpsertArgs<ExtArgs>>): Prisma__ChemicalRecordClient<$Result.GetResult<Prisma.$ChemicalRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChemicalRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChemicalRecordCountArgs} args - Arguments to filter ChemicalRecords to count.
     * @example
     * // Count the number of ChemicalRecords
     * const count = await prisma.chemicalRecord.count({
     *   where: {
     *     // ... the filter for the ChemicalRecords we want to count
     *   }
     * })
    **/
    count<T extends ChemicalRecordCountArgs>(
      args?: Subset<T, ChemicalRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChemicalRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChemicalRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChemicalRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChemicalRecordAggregateArgs>(args: Subset<T, ChemicalRecordAggregateArgs>): Prisma.PrismaPromise<GetChemicalRecordAggregateType<T>>

    /**
     * Group by ChemicalRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChemicalRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChemicalRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChemicalRecordGroupByArgs['orderBy'] }
        : { orderBy?: ChemicalRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChemicalRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChemicalRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChemicalRecord model
   */
  readonly fields: ChemicalRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChemicalRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChemicalRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChemicalRecord model
   */
  interface ChemicalRecordFieldRefs {
    readonly id: FieldRef<"ChemicalRecord", 'String'>
    readonly productName: FieldRef<"ChemicalRecord", 'String'>
    readonly casNumber: FieldRef<"ChemicalRecord", 'String'>
    readonly location: FieldRef<"ChemicalRecord", 'String'>
    readonly quantity: FieldRef<"ChemicalRecord", 'Float'>
    readonly unit: FieldRef<"ChemicalRecord", 'String'>
    readonly sdsUrl: FieldRef<"ChemicalRecord", 'String'>
    readonly lastUpdated: FieldRef<"ChemicalRecord", 'DateTime'>
    readonly createdAt: FieldRef<"ChemicalRecord", 'DateTime'>
    readonly updatedAt: FieldRef<"ChemicalRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChemicalRecord findUnique
   */
  export type ChemicalRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChemicalRecord
     */
    select?: ChemicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChemicalRecord
     */
    omit?: ChemicalRecordOmit<ExtArgs> | null
    /**
     * Filter, which ChemicalRecord to fetch.
     */
    where: ChemicalRecordWhereUniqueInput
  }

  /**
   * ChemicalRecord findUniqueOrThrow
   */
  export type ChemicalRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChemicalRecord
     */
    select?: ChemicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChemicalRecord
     */
    omit?: ChemicalRecordOmit<ExtArgs> | null
    /**
     * Filter, which ChemicalRecord to fetch.
     */
    where: ChemicalRecordWhereUniqueInput
  }

  /**
   * ChemicalRecord findFirst
   */
  export type ChemicalRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChemicalRecord
     */
    select?: ChemicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChemicalRecord
     */
    omit?: ChemicalRecordOmit<ExtArgs> | null
    /**
     * Filter, which ChemicalRecord to fetch.
     */
    where?: ChemicalRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChemicalRecords to fetch.
     */
    orderBy?: ChemicalRecordOrderByWithRelationInput | ChemicalRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChemicalRecords.
     */
    cursor?: ChemicalRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChemicalRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChemicalRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChemicalRecords.
     */
    distinct?: ChemicalRecordScalarFieldEnum | ChemicalRecordScalarFieldEnum[]
  }

  /**
   * ChemicalRecord findFirstOrThrow
   */
  export type ChemicalRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChemicalRecord
     */
    select?: ChemicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChemicalRecord
     */
    omit?: ChemicalRecordOmit<ExtArgs> | null
    /**
     * Filter, which ChemicalRecord to fetch.
     */
    where?: ChemicalRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChemicalRecords to fetch.
     */
    orderBy?: ChemicalRecordOrderByWithRelationInput | ChemicalRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChemicalRecords.
     */
    cursor?: ChemicalRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChemicalRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChemicalRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChemicalRecords.
     */
    distinct?: ChemicalRecordScalarFieldEnum | ChemicalRecordScalarFieldEnum[]
  }

  /**
   * ChemicalRecord findMany
   */
  export type ChemicalRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChemicalRecord
     */
    select?: ChemicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChemicalRecord
     */
    omit?: ChemicalRecordOmit<ExtArgs> | null
    /**
     * Filter, which ChemicalRecords to fetch.
     */
    where?: ChemicalRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChemicalRecords to fetch.
     */
    orderBy?: ChemicalRecordOrderByWithRelationInput | ChemicalRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChemicalRecords.
     */
    cursor?: ChemicalRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChemicalRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChemicalRecords.
     */
    skip?: number
    distinct?: ChemicalRecordScalarFieldEnum | ChemicalRecordScalarFieldEnum[]
  }

  /**
   * ChemicalRecord create
   */
  export type ChemicalRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChemicalRecord
     */
    select?: ChemicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChemicalRecord
     */
    omit?: ChemicalRecordOmit<ExtArgs> | null
    /**
     * The data needed to create a ChemicalRecord.
     */
    data: XOR<ChemicalRecordCreateInput, ChemicalRecordUncheckedCreateInput>
  }

  /**
   * ChemicalRecord createMany
   */
  export type ChemicalRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChemicalRecords.
     */
    data: ChemicalRecordCreateManyInput | ChemicalRecordCreateManyInput[]
  }

  /**
   * ChemicalRecord createManyAndReturn
   */
  export type ChemicalRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChemicalRecord
     */
    select?: ChemicalRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChemicalRecord
     */
    omit?: ChemicalRecordOmit<ExtArgs> | null
    /**
     * The data used to create many ChemicalRecords.
     */
    data: ChemicalRecordCreateManyInput | ChemicalRecordCreateManyInput[]
  }

  /**
   * ChemicalRecord update
   */
  export type ChemicalRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChemicalRecord
     */
    select?: ChemicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChemicalRecord
     */
    omit?: ChemicalRecordOmit<ExtArgs> | null
    /**
     * The data needed to update a ChemicalRecord.
     */
    data: XOR<ChemicalRecordUpdateInput, ChemicalRecordUncheckedUpdateInput>
    /**
     * Choose, which ChemicalRecord to update.
     */
    where: ChemicalRecordWhereUniqueInput
  }

  /**
   * ChemicalRecord updateMany
   */
  export type ChemicalRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChemicalRecords.
     */
    data: XOR<ChemicalRecordUpdateManyMutationInput, ChemicalRecordUncheckedUpdateManyInput>
    /**
     * Filter which ChemicalRecords to update
     */
    where?: ChemicalRecordWhereInput
    /**
     * Limit how many ChemicalRecords to update.
     */
    limit?: number
  }

  /**
   * ChemicalRecord updateManyAndReturn
   */
  export type ChemicalRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChemicalRecord
     */
    select?: ChemicalRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChemicalRecord
     */
    omit?: ChemicalRecordOmit<ExtArgs> | null
    /**
     * The data used to update ChemicalRecords.
     */
    data: XOR<ChemicalRecordUpdateManyMutationInput, ChemicalRecordUncheckedUpdateManyInput>
    /**
     * Filter which ChemicalRecords to update
     */
    where?: ChemicalRecordWhereInput
    /**
     * Limit how many ChemicalRecords to update.
     */
    limit?: number
  }

  /**
   * ChemicalRecord upsert
   */
  export type ChemicalRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChemicalRecord
     */
    select?: ChemicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChemicalRecord
     */
    omit?: ChemicalRecordOmit<ExtArgs> | null
    /**
     * The filter to search for the ChemicalRecord to update in case it exists.
     */
    where: ChemicalRecordWhereUniqueInput
    /**
     * In case the ChemicalRecord found by the `where` argument doesn't exist, create a new ChemicalRecord with this data.
     */
    create: XOR<ChemicalRecordCreateInput, ChemicalRecordUncheckedCreateInput>
    /**
     * In case the ChemicalRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChemicalRecordUpdateInput, ChemicalRecordUncheckedUpdateInput>
  }

  /**
   * ChemicalRecord delete
   */
  export type ChemicalRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChemicalRecord
     */
    select?: ChemicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChemicalRecord
     */
    omit?: ChemicalRecordOmit<ExtArgs> | null
    /**
     * Filter which ChemicalRecord to delete.
     */
    where: ChemicalRecordWhereUniqueInput
  }

  /**
   * ChemicalRecord deleteMany
   */
  export type ChemicalRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChemicalRecords to delete
     */
    where?: ChemicalRecordWhereInput
    /**
     * Limit how many ChemicalRecords to delete.
     */
    limit?: number
  }

  /**
   * ChemicalRecord without action
   */
  export type ChemicalRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChemicalRecord
     */
    select?: ChemicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChemicalRecord
     */
    omit?: ChemicalRecordOmit<ExtArgs> | null
  }


  /**
   * Model JsaRecord
   */

  export type AggregateJsaRecord = {
    _count: JsaRecordCountAggregateOutputType | null
    _min: JsaRecordMinAggregateOutputType | null
    _max: JsaRecordMaxAggregateOutputType | null
  }

  export type JsaRecordMinAggregateOutputType = {
    id: string | null
    taskName: string | null
    department: string | null
    analysisDate: Date | null
    reviewDate: Date | null
    status: string | null
    attachmentUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JsaRecordMaxAggregateOutputType = {
    id: string | null
    taskName: string | null
    department: string | null
    analysisDate: Date | null
    reviewDate: Date | null
    status: string | null
    attachmentUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JsaRecordCountAggregateOutputType = {
    id: number
    taskName: number
    department: number
    analysisDate: number
    reviewDate: number
    status: number
    attachmentUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type JsaRecordMinAggregateInputType = {
    id?: true
    taskName?: true
    department?: true
    analysisDate?: true
    reviewDate?: true
    status?: true
    attachmentUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JsaRecordMaxAggregateInputType = {
    id?: true
    taskName?: true
    department?: true
    analysisDate?: true
    reviewDate?: true
    status?: true
    attachmentUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JsaRecordCountAggregateInputType = {
    id?: true
    taskName?: true
    department?: true
    analysisDate?: true
    reviewDate?: true
    status?: true
    attachmentUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type JsaRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JsaRecord to aggregate.
     */
    where?: JsaRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JsaRecords to fetch.
     */
    orderBy?: JsaRecordOrderByWithRelationInput | JsaRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JsaRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JsaRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JsaRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JsaRecords
    **/
    _count?: true | JsaRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JsaRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JsaRecordMaxAggregateInputType
  }

  export type GetJsaRecordAggregateType<T extends JsaRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateJsaRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJsaRecord[P]>
      : GetScalarType<T[P], AggregateJsaRecord[P]>
  }




  export type JsaRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JsaRecordWhereInput
    orderBy?: JsaRecordOrderByWithAggregationInput | JsaRecordOrderByWithAggregationInput[]
    by: JsaRecordScalarFieldEnum[] | JsaRecordScalarFieldEnum
    having?: JsaRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JsaRecordCountAggregateInputType | true
    _min?: JsaRecordMinAggregateInputType
    _max?: JsaRecordMaxAggregateInputType
  }

  export type JsaRecordGroupByOutputType = {
    id: string
    taskName: string
    department: string
    analysisDate: Date
    reviewDate: Date | null
    status: string
    attachmentUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: JsaRecordCountAggregateOutputType | null
    _min: JsaRecordMinAggregateOutputType | null
    _max: JsaRecordMaxAggregateOutputType | null
  }

  type GetJsaRecordGroupByPayload<T extends JsaRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JsaRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JsaRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JsaRecordGroupByOutputType[P]>
            : GetScalarType<T[P], JsaRecordGroupByOutputType[P]>
        }
      >
    >


  export type JsaRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskName?: boolean
    department?: boolean
    analysisDate?: boolean
    reviewDate?: boolean
    status?: boolean
    attachmentUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    risks?: boolean | JsaRecord$risksArgs<ExtArgs>
    _count?: boolean | JsaRecordCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jsaRecord"]>

  export type JsaRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskName?: boolean
    department?: boolean
    analysisDate?: boolean
    reviewDate?: boolean
    status?: boolean
    attachmentUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["jsaRecord"]>

  export type JsaRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskName?: boolean
    department?: boolean
    analysisDate?: boolean
    reviewDate?: boolean
    status?: boolean
    attachmentUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["jsaRecord"]>

  export type JsaRecordSelectScalar = {
    id?: boolean
    taskName?: boolean
    department?: boolean
    analysisDate?: boolean
    reviewDate?: boolean
    status?: boolean
    attachmentUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type JsaRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "taskName" | "department" | "analysisDate" | "reviewDate" | "status" | "attachmentUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["jsaRecord"]>
  export type JsaRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    risks?: boolean | JsaRecord$risksArgs<ExtArgs>
    _count?: boolean | JsaRecordCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type JsaRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type JsaRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $JsaRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JsaRecord"
    objects: {
      risks: Prisma.$RiskItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      taskName: string
      department: string
      analysisDate: Date
      reviewDate: Date | null
      status: string
      attachmentUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["jsaRecord"]>
    composites: {}
  }

  type JsaRecordGetPayload<S extends boolean | null | undefined | JsaRecordDefaultArgs> = $Result.GetResult<Prisma.$JsaRecordPayload, S>

  type JsaRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JsaRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JsaRecordCountAggregateInputType | true
    }

  export interface JsaRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JsaRecord'], meta: { name: 'JsaRecord' } }
    /**
     * Find zero or one JsaRecord that matches the filter.
     * @param {JsaRecordFindUniqueArgs} args - Arguments to find a JsaRecord
     * @example
     * // Get one JsaRecord
     * const jsaRecord = await prisma.jsaRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JsaRecordFindUniqueArgs>(args: SelectSubset<T, JsaRecordFindUniqueArgs<ExtArgs>>): Prisma__JsaRecordClient<$Result.GetResult<Prisma.$JsaRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JsaRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JsaRecordFindUniqueOrThrowArgs} args - Arguments to find a JsaRecord
     * @example
     * // Get one JsaRecord
     * const jsaRecord = await prisma.jsaRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JsaRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, JsaRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JsaRecordClient<$Result.GetResult<Prisma.$JsaRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JsaRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JsaRecordFindFirstArgs} args - Arguments to find a JsaRecord
     * @example
     * // Get one JsaRecord
     * const jsaRecord = await prisma.jsaRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JsaRecordFindFirstArgs>(args?: SelectSubset<T, JsaRecordFindFirstArgs<ExtArgs>>): Prisma__JsaRecordClient<$Result.GetResult<Prisma.$JsaRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JsaRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JsaRecordFindFirstOrThrowArgs} args - Arguments to find a JsaRecord
     * @example
     * // Get one JsaRecord
     * const jsaRecord = await prisma.jsaRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JsaRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, JsaRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__JsaRecordClient<$Result.GetResult<Prisma.$JsaRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JsaRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JsaRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JsaRecords
     * const jsaRecords = await prisma.jsaRecord.findMany()
     * 
     * // Get first 10 JsaRecords
     * const jsaRecords = await prisma.jsaRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jsaRecordWithIdOnly = await prisma.jsaRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JsaRecordFindManyArgs>(args?: SelectSubset<T, JsaRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JsaRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JsaRecord.
     * @param {JsaRecordCreateArgs} args - Arguments to create a JsaRecord.
     * @example
     * // Create one JsaRecord
     * const JsaRecord = await prisma.jsaRecord.create({
     *   data: {
     *     // ... data to create a JsaRecord
     *   }
     * })
     * 
     */
    create<T extends JsaRecordCreateArgs>(args: SelectSubset<T, JsaRecordCreateArgs<ExtArgs>>): Prisma__JsaRecordClient<$Result.GetResult<Prisma.$JsaRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JsaRecords.
     * @param {JsaRecordCreateManyArgs} args - Arguments to create many JsaRecords.
     * @example
     * // Create many JsaRecords
     * const jsaRecord = await prisma.jsaRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JsaRecordCreateManyArgs>(args?: SelectSubset<T, JsaRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JsaRecords and returns the data saved in the database.
     * @param {JsaRecordCreateManyAndReturnArgs} args - Arguments to create many JsaRecords.
     * @example
     * // Create many JsaRecords
     * const jsaRecord = await prisma.jsaRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JsaRecords and only return the `id`
     * const jsaRecordWithIdOnly = await prisma.jsaRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JsaRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, JsaRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JsaRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JsaRecord.
     * @param {JsaRecordDeleteArgs} args - Arguments to delete one JsaRecord.
     * @example
     * // Delete one JsaRecord
     * const JsaRecord = await prisma.jsaRecord.delete({
     *   where: {
     *     // ... filter to delete one JsaRecord
     *   }
     * })
     * 
     */
    delete<T extends JsaRecordDeleteArgs>(args: SelectSubset<T, JsaRecordDeleteArgs<ExtArgs>>): Prisma__JsaRecordClient<$Result.GetResult<Prisma.$JsaRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JsaRecord.
     * @param {JsaRecordUpdateArgs} args - Arguments to update one JsaRecord.
     * @example
     * // Update one JsaRecord
     * const jsaRecord = await prisma.jsaRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JsaRecordUpdateArgs>(args: SelectSubset<T, JsaRecordUpdateArgs<ExtArgs>>): Prisma__JsaRecordClient<$Result.GetResult<Prisma.$JsaRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JsaRecords.
     * @param {JsaRecordDeleteManyArgs} args - Arguments to filter JsaRecords to delete.
     * @example
     * // Delete a few JsaRecords
     * const { count } = await prisma.jsaRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JsaRecordDeleteManyArgs>(args?: SelectSubset<T, JsaRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JsaRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JsaRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JsaRecords
     * const jsaRecord = await prisma.jsaRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JsaRecordUpdateManyArgs>(args: SelectSubset<T, JsaRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JsaRecords and returns the data updated in the database.
     * @param {JsaRecordUpdateManyAndReturnArgs} args - Arguments to update many JsaRecords.
     * @example
     * // Update many JsaRecords
     * const jsaRecord = await prisma.jsaRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JsaRecords and only return the `id`
     * const jsaRecordWithIdOnly = await prisma.jsaRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JsaRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, JsaRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JsaRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JsaRecord.
     * @param {JsaRecordUpsertArgs} args - Arguments to update or create a JsaRecord.
     * @example
     * // Update or create a JsaRecord
     * const jsaRecord = await prisma.jsaRecord.upsert({
     *   create: {
     *     // ... data to create a JsaRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JsaRecord we want to update
     *   }
     * })
     */
    upsert<T extends JsaRecordUpsertArgs>(args: SelectSubset<T, JsaRecordUpsertArgs<ExtArgs>>): Prisma__JsaRecordClient<$Result.GetResult<Prisma.$JsaRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JsaRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JsaRecordCountArgs} args - Arguments to filter JsaRecords to count.
     * @example
     * // Count the number of JsaRecords
     * const count = await prisma.jsaRecord.count({
     *   where: {
     *     // ... the filter for the JsaRecords we want to count
     *   }
     * })
    **/
    count<T extends JsaRecordCountArgs>(
      args?: Subset<T, JsaRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JsaRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JsaRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JsaRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JsaRecordAggregateArgs>(args: Subset<T, JsaRecordAggregateArgs>): Prisma.PrismaPromise<GetJsaRecordAggregateType<T>>

    /**
     * Group by JsaRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JsaRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JsaRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JsaRecordGroupByArgs['orderBy'] }
        : { orderBy?: JsaRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JsaRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJsaRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JsaRecord model
   */
  readonly fields: JsaRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JsaRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JsaRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    risks<T extends JsaRecord$risksArgs<ExtArgs> = {}>(args?: Subset<T, JsaRecord$risksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JsaRecord model
   */
  interface JsaRecordFieldRefs {
    readonly id: FieldRef<"JsaRecord", 'String'>
    readonly taskName: FieldRef<"JsaRecord", 'String'>
    readonly department: FieldRef<"JsaRecord", 'String'>
    readonly analysisDate: FieldRef<"JsaRecord", 'DateTime'>
    readonly reviewDate: FieldRef<"JsaRecord", 'DateTime'>
    readonly status: FieldRef<"JsaRecord", 'String'>
    readonly attachmentUrl: FieldRef<"JsaRecord", 'String'>
    readonly createdAt: FieldRef<"JsaRecord", 'DateTime'>
    readonly updatedAt: FieldRef<"JsaRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * JsaRecord findUnique
   */
  export type JsaRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JsaRecord
     */
    select?: JsaRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JsaRecord
     */
    omit?: JsaRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JsaRecordInclude<ExtArgs> | null
    /**
     * Filter, which JsaRecord to fetch.
     */
    where: JsaRecordWhereUniqueInput
  }

  /**
   * JsaRecord findUniqueOrThrow
   */
  export type JsaRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JsaRecord
     */
    select?: JsaRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JsaRecord
     */
    omit?: JsaRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JsaRecordInclude<ExtArgs> | null
    /**
     * Filter, which JsaRecord to fetch.
     */
    where: JsaRecordWhereUniqueInput
  }

  /**
   * JsaRecord findFirst
   */
  export type JsaRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JsaRecord
     */
    select?: JsaRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JsaRecord
     */
    omit?: JsaRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JsaRecordInclude<ExtArgs> | null
    /**
     * Filter, which JsaRecord to fetch.
     */
    where?: JsaRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JsaRecords to fetch.
     */
    orderBy?: JsaRecordOrderByWithRelationInput | JsaRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JsaRecords.
     */
    cursor?: JsaRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JsaRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JsaRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JsaRecords.
     */
    distinct?: JsaRecordScalarFieldEnum | JsaRecordScalarFieldEnum[]
  }

  /**
   * JsaRecord findFirstOrThrow
   */
  export type JsaRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JsaRecord
     */
    select?: JsaRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JsaRecord
     */
    omit?: JsaRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JsaRecordInclude<ExtArgs> | null
    /**
     * Filter, which JsaRecord to fetch.
     */
    where?: JsaRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JsaRecords to fetch.
     */
    orderBy?: JsaRecordOrderByWithRelationInput | JsaRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JsaRecords.
     */
    cursor?: JsaRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JsaRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JsaRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JsaRecords.
     */
    distinct?: JsaRecordScalarFieldEnum | JsaRecordScalarFieldEnum[]
  }

  /**
   * JsaRecord findMany
   */
  export type JsaRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JsaRecord
     */
    select?: JsaRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JsaRecord
     */
    omit?: JsaRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JsaRecordInclude<ExtArgs> | null
    /**
     * Filter, which JsaRecords to fetch.
     */
    where?: JsaRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JsaRecords to fetch.
     */
    orderBy?: JsaRecordOrderByWithRelationInput | JsaRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JsaRecords.
     */
    cursor?: JsaRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JsaRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JsaRecords.
     */
    skip?: number
    distinct?: JsaRecordScalarFieldEnum | JsaRecordScalarFieldEnum[]
  }

  /**
   * JsaRecord create
   */
  export type JsaRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JsaRecord
     */
    select?: JsaRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JsaRecord
     */
    omit?: JsaRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JsaRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a JsaRecord.
     */
    data: XOR<JsaRecordCreateInput, JsaRecordUncheckedCreateInput>
  }

  /**
   * JsaRecord createMany
   */
  export type JsaRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JsaRecords.
     */
    data: JsaRecordCreateManyInput | JsaRecordCreateManyInput[]
  }

  /**
   * JsaRecord createManyAndReturn
   */
  export type JsaRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JsaRecord
     */
    select?: JsaRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JsaRecord
     */
    omit?: JsaRecordOmit<ExtArgs> | null
    /**
     * The data used to create many JsaRecords.
     */
    data: JsaRecordCreateManyInput | JsaRecordCreateManyInput[]
  }

  /**
   * JsaRecord update
   */
  export type JsaRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JsaRecord
     */
    select?: JsaRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JsaRecord
     */
    omit?: JsaRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JsaRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a JsaRecord.
     */
    data: XOR<JsaRecordUpdateInput, JsaRecordUncheckedUpdateInput>
    /**
     * Choose, which JsaRecord to update.
     */
    where: JsaRecordWhereUniqueInput
  }

  /**
   * JsaRecord updateMany
   */
  export type JsaRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JsaRecords.
     */
    data: XOR<JsaRecordUpdateManyMutationInput, JsaRecordUncheckedUpdateManyInput>
    /**
     * Filter which JsaRecords to update
     */
    where?: JsaRecordWhereInput
    /**
     * Limit how many JsaRecords to update.
     */
    limit?: number
  }

  /**
   * JsaRecord updateManyAndReturn
   */
  export type JsaRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JsaRecord
     */
    select?: JsaRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JsaRecord
     */
    omit?: JsaRecordOmit<ExtArgs> | null
    /**
     * The data used to update JsaRecords.
     */
    data: XOR<JsaRecordUpdateManyMutationInput, JsaRecordUncheckedUpdateManyInput>
    /**
     * Filter which JsaRecords to update
     */
    where?: JsaRecordWhereInput
    /**
     * Limit how many JsaRecords to update.
     */
    limit?: number
  }

  /**
   * JsaRecord upsert
   */
  export type JsaRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JsaRecord
     */
    select?: JsaRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JsaRecord
     */
    omit?: JsaRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JsaRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the JsaRecord to update in case it exists.
     */
    where: JsaRecordWhereUniqueInput
    /**
     * In case the JsaRecord found by the `where` argument doesn't exist, create a new JsaRecord with this data.
     */
    create: XOR<JsaRecordCreateInput, JsaRecordUncheckedCreateInput>
    /**
     * In case the JsaRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JsaRecordUpdateInput, JsaRecordUncheckedUpdateInput>
  }

  /**
   * JsaRecord delete
   */
  export type JsaRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JsaRecord
     */
    select?: JsaRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JsaRecord
     */
    omit?: JsaRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JsaRecordInclude<ExtArgs> | null
    /**
     * Filter which JsaRecord to delete.
     */
    where: JsaRecordWhereUniqueInput
  }

  /**
   * JsaRecord deleteMany
   */
  export type JsaRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JsaRecords to delete
     */
    where?: JsaRecordWhereInput
    /**
     * Limit how many JsaRecords to delete.
     */
    limit?: number
  }

  /**
   * JsaRecord.risks
   */
  export type JsaRecord$risksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskItem
     */
    select?: RiskItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskItem
     */
    omit?: RiskItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskItemInclude<ExtArgs> | null
    where?: RiskItemWhereInput
    orderBy?: RiskItemOrderByWithRelationInput | RiskItemOrderByWithRelationInput[]
    cursor?: RiskItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RiskItemScalarFieldEnum | RiskItemScalarFieldEnum[]
  }

  /**
   * JsaRecord without action
   */
  export type JsaRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JsaRecord
     */
    select?: JsaRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JsaRecord
     */
    omit?: JsaRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JsaRecordInclude<ExtArgs> | null
  }


  /**
   * Model RiskItem
   */

  export type AggregateRiskItem = {
    _count: RiskItemCountAggregateOutputType | null
    _min: RiskItemMinAggregateOutputType | null
    _max: RiskItemMaxAggregateOutputType | null
  }

  export type RiskItemMinAggregateOutputType = {
    id: string | null
    jsaId: string | null
    description: string | null
    controls: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RiskItemMaxAggregateOutputType = {
    id: string | null
    jsaId: string | null
    description: string | null
    controls: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RiskItemCountAggregateOutputType = {
    id: number
    jsaId: number
    description: number
    controls: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RiskItemMinAggregateInputType = {
    id?: true
    jsaId?: true
    description?: true
    controls?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RiskItemMaxAggregateInputType = {
    id?: true
    jsaId?: true
    description?: true
    controls?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RiskItemCountAggregateInputType = {
    id?: true
    jsaId?: true
    description?: true
    controls?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RiskItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RiskItem to aggregate.
     */
    where?: RiskItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskItems to fetch.
     */
    orderBy?: RiskItemOrderByWithRelationInput | RiskItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RiskItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RiskItems
    **/
    _count?: true | RiskItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RiskItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RiskItemMaxAggregateInputType
  }

  export type GetRiskItemAggregateType<T extends RiskItemAggregateArgs> = {
        [P in keyof T & keyof AggregateRiskItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRiskItem[P]>
      : GetScalarType<T[P], AggregateRiskItem[P]>
  }




  export type RiskItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RiskItemWhereInput
    orderBy?: RiskItemOrderByWithAggregationInput | RiskItemOrderByWithAggregationInput[]
    by: RiskItemScalarFieldEnum[] | RiskItemScalarFieldEnum
    having?: RiskItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RiskItemCountAggregateInputType | true
    _min?: RiskItemMinAggregateInputType
    _max?: RiskItemMaxAggregateInputType
  }

  export type RiskItemGroupByOutputType = {
    id: string
    jsaId: string
    description: string
    controls: string
    createdAt: Date
    updatedAt: Date
    _count: RiskItemCountAggregateOutputType | null
    _min: RiskItemMinAggregateOutputType | null
    _max: RiskItemMaxAggregateOutputType | null
  }

  type GetRiskItemGroupByPayload<T extends RiskItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RiskItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RiskItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RiskItemGroupByOutputType[P]>
            : GetScalarType<T[P], RiskItemGroupByOutputType[P]>
        }
      >
    >


  export type RiskItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jsaId?: boolean
    description?: boolean
    controls?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    jsa?: boolean | JsaRecordDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["riskItem"]>

  export type RiskItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jsaId?: boolean
    description?: boolean
    controls?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    jsa?: boolean | JsaRecordDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["riskItem"]>

  export type RiskItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jsaId?: boolean
    description?: boolean
    controls?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    jsa?: boolean | JsaRecordDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["riskItem"]>

  export type RiskItemSelectScalar = {
    id?: boolean
    jsaId?: boolean
    description?: boolean
    controls?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RiskItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "jsaId" | "description" | "controls" | "createdAt" | "updatedAt", ExtArgs["result"]["riskItem"]>
  export type RiskItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jsa?: boolean | JsaRecordDefaultArgs<ExtArgs>
  }
  export type RiskItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jsa?: boolean | JsaRecordDefaultArgs<ExtArgs>
  }
  export type RiskItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jsa?: boolean | JsaRecordDefaultArgs<ExtArgs>
  }

  export type $RiskItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RiskItem"
    objects: {
      jsa: Prisma.$JsaRecordPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jsaId: string
      description: string
      controls: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["riskItem"]>
    composites: {}
  }

  type RiskItemGetPayload<S extends boolean | null | undefined | RiskItemDefaultArgs> = $Result.GetResult<Prisma.$RiskItemPayload, S>

  type RiskItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RiskItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RiskItemCountAggregateInputType | true
    }

  export interface RiskItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RiskItem'], meta: { name: 'RiskItem' } }
    /**
     * Find zero or one RiskItem that matches the filter.
     * @param {RiskItemFindUniqueArgs} args - Arguments to find a RiskItem
     * @example
     * // Get one RiskItem
     * const riskItem = await prisma.riskItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RiskItemFindUniqueArgs>(args: SelectSubset<T, RiskItemFindUniqueArgs<ExtArgs>>): Prisma__RiskItemClient<$Result.GetResult<Prisma.$RiskItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RiskItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RiskItemFindUniqueOrThrowArgs} args - Arguments to find a RiskItem
     * @example
     * // Get one RiskItem
     * const riskItem = await prisma.riskItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RiskItemFindUniqueOrThrowArgs>(args: SelectSubset<T, RiskItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RiskItemClient<$Result.GetResult<Prisma.$RiskItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RiskItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskItemFindFirstArgs} args - Arguments to find a RiskItem
     * @example
     * // Get one RiskItem
     * const riskItem = await prisma.riskItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RiskItemFindFirstArgs>(args?: SelectSubset<T, RiskItemFindFirstArgs<ExtArgs>>): Prisma__RiskItemClient<$Result.GetResult<Prisma.$RiskItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RiskItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskItemFindFirstOrThrowArgs} args - Arguments to find a RiskItem
     * @example
     * // Get one RiskItem
     * const riskItem = await prisma.riskItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RiskItemFindFirstOrThrowArgs>(args?: SelectSubset<T, RiskItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__RiskItemClient<$Result.GetResult<Prisma.$RiskItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RiskItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RiskItems
     * const riskItems = await prisma.riskItem.findMany()
     * 
     * // Get first 10 RiskItems
     * const riskItems = await prisma.riskItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const riskItemWithIdOnly = await prisma.riskItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RiskItemFindManyArgs>(args?: SelectSubset<T, RiskItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RiskItem.
     * @param {RiskItemCreateArgs} args - Arguments to create a RiskItem.
     * @example
     * // Create one RiskItem
     * const RiskItem = await prisma.riskItem.create({
     *   data: {
     *     // ... data to create a RiskItem
     *   }
     * })
     * 
     */
    create<T extends RiskItemCreateArgs>(args: SelectSubset<T, RiskItemCreateArgs<ExtArgs>>): Prisma__RiskItemClient<$Result.GetResult<Prisma.$RiskItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RiskItems.
     * @param {RiskItemCreateManyArgs} args - Arguments to create many RiskItems.
     * @example
     * // Create many RiskItems
     * const riskItem = await prisma.riskItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RiskItemCreateManyArgs>(args?: SelectSubset<T, RiskItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RiskItems and returns the data saved in the database.
     * @param {RiskItemCreateManyAndReturnArgs} args - Arguments to create many RiskItems.
     * @example
     * // Create many RiskItems
     * const riskItem = await prisma.riskItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RiskItems and only return the `id`
     * const riskItemWithIdOnly = await prisma.riskItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RiskItemCreateManyAndReturnArgs>(args?: SelectSubset<T, RiskItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RiskItem.
     * @param {RiskItemDeleteArgs} args - Arguments to delete one RiskItem.
     * @example
     * // Delete one RiskItem
     * const RiskItem = await prisma.riskItem.delete({
     *   where: {
     *     // ... filter to delete one RiskItem
     *   }
     * })
     * 
     */
    delete<T extends RiskItemDeleteArgs>(args: SelectSubset<T, RiskItemDeleteArgs<ExtArgs>>): Prisma__RiskItemClient<$Result.GetResult<Prisma.$RiskItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RiskItem.
     * @param {RiskItemUpdateArgs} args - Arguments to update one RiskItem.
     * @example
     * // Update one RiskItem
     * const riskItem = await prisma.riskItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RiskItemUpdateArgs>(args: SelectSubset<T, RiskItemUpdateArgs<ExtArgs>>): Prisma__RiskItemClient<$Result.GetResult<Prisma.$RiskItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RiskItems.
     * @param {RiskItemDeleteManyArgs} args - Arguments to filter RiskItems to delete.
     * @example
     * // Delete a few RiskItems
     * const { count } = await prisma.riskItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RiskItemDeleteManyArgs>(args?: SelectSubset<T, RiskItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RiskItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RiskItems
     * const riskItem = await prisma.riskItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RiskItemUpdateManyArgs>(args: SelectSubset<T, RiskItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RiskItems and returns the data updated in the database.
     * @param {RiskItemUpdateManyAndReturnArgs} args - Arguments to update many RiskItems.
     * @example
     * // Update many RiskItems
     * const riskItem = await prisma.riskItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RiskItems and only return the `id`
     * const riskItemWithIdOnly = await prisma.riskItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RiskItemUpdateManyAndReturnArgs>(args: SelectSubset<T, RiskItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RiskItem.
     * @param {RiskItemUpsertArgs} args - Arguments to update or create a RiskItem.
     * @example
     * // Update or create a RiskItem
     * const riskItem = await prisma.riskItem.upsert({
     *   create: {
     *     // ... data to create a RiskItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RiskItem we want to update
     *   }
     * })
     */
    upsert<T extends RiskItemUpsertArgs>(args: SelectSubset<T, RiskItemUpsertArgs<ExtArgs>>): Prisma__RiskItemClient<$Result.GetResult<Prisma.$RiskItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RiskItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskItemCountArgs} args - Arguments to filter RiskItems to count.
     * @example
     * // Count the number of RiskItems
     * const count = await prisma.riskItem.count({
     *   where: {
     *     // ... the filter for the RiskItems we want to count
     *   }
     * })
    **/
    count<T extends RiskItemCountArgs>(
      args?: Subset<T, RiskItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RiskItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RiskItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RiskItemAggregateArgs>(args: Subset<T, RiskItemAggregateArgs>): Prisma.PrismaPromise<GetRiskItemAggregateType<T>>

    /**
     * Group by RiskItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RiskItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RiskItemGroupByArgs['orderBy'] }
        : { orderBy?: RiskItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RiskItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRiskItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RiskItem model
   */
  readonly fields: RiskItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RiskItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RiskItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    jsa<T extends JsaRecordDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JsaRecordDefaultArgs<ExtArgs>>): Prisma__JsaRecordClient<$Result.GetResult<Prisma.$JsaRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RiskItem model
   */
  interface RiskItemFieldRefs {
    readonly id: FieldRef<"RiskItem", 'String'>
    readonly jsaId: FieldRef<"RiskItem", 'String'>
    readonly description: FieldRef<"RiskItem", 'String'>
    readonly controls: FieldRef<"RiskItem", 'String'>
    readonly createdAt: FieldRef<"RiskItem", 'DateTime'>
    readonly updatedAt: FieldRef<"RiskItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RiskItem findUnique
   */
  export type RiskItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskItem
     */
    select?: RiskItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskItem
     */
    omit?: RiskItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskItemInclude<ExtArgs> | null
    /**
     * Filter, which RiskItem to fetch.
     */
    where: RiskItemWhereUniqueInput
  }

  /**
   * RiskItem findUniqueOrThrow
   */
  export type RiskItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskItem
     */
    select?: RiskItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskItem
     */
    omit?: RiskItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskItemInclude<ExtArgs> | null
    /**
     * Filter, which RiskItem to fetch.
     */
    where: RiskItemWhereUniqueInput
  }

  /**
   * RiskItem findFirst
   */
  export type RiskItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskItem
     */
    select?: RiskItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskItem
     */
    omit?: RiskItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskItemInclude<ExtArgs> | null
    /**
     * Filter, which RiskItem to fetch.
     */
    where?: RiskItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskItems to fetch.
     */
    orderBy?: RiskItemOrderByWithRelationInput | RiskItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RiskItems.
     */
    cursor?: RiskItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RiskItems.
     */
    distinct?: RiskItemScalarFieldEnum | RiskItemScalarFieldEnum[]
  }

  /**
   * RiskItem findFirstOrThrow
   */
  export type RiskItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskItem
     */
    select?: RiskItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskItem
     */
    omit?: RiskItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskItemInclude<ExtArgs> | null
    /**
     * Filter, which RiskItem to fetch.
     */
    where?: RiskItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskItems to fetch.
     */
    orderBy?: RiskItemOrderByWithRelationInput | RiskItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RiskItems.
     */
    cursor?: RiskItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RiskItems.
     */
    distinct?: RiskItemScalarFieldEnum | RiskItemScalarFieldEnum[]
  }

  /**
   * RiskItem findMany
   */
  export type RiskItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskItem
     */
    select?: RiskItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskItem
     */
    omit?: RiskItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskItemInclude<ExtArgs> | null
    /**
     * Filter, which RiskItems to fetch.
     */
    where?: RiskItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskItems to fetch.
     */
    orderBy?: RiskItemOrderByWithRelationInput | RiskItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RiskItems.
     */
    cursor?: RiskItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskItems.
     */
    skip?: number
    distinct?: RiskItemScalarFieldEnum | RiskItemScalarFieldEnum[]
  }

  /**
   * RiskItem create
   */
  export type RiskItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskItem
     */
    select?: RiskItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskItem
     */
    omit?: RiskItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskItemInclude<ExtArgs> | null
    /**
     * The data needed to create a RiskItem.
     */
    data: XOR<RiskItemCreateInput, RiskItemUncheckedCreateInput>
  }

  /**
   * RiskItem createMany
   */
  export type RiskItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RiskItems.
     */
    data: RiskItemCreateManyInput | RiskItemCreateManyInput[]
  }

  /**
   * RiskItem createManyAndReturn
   */
  export type RiskItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskItem
     */
    select?: RiskItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RiskItem
     */
    omit?: RiskItemOmit<ExtArgs> | null
    /**
     * The data used to create many RiskItems.
     */
    data: RiskItemCreateManyInput | RiskItemCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RiskItem update
   */
  export type RiskItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskItem
     */
    select?: RiskItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskItem
     */
    omit?: RiskItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskItemInclude<ExtArgs> | null
    /**
     * The data needed to update a RiskItem.
     */
    data: XOR<RiskItemUpdateInput, RiskItemUncheckedUpdateInput>
    /**
     * Choose, which RiskItem to update.
     */
    where: RiskItemWhereUniqueInput
  }

  /**
   * RiskItem updateMany
   */
  export type RiskItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RiskItems.
     */
    data: XOR<RiskItemUpdateManyMutationInput, RiskItemUncheckedUpdateManyInput>
    /**
     * Filter which RiskItems to update
     */
    where?: RiskItemWhereInput
    /**
     * Limit how many RiskItems to update.
     */
    limit?: number
  }

  /**
   * RiskItem updateManyAndReturn
   */
  export type RiskItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskItem
     */
    select?: RiskItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RiskItem
     */
    omit?: RiskItemOmit<ExtArgs> | null
    /**
     * The data used to update RiskItems.
     */
    data: XOR<RiskItemUpdateManyMutationInput, RiskItemUncheckedUpdateManyInput>
    /**
     * Filter which RiskItems to update
     */
    where?: RiskItemWhereInput
    /**
     * Limit how many RiskItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RiskItem upsert
   */
  export type RiskItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskItem
     */
    select?: RiskItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskItem
     */
    omit?: RiskItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskItemInclude<ExtArgs> | null
    /**
     * The filter to search for the RiskItem to update in case it exists.
     */
    where: RiskItemWhereUniqueInput
    /**
     * In case the RiskItem found by the `where` argument doesn't exist, create a new RiskItem with this data.
     */
    create: XOR<RiskItemCreateInput, RiskItemUncheckedCreateInput>
    /**
     * In case the RiskItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RiskItemUpdateInput, RiskItemUncheckedUpdateInput>
  }

  /**
   * RiskItem delete
   */
  export type RiskItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskItem
     */
    select?: RiskItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskItem
     */
    omit?: RiskItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskItemInclude<ExtArgs> | null
    /**
     * Filter which RiskItem to delete.
     */
    where: RiskItemWhereUniqueInput
  }

  /**
   * RiskItem deleteMany
   */
  export type RiskItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RiskItems to delete
     */
    where?: RiskItemWhereInput
    /**
     * Limit how many RiskItems to delete.
     */
    limit?: number
  }

  /**
   * RiskItem without action
   */
  export type RiskItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskItem
     */
    select?: RiskItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskItem
     */
    omit?: RiskItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskItemInclude<ExtArgs> | null
  }


  /**
   * Model CipaMeeting
   */

  export type AggregateCipaMeeting = {
    _count: CipaMeetingCountAggregateOutputType | null
    _min: CipaMeetingMinAggregateOutputType | null
    _max: CipaMeetingMaxAggregateOutputType | null
  }

  export type CipaMeetingMinAggregateOutputType = {
    id: string | null
    date: Date | null
    participantsJson: string | null
    agenda: string | null
    status: string | null
    minutesUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CipaMeetingMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    participantsJson: string | null
    agenda: string | null
    status: string | null
    minutesUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CipaMeetingCountAggregateOutputType = {
    id: number
    date: number
    participantsJson: number
    agenda: number
    status: number
    minutesUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CipaMeetingMinAggregateInputType = {
    id?: true
    date?: true
    participantsJson?: true
    agenda?: true
    status?: true
    minutesUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CipaMeetingMaxAggregateInputType = {
    id?: true
    date?: true
    participantsJson?: true
    agenda?: true
    status?: true
    minutesUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CipaMeetingCountAggregateInputType = {
    id?: true
    date?: true
    participantsJson?: true
    agenda?: true
    status?: true
    minutesUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CipaMeetingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CipaMeeting to aggregate.
     */
    where?: CipaMeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CipaMeetings to fetch.
     */
    orderBy?: CipaMeetingOrderByWithRelationInput | CipaMeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CipaMeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CipaMeetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CipaMeetings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CipaMeetings
    **/
    _count?: true | CipaMeetingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CipaMeetingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CipaMeetingMaxAggregateInputType
  }

  export type GetCipaMeetingAggregateType<T extends CipaMeetingAggregateArgs> = {
        [P in keyof T & keyof AggregateCipaMeeting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCipaMeeting[P]>
      : GetScalarType<T[P], AggregateCipaMeeting[P]>
  }




  export type CipaMeetingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CipaMeetingWhereInput
    orderBy?: CipaMeetingOrderByWithAggregationInput | CipaMeetingOrderByWithAggregationInput[]
    by: CipaMeetingScalarFieldEnum[] | CipaMeetingScalarFieldEnum
    having?: CipaMeetingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CipaMeetingCountAggregateInputType | true
    _min?: CipaMeetingMinAggregateInputType
    _max?: CipaMeetingMaxAggregateInputType
  }

  export type CipaMeetingGroupByOutputType = {
    id: string
    date: Date
    participantsJson: string | null
    agenda: string
    status: string
    minutesUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: CipaMeetingCountAggregateOutputType | null
    _min: CipaMeetingMinAggregateOutputType | null
    _max: CipaMeetingMaxAggregateOutputType | null
  }

  type GetCipaMeetingGroupByPayload<T extends CipaMeetingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CipaMeetingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CipaMeetingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CipaMeetingGroupByOutputType[P]>
            : GetScalarType<T[P], CipaMeetingGroupByOutputType[P]>
        }
      >
    >


  export type CipaMeetingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    participantsJson?: boolean
    agenda?: boolean
    status?: boolean
    minutesUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    actionsDefined?: boolean | CipaMeeting$actionsDefinedArgs<ExtArgs>
    _count?: boolean | CipaMeetingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cipaMeeting"]>

  export type CipaMeetingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    participantsJson?: boolean
    agenda?: boolean
    status?: boolean
    minutesUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cipaMeeting"]>

  export type CipaMeetingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    participantsJson?: boolean
    agenda?: boolean
    status?: boolean
    minutesUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cipaMeeting"]>

  export type CipaMeetingSelectScalar = {
    id?: boolean
    date?: boolean
    participantsJson?: boolean
    agenda?: boolean
    status?: boolean
    minutesUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CipaMeetingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "participantsJson" | "agenda" | "status" | "minutesUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["cipaMeeting"]>
  export type CipaMeetingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actionsDefined?: boolean | CipaMeeting$actionsDefinedArgs<ExtArgs>
    _count?: boolean | CipaMeetingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CipaMeetingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CipaMeetingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CipaMeetingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CipaMeeting"
    objects: {
      actionsDefined: Prisma.$CipaActionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      participantsJson: string | null
      agenda: string
      status: string
      minutesUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cipaMeeting"]>
    composites: {}
  }

  type CipaMeetingGetPayload<S extends boolean | null | undefined | CipaMeetingDefaultArgs> = $Result.GetResult<Prisma.$CipaMeetingPayload, S>

  type CipaMeetingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CipaMeetingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CipaMeetingCountAggregateInputType | true
    }

  export interface CipaMeetingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CipaMeeting'], meta: { name: 'CipaMeeting' } }
    /**
     * Find zero or one CipaMeeting that matches the filter.
     * @param {CipaMeetingFindUniqueArgs} args - Arguments to find a CipaMeeting
     * @example
     * // Get one CipaMeeting
     * const cipaMeeting = await prisma.cipaMeeting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CipaMeetingFindUniqueArgs>(args: SelectSubset<T, CipaMeetingFindUniqueArgs<ExtArgs>>): Prisma__CipaMeetingClient<$Result.GetResult<Prisma.$CipaMeetingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CipaMeeting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CipaMeetingFindUniqueOrThrowArgs} args - Arguments to find a CipaMeeting
     * @example
     * // Get one CipaMeeting
     * const cipaMeeting = await prisma.cipaMeeting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CipaMeetingFindUniqueOrThrowArgs>(args: SelectSubset<T, CipaMeetingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CipaMeetingClient<$Result.GetResult<Prisma.$CipaMeetingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CipaMeeting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CipaMeetingFindFirstArgs} args - Arguments to find a CipaMeeting
     * @example
     * // Get one CipaMeeting
     * const cipaMeeting = await prisma.cipaMeeting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CipaMeetingFindFirstArgs>(args?: SelectSubset<T, CipaMeetingFindFirstArgs<ExtArgs>>): Prisma__CipaMeetingClient<$Result.GetResult<Prisma.$CipaMeetingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CipaMeeting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CipaMeetingFindFirstOrThrowArgs} args - Arguments to find a CipaMeeting
     * @example
     * // Get one CipaMeeting
     * const cipaMeeting = await prisma.cipaMeeting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CipaMeetingFindFirstOrThrowArgs>(args?: SelectSubset<T, CipaMeetingFindFirstOrThrowArgs<ExtArgs>>): Prisma__CipaMeetingClient<$Result.GetResult<Prisma.$CipaMeetingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CipaMeetings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CipaMeetingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CipaMeetings
     * const cipaMeetings = await prisma.cipaMeeting.findMany()
     * 
     * // Get first 10 CipaMeetings
     * const cipaMeetings = await prisma.cipaMeeting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cipaMeetingWithIdOnly = await prisma.cipaMeeting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CipaMeetingFindManyArgs>(args?: SelectSubset<T, CipaMeetingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CipaMeetingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CipaMeeting.
     * @param {CipaMeetingCreateArgs} args - Arguments to create a CipaMeeting.
     * @example
     * // Create one CipaMeeting
     * const CipaMeeting = await prisma.cipaMeeting.create({
     *   data: {
     *     // ... data to create a CipaMeeting
     *   }
     * })
     * 
     */
    create<T extends CipaMeetingCreateArgs>(args: SelectSubset<T, CipaMeetingCreateArgs<ExtArgs>>): Prisma__CipaMeetingClient<$Result.GetResult<Prisma.$CipaMeetingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CipaMeetings.
     * @param {CipaMeetingCreateManyArgs} args - Arguments to create many CipaMeetings.
     * @example
     * // Create many CipaMeetings
     * const cipaMeeting = await prisma.cipaMeeting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CipaMeetingCreateManyArgs>(args?: SelectSubset<T, CipaMeetingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CipaMeetings and returns the data saved in the database.
     * @param {CipaMeetingCreateManyAndReturnArgs} args - Arguments to create many CipaMeetings.
     * @example
     * // Create many CipaMeetings
     * const cipaMeeting = await prisma.cipaMeeting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CipaMeetings and only return the `id`
     * const cipaMeetingWithIdOnly = await prisma.cipaMeeting.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CipaMeetingCreateManyAndReturnArgs>(args?: SelectSubset<T, CipaMeetingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CipaMeetingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CipaMeeting.
     * @param {CipaMeetingDeleteArgs} args - Arguments to delete one CipaMeeting.
     * @example
     * // Delete one CipaMeeting
     * const CipaMeeting = await prisma.cipaMeeting.delete({
     *   where: {
     *     // ... filter to delete one CipaMeeting
     *   }
     * })
     * 
     */
    delete<T extends CipaMeetingDeleteArgs>(args: SelectSubset<T, CipaMeetingDeleteArgs<ExtArgs>>): Prisma__CipaMeetingClient<$Result.GetResult<Prisma.$CipaMeetingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CipaMeeting.
     * @param {CipaMeetingUpdateArgs} args - Arguments to update one CipaMeeting.
     * @example
     * // Update one CipaMeeting
     * const cipaMeeting = await prisma.cipaMeeting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CipaMeetingUpdateArgs>(args: SelectSubset<T, CipaMeetingUpdateArgs<ExtArgs>>): Prisma__CipaMeetingClient<$Result.GetResult<Prisma.$CipaMeetingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CipaMeetings.
     * @param {CipaMeetingDeleteManyArgs} args - Arguments to filter CipaMeetings to delete.
     * @example
     * // Delete a few CipaMeetings
     * const { count } = await prisma.cipaMeeting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CipaMeetingDeleteManyArgs>(args?: SelectSubset<T, CipaMeetingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CipaMeetings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CipaMeetingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CipaMeetings
     * const cipaMeeting = await prisma.cipaMeeting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CipaMeetingUpdateManyArgs>(args: SelectSubset<T, CipaMeetingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CipaMeetings and returns the data updated in the database.
     * @param {CipaMeetingUpdateManyAndReturnArgs} args - Arguments to update many CipaMeetings.
     * @example
     * // Update many CipaMeetings
     * const cipaMeeting = await prisma.cipaMeeting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CipaMeetings and only return the `id`
     * const cipaMeetingWithIdOnly = await prisma.cipaMeeting.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CipaMeetingUpdateManyAndReturnArgs>(args: SelectSubset<T, CipaMeetingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CipaMeetingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CipaMeeting.
     * @param {CipaMeetingUpsertArgs} args - Arguments to update or create a CipaMeeting.
     * @example
     * // Update or create a CipaMeeting
     * const cipaMeeting = await prisma.cipaMeeting.upsert({
     *   create: {
     *     // ... data to create a CipaMeeting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CipaMeeting we want to update
     *   }
     * })
     */
    upsert<T extends CipaMeetingUpsertArgs>(args: SelectSubset<T, CipaMeetingUpsertArgs<ExtArgs>>): Prisma__CipaMeetingClient<$Result.GetResult<Prisma.$CipaMeetingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CipaMeetings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CipaMeetingCountArgs} args - Arguments to filter CipaMeetings to count.
     * @example
     * // Count the number of CipaMeetings
     * const count = await prisma.cipaMeeting.count({
     *   where: {
     *     // ... the filter for the CipaMeetings we want to count
     *   }
     * })
    **/
    count<T extends CipaMeetingCountArgs>(
      args?: Subset<T, CipaMeetingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CipaMeetingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CipaMeeting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CipaMeetingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CipaMeetingAggregateArgs>(args: Subset<T, CipaMeetingAggregateArgs>): Prisma.PrismaPromise<GetCipaMeetingAggregateType<T>>

    /**
     * Group by CipaMeeting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CipaMeetingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CipaMeetingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CipaMeetingGroupByArgs['orderBy'] }
        : { orderBy?: CipaMeetingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CipaMeetingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCipaMeetingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CipaMeeting model
   */
  readonly fields: CipaMeetingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CipaMeeting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CipaMeetingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    actionsDefined<T extends CipaMeeting$actionsDefinedArgs<ExtArgs> = {}>(args?: Subset<T, CipaMeeting$actionsDefinedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CipaActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CipaMeeting model
   */
  interface CipaMeetingFieldRefs {
    readonly id: FieldRef<"CipaMeeting", 'String'>
    readonly date: FieldRef<"CipaMeeting", 'DateTime'>
    readonly participantsJson: FieldRef<"CipaMeeting", 'String'>
    readonly agenda: FieldRef<"CipaMeeting", 'String'>
    readonly status: FieldRef<"CipaMeeting", 'String'>
    readonly minutesUrl: FieldRef<"CipaMeeting", 'String'>
    readonly createdAt: FieldRef<"CipaMeeting", 'DateTime'>
    readonly updatedAt: FieldRef<"CipaMeeting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CipaMeeting findUnique
   */
  export type CipaMeetingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CipaMeeting
     */
    select?: CipaMeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CipaMeeting
     */
    omit?: CipaMeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CipaMeetingInclude<ExtArgs> | null
    /**
     * Filter, which CipaMeeting to fetch.
     */
    where: CipaMeetingWhereUniqueInput
  }

  /**
   * CipaMeeting findUniqueOrThrow
   */
  export type CipaMeetingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CipaMeeting
     */
    select?: CipaMeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CipaMeeting
     */
    omit?: CipaMeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CipaMeetingInclude<ExtArgs> | null
    /**
     * Filter, which CipaMeeting to fetch.
     */
    where: CipaMeetingWhereUniqueInput
  }

  /**
   * CipaMeeting findFirst
   */
  export type CipaMeetingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CipaMeeting
     */
    select?: CipaMeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CipaMeeting
     */
    omit?: CipaMeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CipaMeetingInclude<ExtArgs> | null
    /**
     * Filter, which CipaMeeting to fetch.
     */
    where?: CipaMeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CipaMeetings to fetch.
     */
    orderBy?: CipaMeetingOrderByWithRelationInput | CipaMeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CipaMeetings.
     */
    cursor?: CipaMeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CipaMeetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CipaMeetings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CipaMeetings.
     */
    distinct?: CipaMeetingScalarFieldEnum | CipaMeetingScalarFieldEnum[]
  }

  /**
   * CipaMeeting findFirstOrThrow
   */
  export type CipaMeetingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CipaMeeting
     */
    select?: CipaMeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CipaMeeting
     */
    omit?: CipaMeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CipaMeetingInclude<ExtArgs> | null
    /**
     * Filter, which CipaMeeting to fetch.
     */
    where?: CipaMeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CipaMeetings to fetch.
     */
    orderBy?: CipaMeetingOrderByWithRelationInput | CipaMeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CipaMeetings.
     */
    cursor?: CipaMeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CipaMeetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CipaMeetings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CipaMeetings.
     */
    distinct?: CipaMeetingScalarFieldEnum | CipaMeetingScalarFieldEnum[]
  }

  /**
   * CipaMeeting findMany
   */
  export type CipaMeetingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CipaMeeting
     */
    select?: CipaMeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CipaMeeting
     */
    omit?: CipaMeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CipaMeetingInclude<ExtArgs> | null
    /**
     * Filter, which CipaMeetings to fetch.
     */
    where?: CipaMeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CipaMeetings to fetch.
     */
    orderBy?: CipaMeetingOrderByWithRelationInput | CipaMeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CipaMeetings.
     */
    cursor?: CipaMeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CipaMeetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CipaMeetings.
     */
    skip?: number
    distinct?: CipaMeetingScalarFieldEnum | CipaMeetingScalarFieldEnum[]
  }

  /**
   * CipaMeeting create
   */
  export type CipaMeetingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CipaMeeting
     */
    select?: CipaMeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CipaMeeting
     */
    omit?: CipaMeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CipaMeetingInclude<ExtArgs> | null
    /**
     * The data needed to create a CipaMeeting.
     */
    data: XOR<CipaMeetingCreateInput, CipaMeetingUncheckedCreateInput>
  }

  /**
   * CipaMeeting createMany
   */
  export type CipaMeetingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CipaMeetings.
     */
    data: CipaMeetingCreateManyInput | CipaMeetingCreateManyInput[]
  }

  /**
   * CipaMeeting createManyAndReturn
   */
  export type CipaMeetingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CipaMeeting
     */
    select?: CipaMeetingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CipaMeeting
     */
    omit?: CipaMeetingOmit<ExtArgs> | null
    /**
     * The data used to create many CipaMeetings.
     */
    data: CipaMeetingCreateManyInput | CipaMeetingCreateManyInput[]
  }

  /**
   * CipaMeeting update
   */
  export type CipaMeetingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CipaMeeting
     */
    select?: CipaMeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CipaMeeting
     */
    omit?: CipaMeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CipaMeetingInclude<ExtArgs> | null
    /**
     * The data needed to update a CipaMeeting.
     */
    data: XOR<CipaMeetingUpdateInput, CipaMeetingUncheckedUpdateInput>
    /**
     * Choose, which CipaMeeting to update.
     */
    where: CipaMeetingWhereUniqueInput
  }

  /**
   * CipaMeeting updateMany
   */
  export type CipaMeetingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CipaMeetings.
     */
    data: XOR<CipaMeetingUpdateManyMutationInput, CipaMeetingUncheckedUpdateManyInput>
    /**
     * Filter which CipaMeetings to update
     */
    where?: CipaMeetingWhereInput
    /**
     * Limit how many CipaMeetings to update.
     */
    limit?: number
  }

  /**
   * CipaMeeting updateManyAndReturn
   */
  export type CipaMeetingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CipaMeeting
     */
    select?: CipaMeetingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CipaMeeting
     */
    omit?: CipaMeetingOmit<ExtArgs> | null
    /**
     * The data used to update CipaMeetings.
     */
    data: XOR<CipaMeetingUpdateManyMutationInput, CipaMeetingUncheckedUpdateManyInput>
    /**
     * Filter which CipaMeetings to update
     */
    where?: CipaMeetingWhereInput
    /**
     * Limit how many CipaMeetings to update.
     */
    limit?: number
  }

  /**
   * CipaMeeting upsert
   */
  export type CipaMeetingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CipaMeeting
     */
    select?: CipaMeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CipaMeeting
     */
    omit?: CipaMeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CipaMeetingInclude<ExtArgs> | null
    /**
     * The filter to search for the CipaMeeting to update in case it exists.
     */
    where: CipaMeetingWhereUniqueInput
    /**
     * In case the CipaMeeting found by the `where` argument doesn't exist, create a new CipaMeeting with this data.
     */
    create: XOR<CipaMeetingCreateInput, CipaMeetingUncheckedCreateInput>
    /**
     * In case the CipaMeeting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CipaMeetingUpdateInput, CipaMeetingUncheckedUpdateInput>
  }

  /**
   * CipaMeeting delete
   */
  export type CipaMeetingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CipaMeeting
     */
    select?: CipaMeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CipaMeeting
     */
    omit?: CipaMeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CipaMeetingInclude<ExtArgs> | null
    /**
     * Filter which CipaMeeting to delete.
     */
    where: CipaMeetingWhereUniqueInput
  }

  /**
   * CipaMeeting deleteMany
   */
  export type CipaMeetingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CipaMeetings to delete
     */
    where?: CipaMeetingWhereInput
    /**
     * Limit how many CipaMeetings to delete.
     */
    limit?: number
  }

  /**
   * CipaMeeting.actionsDefined
   */
  export type CipaMeeting$actionsDefinedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CipaAction
     */
    select?: CipaActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CipaAction
     */
    omit?: CipaActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CipaActionInclude<ExtArgs> | null
    where?: CipaActionWhereInput
    orderBy?: CipaActionOrderByWithRelationInput | CipaActionOrderByWithRelationInput[]
    cursor?: CipaActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CipaActionScalarFieldEnum | CipaActionScalarFieldEnum[]
  }

  /**
   * CipaMeeting without action
   */
  export type CipaMeetingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CipaMeeting
     */
    select?: CipaMeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CipaMeeting
     */
    omit?: CipaMeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CipaMeetingInclude<ExtArgs> | null
  }


  /**
   * Model CipaAction
   */

  export type AggregateCipaAction = {
    _count: CipaActionCountAggregateOutputType | null
    _min: CipaActionMinAggregateOutputType | null
    _max: CipaActionMaxAggregateOutputType | null
  }

  export type CipaActionMinAggregateOutputType = {
    id: string | null
    description: string | null
    responsible: string | null
    deadline: Date | null
    status: string | null
    meetingId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CipaActionMaxAggregateOutputType = {
    id: string | null
    description: string | null
    responsible: string | null
    deadline: Date | null
    status: string | null
    meetingId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CipaActionCountAggregateOutputType = {
    id: number
    description: number
    responsible: number
    deadline: number
    status: number
    meetingId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CipaActionMinAggregateInputType = {
    id?: true
    description?: true
    responsible?: true
    deadline?: true
    status?: true
    meetingId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CipaActionMaxAggregateInputType = {
    id?: true
    description?: true
    responsible?: true
    deadline?: true
    status?: true
    meetingId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CipaActionCountAggregateInputType = {
    id?: true
    description?: true
    responsible?: true
    deadline?: true
    status?: true
    meetingId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CipaActionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CipaAction to aggregate.
     */
    where?: CipaActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CipaActions to fetch.
     */
    orderBy?: CipaActionOrderByWithRelationInput | CipaActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CipaActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CipaActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CipaActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CipaActions
    **/
    _count?: true | CipaActionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CipaActionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CipaActionMaxAggregateInputType
  }

  export type GetCipaActionAggregateType<T extends CipaActionAggregateArgs> = {
        [P in keyof T & keyof AggregateCipaAction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCipaAction[P]>
      : GetScalarType<T[P], AggregateCipaAction[P]>
  }




  export type CipaActionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CipaActionWhereInput
    orderBy?: CipaActionOrderByWithAggregationInput | CipaActionOrderByWithAggregationInput[]
    by: CipaActionScalarFieldEnum[] | CipaActionScalarFieldEnum
    having?: CipaActionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CipaActionCountAggregateInputType | true
    _min?: CipaActionMinAggregateInputType
    _max?: CipaActionMaxAggregateInputType
  }

  export type CipaActionGroupByOutputType = {
    id: string
    description: string
    responsible: string
    deadline: Date | null
    status: string
    meetingId: string
    createdAt: Date
    updatedAt: Date
    _count: CipaActionCountAggregateOutputType | null
    _min: CipaActionMinAggregateOutputType | null
    _max: CipaActionMaxAggregateOutputType | null
  }

  type GetCipaActionGroupByPayload<T extends CipaActionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CipaActionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CipaActionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CipaActionGroupByOutputType[P]>
            : GetScalarType<T[P], CipaActionGroupByOutputType[P]>
        }
      >
    >


  export type CipaActionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    responsible?: boolean
    deadline?: boolean
    status?: boolean
    meetingId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    meeting?: boolean | CipaMeetingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cipaAction"]>

  export type CipaActionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    responsible?: boolean
    deadline?: boolean
    status?: boolean
    meetingId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    meeting?: boolean | CipaMeetingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cipaAction"]>

  export type CipaActionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    responsible?: boolean
    deadline?: boolean
    status?: boolean
    meetingId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    meeting?: boolean | CipaMeetingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cipaAction"]>

  export type CipaActionSelectScalar = {
    id?: boolean
    description?: boolean
    responsible?: boolean
    deadline?: boolean
    status?: boolean
    meetingId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CipaActionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "description" | "responsible" | "deadline" | "status" | "meetingId" | "createdAt" | "updatedAt", ExtArgs["result"]["cipaAction"]>
  export type CipaActionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meeting?: boolean | CipaMeetingDefaultArgs<ExtArgs>
  }
  export type CipaActionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meeting?: boolean | CipaMeetingDefaultArgs<ExtArgs>
  }
  export type CipaActionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meeting?: boolean | CipaMeetingDefaultArgs<ExtArgs>
  }

  export type $CipaActionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CipaAction"
    objects: {
      meeting: Prisma.$CipaMeetingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      description: string
      responsible: string
      deadline: Date | null
      status: string
      meetingId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cipaAction"]>
    composites: {}
  }

  type CipaActionGetPayload<S extends boolean | null | undefined | CipaActionDefaultArgs> = $Result.GetResult<Prisma.$CipaActionPayload, S>

  type CipaActionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CipaActionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CipaActionCountAggregateInputType | true
    }

  export interface CipaActionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CipaAction'], meta: { name: 'CipaAction' } }
    /**
     * Find zero or one CipaAction that matches the filter.
     * @param {CipaActionFindUniqueArgs} args - Arguments to find a CipaAction
     * @example
     * // Get one CipaAction
     * const cipaAction = await prisma.cipaAction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CipaActionFindUniqueArgs>(args: SelectSubset<T, CipaActionFindUniqueArgs<ExtArgs>>): Prisma__CipaActionClient<$Result.GetResult<Prisma.$CipaActionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CipaAction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CipaActionFindUniqueOrThrowArgs} args - Arguments to find a CipaAction
     * @example
     * // Get one CipaAction
     * const cipaAction = await prisma.cipaAction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CipaActionFindUniqueOrThrowArgs>(args: SelectSubset<T, CipaActionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CipaActionClient<$Result.GetResult<Prisma.$CipaActionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CipaAction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CipaActionFindFirstArgs} args - Arguments to find a CipaAction
     * @example
     * // Get one CipaAction
     * const cipaAction = await prisma.cipaAction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CipaActionFindFirstArgs>(args?: SelectSubset<T, CipaActionFindFirstArgs<ExtArgs>>): Prisma__CipaActionClient<$Result.GetResult<Prisma.$CipaActionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CipaAction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CipaActionFindFirstOrThrowArgs} args - Arguments to find a CipaAction
     * @example
     * // Get one CipaAction
     * const cipaAction = await prisma.cipaAction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CipaActionFindFirstOrThrowArgs>(args?: SelectSubset<T, CipaActionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CipaActionClient<$Result.GetResult<Prisma.$CipaActionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CipaActions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CipaActionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CipaActions
     * const cipaActions = await prisma.cipaAction.findMany()
     * 
     * // Get first 10 CipaActions
     * const cipaActions = await prisma.cipaAction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cipaActionWithIdOnly = await prisma.cipaAction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CipaActionFindManyArgs>(args?: SelectSubset<T, CipaActionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CipaActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CipaAction.
     * @param {CipaActionCreateArgs} args - Arguments to create a CipaAction.
     * @example
     * // Create one CipaAction
     * const CipaAction = await prisma.cipaAction.create({
     *   data: {
     *     // ... data to create a CipaAction
     *   }
     * })
     * 
     */
    create<T extends CipaActionCreateArgs>(args: SelectSubset<T, CipaActionCreateArgs<ExtArgs>>): Prisma__CipaActionClient<$Result.GetResult<Prisma.$CipaActionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CipaActions.
     * @param {CipaActionCreateManyArgs} args - Arguments to create many CipaActions.
     * @example
     * // Create many CipaActions
     * const cipaAction = await prisma.cipaAction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CipaActionCreateManyArgs>(args?: SelectSubset<T, CipaActionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CipaActions and returns the data saved in the database.
     * @param {CipaActionCreateManyAndReturnArgs} args - Arguments to create many CipaActions.
     * @example
     * // Create many CipaActions
     * const cipaAction = await prisma.cipaAction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CipaActions and only return the `id`
     * const cipaActionWithIdOnly = await prisma.cipaAction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CipaActionCreateManyAndReturnArgs>(args?: SelectSubset<T, CipaActionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CipaActionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CipaAction.
     * @param {CipaActionDeleteArgs} args - Arguments to delete one CipaAction.
     * @example
     * // Delete one CipaAction
     * const CipaAction = await prisma.cipaAction.delete({
     *   where: {
     *     // ... filter to delete one CipaAction
     *   }
     * })
     * 
     */
    delete<T extends CipaActionDeleteArgs>(args: SelectSubset<T, CipaActionDeleteArgs<ExtArgs>>): Prisma__CipaActionClient<$Result.GetResult<Prisma.$CipaActionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CipaAction.
     * @param {CipaActionUpdateArgs} args - Arguments to update one CipaAction.
     * @example
     * // Update one CipaAction
     * const cipaAction = await prisma.cipaAction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CipaActionUpdateArgs>(args: SelectSubset<T, CipaActionUpdateArgs<ExtArgs>>): Prisma__CipaActionClient<$Result.GetResult<Prisma.$CipaActionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CipaActions.
     * @param {CipaActionDeleteManyArgs} args - Arguments to filter CipaActions to delete.
     * @example
     * // Delete a few CipaActions
     * const { count } = await prisma.cipaAction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CipaActionDeleteManyArgs>(args?: SelectSubset<T, CipaActionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CipaActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CipaActionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CipaActions
     * const cipaAction = await prisma.cipaAction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CipaActionUpdateManyArgs>(args: SelectSubset<T, CipaActionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CipaActions and returns the data updated in the database.
     * @param {CipaActionUpdateManyAndReturnArgs} args - Arguments to update many CipaActions.
     * @example
     * // Update many CipaActions
     * const cipaAction = await prisma.cipaAction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CipaActions and only return the `id`
     * const cipaActionWithIdOnly = await prisma.cipaAction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CipaActionUpdateManyAndReturnArgs>(args: SelectSubset<T, CipaActionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CipaActionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CipaAction.
     * @param {CipaActionUpsertArgs} args - Arguments to update or create a CipaAction.
     * @example
     * // Update or create a CipaAction
     * const cipaAction = await prisma.cipaAction.upsert({
     *   create: {
     *     // ... data to create a CipaAction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CipaAction we want to update
     *   }
     * })
     */
    upsert<T extends CipaActionUpsertArgs>(args: SelectSubset<T, CipaActionUpsertArgs<ExtArgs>>): Prisma__CipaActionClient<$Result.GetResult<Prisma.$CipaActionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CipaActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CipaActionCountArgs} args - Arguments to filter CipaActions to count.
     * @example
     * // Count the number of CipaActions
     * const count = await prisma.cipaAction.count({
     *   where: {
     *     // ... the filter for the CipaActions we want to count
     *   }
     * })
    **/
    count<T extends CipaActionCountArgs>(
      args?: Subset<T, CipaActionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CipaActionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CipaAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CipaActionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CipaActionAggregateArgs>(args: Subset<T, CipaActionAggregateArgs>): Prisma.PrismaPromise<GetCipaActionAggregateType<T>>

    /**
     * Group by CipaAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CipaActionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CipaActionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CipaActionGroupByArgs['orderBy'] }
        : { orderBy?: CipaActionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CipaActionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCipaActionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CipaAction model
   */
  readonly fields: CipaActionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CipaAction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CipaActionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    meeting<T extends CipaMeetingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CipaMeetingDefaultArgs<ExtArgs>>): Prisma__CipaMeetingClient<$Result.GetResult<Prisma.$CipaMeetingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CipaAction model
   */
  interface CipaActionFieldRefs {
    readonly id: FieldRef<"CipaAction", 'String'>
    readonly description: FieldRef<"CipaAction", 'String'>
    readonly responsible: FieldRef<"CipaAction", 'String'>
    readonly deadline: FieldRef<"CipaAction", 'DateTime'>
    readonly status: FieldRef<"CipaAction", 'String'>
    readonly meetingId: FieldRef<"CipaAction", 'String'>
    readonly createdAt: FieldRef<"CipaAction", 'DateTime'>
    readonly updatedAt: FieldRef<"CipaAction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CipaAction findUnique
   */
  export type CipaActionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CipaAction
     */
    select?: CipaActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CipaAction
     */
    omit?: CipaActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CipaActionInclude<ExtArgs> | null
    /**
     * Filter, which CipaAction to fetch.
     */
    where: CipaActionWhereUniqueInput
  }

  /**
   * CipaAction findUniqueOrThrow
   */
  export type CipaActionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CipaAction
     */
    select?: CipaActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CipaAction
     */
    omit?: CipaActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CipaActionInclude<ExtArgs> | null
    /**
     * Filter, which CipaAction to fetch.
     */
    where: CipaActionWhereUniqueInput
  }

  /**
   * CipaAction findFirst
   */
  export type CipaActionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CipaAction
     */
    select?: CipaActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CipaAction
     */
    omit?: CipaActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CipaActionInclude<ExtArgs> | null
    /**
     * Filter, which CipaAction to fetch.
     */
    where?: CipaActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CipaActions to fetch.
     */
    orderBy?: CipaActionOrderByWithRelationInput | CipaActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CipaActions.
     */
    cursor?: CipaActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CipaActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CipaActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CipaActions.
     */
    distinct?: CipaActionScalarFieldEnum | CipaActionScalarFieldEnum[]
  }

  /**
   * CipaAction findFirstOrThrow
   */
  export type CipaActionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CipaAction
     */
    select?: CipaActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CipaAction
     */
    omit?: CipaActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CipaActionInclude<ExtArgs> | null
    /**
     * Filter, which CipaAction to fetch.
     */
    where?: CipaActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CipaActions to fetch.
     */
    orderBy?: CipaActionOrderByWithRelationInput | CipaActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CipaActions.
     */
    cursor?: CipaActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CipaActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CipaActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CipaActions.
     */
    distinct?: CipaActionScalarFieldEnum | CipaActionScalarFieldEnum[]
  }

  /**
   * CipaAction findMany
   */
  export type CipaActionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CipaAction
     */
    select?: CipaActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CipaAction
     */
    omit?: CipaActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CipaActionInclude<ExtArgs> | null
    /**
     * Filter, which CipaActions to fetch.
     */
    where?: CipaActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CipaActions to fetch.
     */
    orderBy?: CipaActionOrderByWithRelationInput | CipaActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CipaActions.
     */
    cursor?: CipaActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CipaActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CipaActions.
     */
    skip?: number
    distinct?: CipaActionScalarFieldEnum | CipaActionScalarFieldEnum[]
  }

  /**
   * CipaAction create
   */
  export type CipaActionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CipaAction
     */
    select?: CipaActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CipaAction
     */
    omit?: CipaActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CipaActionInclude<ExtArgs> | null
    /**
     * The data needed to create a CipaAction.
     */
    data: XOR<CipaActionCreateInput, CipaActionUncheckedCreateInput>
  }

  /**
   * CipaAction createMany
   */
  export type CipaActionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CipaActions.
     */
    data: CipaActionCreateManyInput | CipaActionCreateManyInput[]
  }

  /**
   * CipaAction createManyAndReturn
   */
  export type CipaActionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CipaAction
     */
    select?: CipaActionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CipaAction
     */
    omit?: CipaActionOmit<ExtArgs> | null
    /**
     * The data used to create many CipaActions.
     */
    data: CipaActionCreateManyInput | CipaActionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CipaActionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CipaAction update
   */
  export type CipaActionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CipaAction
     */
    select?: CipaActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CipaAction
     */
    omit?: CipaActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CipaActionInclude<ExtArgs> | null
    /**
     * The data needed to update a CipaAction.
     */
    data: XOR<CipaActionUpdateInput, CipaActionUncheckedUpdateInput>
    /**
     * Choose, which CipaAction to update.
     */
    where: CipaActionWhereUniqueInput
  }

  /**
   * CipaAction updateMany
   */
  export type CipaActionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CipaActions.
     */
    data: XOR<CipaActionUpdateManyMutationInput, CipaActionUncheckedUpdateManyInput>
    /**
     * Filter which CipaActions to update
     */
    where?: CipaActionWhereInput
    /**
     * Limit how many CipaActions to update.
     */
    limit?: number
  }

  /**
   * CipaAction updateManyAndReturn
   */
  export type CipaActionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CipaAction
     */
    select?: CipaActionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CipaAction
     */
    omit?: CipaActionOmit<ExtArgs> | null
    /**
     * The data used to update CipaActions.
     */
    data: XOR<CipaActionUpdateManyMutationInput, CipaActionUncheckedUpdateManyInput>
    /**
     * Filter which CipaActions to update
     */
    where?: CipaActionWhereInput
    /**
     * Limit how many CipaActions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CipaActionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CipaAction upsert
   */
  export type CipaActionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CipaAction
     */
    select?: CipaActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CipaAction
     */
    omit?: CipaActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CipaActionInclude<ExtArgs> | null
    /**
     * The filter to search for the CipaAction to update in case it exists.
     */
    where: CipaActionWhereUniqueInput
    /**
     * In case the CipaAction found by the `where` argument doesn't exist, create a new CipaAction with this data.
     */
    create: XOR<CipaActionCreateInput, CipaActionUncheckedCreateInput>
    /**
     * In case the CipaAction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CipaActionUpdateInput, CipaActionUncheckedUpdateInput>
  }

  /**
   * CipaAction delete
   */
  export type CipaActionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CipaAction
     */
    select?: CipaActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CipaAction
     */
    omit?: CipaActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CipaActionInclude<ExtArgs> | null
    /**
     * Filter which CipaAction to delete.
     */
    where: CipaActionWhereUniqueInput
  }

  /**
   * CipaAction deleteMany
   */
  export type CipaActionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CipaActions to delete
     */
    where?: CipaActionWhereInput
    /**
     * Limit how many CipaActions to delete.
     */
    limit?: number
  }

  /**
   * CipaAction without action
   */
  export type CipaActionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CipaAction
     */
    select?: CipaActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CipaAction
     */
    omit?: CipaActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CipaActionInclude<ExtArgs> | null
  }


  /**
   * Model PreventiveAction
   */

  export type AggregatePreventiveAction = {
    _count: PreventiveActionCountAggregateOutputType | null
    _min: PreventiveActionMinAggregateOutputType | null
    _max: PreventiveActionMaxAggregateOutputType | null
  }

  export type PreventiveActionMinAggregateOutputType = {
    id: string | null
    description: string | null
    category: string | null
    responsible: string | null
    frequency: string | null
    dueDate: Date | null
    lastCompletedDate: Date | null
    status: string | null
    evidenceUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PreventiveActionMaxAggregateOutputType = {
    id: string | null
    description: string | null
    category: string | null
    responsible: string | null
    frequency: string | null
    dueDate: Date | null
    lastCompletedDate: Date | null
    status: string | null
    evidenceUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PreventiveActionCountAggregateOutputType = {
    id: number
    description: number
    category: number
    responsible: number
    frequency: number
    dueDate: number
    lastCompletedDate: number
    status: number
    evidenceUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PreventiveActionMinAggregateInputType = {
    id?: true
    description?: true
    category?: true
    responsible?: true
    frequency?: true
    dueDate?: true
    lastCompletedDate?: true
    status?: true
    evidenceUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PreventiveActionMaxAggregateInputType = {
    id?: true
    description?: true
    category?: true
    responsible?: true
    frequency?: true
    dueDate?: true
    lastCompletedDate?: true
    status?: true
    evidenceUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PreventiveActionCountAggregateInputType = {
    id?: true
    description?: true
    category?: true
    responsible?: true
    frequency?: true
    dueDate?: true
    lastCompletedDate?: true
    status?: true
    evidenceUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PreventiveActionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PreventiveAction to aggregate.
     */
    where?: PreventiveActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PreventiveActions to fetch.
     */
    orderBy?: PreventiveActionOrderByWithRelationInput | PreventiveActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PreventiveActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PreventiveActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PreventiveActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PreventiveActions
    **/
    _count?: true | PreventiveActionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PreventiveActionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PreventiveActionMaxAggregateInputType
  }

  export type GetPreventiveActionAggregateType<T extends PreventiveActionAggregateArgs> = {
        [P in keyof T & keyof AggregatePreventiveAction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePreventiveAction[P]>
      : GetScalarType<T[P], AggregatePreventiveAction[P]>
  }




  export type PreventiveActionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PreventiveActionWhereInput
    orderBy?: PreventiveActionOrderByWithAggregationInput | PreventiveActionOrderByWithAggregationInput[]
    by: PreventiveActionScalarFieldEnum[] | PreventiveActionScalarFieldEnum
    having?: PreventiveActionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PreventiveActionCountAggregateInputType | true
    _min?: PreventiveActionMinAggregateInputType
    _max?: PreventiveActionMaxAggregateInputType
  }

  export type PreventiveActionGroupByOutputType = {
    id: string
    description: string
    category: string
    responsible: string
    frequency: string | null
    dueDate: Date | null
    lastCompletedDate: Date | null
    status: string
    evidenceUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: PreventiveActionCountAggregateOutputType | null
    _min: PreventiveActionMinAggregateOutputType | null
    _max: PreventiveActionMaxAggregateOutputType | null
  }

  type GetPreventiveActionGroupByPayload<T extends PreventiveActionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PreventiveActionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PreventiveActionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PreventiveActionGroupByOutputType[P]>
            : GetScalarType<T[P], PreventiveActionGroupByOutputType[P]>
        }
      >
    >


  export type PreventiveActionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    category?: boolean
    responsible?: boolean
    frequency?: boolean
    dueDate?: boolean
    lastCompletedDate?: boolean
    status?: boolean
    evidenceUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["preventiveAction"]>

  export type PreventiveActionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    category?: boolean
    responsible?: boolean
    frequency?: boolean
    dueDate?: boolean
    lastCompletedDate?: boolean
    status?: boolean
    evidenceUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["preventiveAction"]>

  export type PreventiveActionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    category?: boolean
    responsible?: boolean
    frequency?: boolean
    dueDate?: boolean
    lastCompletedDate?: boolean
    status?: boolean
    evidenceUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["preventiveAction"]>

  export type PreventiveActionSelectScalar = {
    id?: boolean
    description?: boolean
    category?: boolean
    responsible?: boolean
    frequency?: boolean
    dueDate?: boolean
    lastCompletedDate?: boolean
    status?: boolean
    evidenceUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PreventiveActionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "description" | "category" | "responsible" | "frequency" | "dueDate" | "lastCompletedDate" | "status" | "evidenceUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["preventiveAction"]>

  export type $PreventiveActionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PreventiveAction"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      description: string
      category: string
      responsible: string
      frequency: string | null
      dueDate: Date | null
      lastCompletedDate: Date | null
      status: string
      evidenceUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["preventiveAction"]>
    composites: {}
  }

  type PreventiveActionGetPayload<S extends boolean | null | undefined | PreventiveActionDefaultArgs> = $Result.GetResult<Prisma.$PreventiveActionPayload, S>

  type PreventiveActionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PreventiveActionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PreventiveActionCountAggregateInputType | true
    }

  export interface PreventiveActionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PreventiveAction'], meta: { name: 'PreventiveAction' } }
    /**
     * Find zero or one PreventiveAction that matches the filter.
     * @param {PreventiveActionFindUniqueArgs} args - Arguments to find a PreventiveAction
     * @example
     * // Get one PreventiveAction
     * const preventiveAction = await prisma.preventiveAction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PreventiveActionFindUniqueArgs>(args: SelectSubset<T, PreventiveActionFindUniqueArgs<ExtArgs>>): Prisma__PreventiveActionClient<$Result.GetResult<Prisma.$PreventiveActionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PreventiveAction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PreventiveActionFindUniqueOrThrowArgs} args - Arguments to find a PreventiveAction
     * @example
     * // Get one PreventiveAction
     * const preventiveAction = await prisma.preventiveAction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PreventiveActionFindUniqueOrThrowArgs>(args: SelectSubset<T, PreventiveActionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PreventiveActionClient<$Result.GetResult<Prisma.$PreventiveActionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PreventiveAction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreventiveActionFindFirstArgs} args - Arguments to find a PreventiveAction
     * @example
     * // Get one PreventiveAction
     * const preventiveAction = await prisma.preventiveAction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PreventiveActionFindFirstArgs>(args?: SelectSubset<T, PreventiveActionFindFirstArgs<ExtArgs>>): Prisma__PreventiveActionClient<$Result.GetResult<Prisma.$PreventiveActionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PreventiveAction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreventiveActionFindFirstOrThrowArgs} args - Arguments to find a PreventiveAction
     * @example
     * // Get one PreventiveAction
     * const preventiveAction = await prisma.preventiveAction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PreventiveActionFindFirstOrThrowArgs>(args?: SelectSubset<T, PreventiveActionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PreventiveActionClient<$Result.GetResult<Prisma.$PreventiveActionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PreventiveActions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreventiveActionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PreventiveActions
     * const preventiveActions = await prisma.preventiveAction.findMany()
     * 
     * // Get first 10 PreventiveActions
     * const preventiveActions = await prisma.preventiveAction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const preventiveActionWithIdOnly = await prisma.preventiveAction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PreventiveActionFindManyArgs>(args?: SelectSubset<T, PreventiveActionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreventiveActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PreventiveAction.
     * @param {PreventiveActionCreateArgs} args - Arguments to create a PreventiveAction.
     * @example
     * // Create one PreventiveAction
     * const PreventiveAction = await prisma.preventiveAction.create({
     *   data: {
     *     // ... data to create a PreventiveAction
     *   }
     * })
     * 
     */
    create<T extends PreventiveActionCreateArgs>(args: SelectSubset<T, PreventiveActionCreateArgs<ExtArgs>>): Prisma__PreventiveActionClient<$Result.GetResult<Prisma.$PreventiveActionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PreventiveActions.
     * @param {PreventiveActionCreateManyArgs} args - Arguments to create many PreventiveActions.
     * @example
     * // Create many PreventiveActions
     * const preventiveAction = await prisma.preventiveAction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PreventiveActionCreateManyArgs>(args?: SelectSubset<T, PreventiveActionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PreventiveActions and returns the data saved in the database.
     * @param {PreventiveActionCreateManyAndReturnArgs} args - Arguments to create many PreventiveActions.
     * @example
     * // Create many PreventiveActions
     * const preventiveAction = await prisma.preventiveAction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PreventiveActions and only return the `id`
     * const preventiveActionWithIdOnly = await prisma.preventiveAction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PreventiveActionCreateManyAndReturnArgs>(args?: SelectSubset<T, PreventiveActionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreventiveActionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PreventiveAction.
     * @param {PreventiveActionDeleteArgs} args - Arguments to delete one PreventiveAction.
     * @example
     * // Delete one PreventiveAction
     * const PreventiveAction = await prisma.preventiveAction.delete({
     *   where: {
     *     // ... filter to delete one PreventiveAction
     *   }
     * })
     * 
     */
    delete<T extends PreventiveActionDeleteArgs>(args: SelectSubset<T, PreventiveActionDeleteArgs<ExtArgs>>): Prisma__PreventiveActionClient<$Result.GetResult<Prisma.$PreventiveActionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PreventiveAction.
     * @param {PreventiveActionUpdateArgs} args - Arguments to update one PreventiveAction.
     * @example
     * // Update one PreventiveAction
     * const preventiveAction = await prisma.preventiveAction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PreventiveActionUpdateArgs>(args: SelectSubset<T, PreventiveActionUpdateArgs<ExtArgs>>): Prisma__PreventiveActionClient<$Result.GetResult<Prisma.$PreventiveActionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PreventiveActions.
     * @param {PreventiveActionDeleteManyArgs} args - Arguments to filter PreventiveActions to delete.
     * @example
     * // Delete a few PreventiveActions
     * const { count } = await prisma.preventiveAction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PreventiveActionDeleteManyArgs>(args?: SelectSubset<T, PreventiveActionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PreventiveActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreventiveActionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PreventiveActions
     * const preventiveAction = await prisma.preventiveAction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PreventiveActionUpdateManyArgs>(args: SelectSubset<T, PreventiveActionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PreventiveActions and returns the data updated in the database.
     * @param {PreventiveActionUpdateManyAndReturnArgs} args - Arguments to update many PreventiveActions.
     * @example
     * // Update many PreventiveActions
     * const preventiveAction = await prisma.preventiveAction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PreventiveActions and only return the `id`
     * const preventiveActionWithIdOnly = await prisma.preventiveAction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PreventiveActionUpdateManyAndReturnArgs>(args: SelectSubset<T, PreventiveActionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreventiveActionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PreventiveAction.
     * @param {PreventiveActionUpsertArgs} args - Arguments to update or create a PreventiveAction.
     * @example
     * // Update or create a PreventiveAction
     * const preventiveAction = await prisma.preventiveAction.upsert({
     *   create: {
     *     // ... data to create a PreventiveAction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PreventiveAction we want to update
     *   }
     * })
     */
    upsert<T extends PreventiveActionUpsertArgs>(args: SelectSubset<T, PreventiveActionUpsertArgs<ExtArgs>>): Prisma__PreventiveActionClient<$Result.GetResult<Prisma.$PreventiveActionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PreventiveActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreventiveActionCountArgs} args - Arguments to filter PreventiveActions to count.
     * @example
     * // Count the number of PreventiveActions
     * const count = await prisma.preventiveAction.count({
     *   where: {
     *     // ... the filter for the PreventiveActions we want to count
     *   }
     * })
    **/
    count<T extends PreventiveActionCountArgs>(
      args?: Subset<T, PreventiveActionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PreventiveActionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PreventiveAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreventiveActionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PreventiveActionAggregateArgs>(args: Subset<T, PreventiveActionAggregateArgs>): Prisma.PrismaPromise<GetPreventiveActionAggregateType<T>>

    /**
     * Group by PreventiveAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreventiveActionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PreventiveActionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PreventiveActionGroupByArgs['orderBy'] }
        : { orderBy?: PreventiveActionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PreventiveActionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPreventiveActionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PreventiveAction model
   */
  readonly fields: PreventiveActionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PreventiveAction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PreventiveActionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PreventiveAction model
   */
  interface PreventiveActionFieldRefs {
    readonly id: FieldRef<"PreventiveAction", 'String'>
    readonly description: FieldRef<"PreventiveAction", 'String'>
    readonly category: FieldRef<"PreventiveAction", 'String'>
    readonly responsible: FieldRef<"PreventiveAction", 'String'>
    readonly frequency: FieldRef<"PreventiveAction", 'String'>
    readonly dueDate: FieldRef<"PreventiveAction", 'DateTime'>
    readonly lastCompletedDate: FieldRef<"PreventiveAction", 'DateTime'>
    readonly status: FieldRef<"PreventiveAction", 'String'>
    readonly evidenceUrl: FieldRef<"PreventiveAction", 'String'>
    readonly createdAt: FieldRef<"PreventiveAction", 'DateTime'>
    readonly updatedAt: FieldRef<"PreventiveAction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PreventiveAction findUnique
   */
  export type PreventiveActionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreventiveAction
     */
    select?: PreventiveActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreventiveAction
     */
    omit?: PreventiveActionOmit<ExtArgs> | null
    /**
     * Filter, which PreventiveAction to fetch.
     */
    where: PreventiveActionWhereUniqueInput
  }

  /**
   * PreventiveAction findUniqueOrThrow
   */
  export type PreventiveActionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreventiveAction
     */
    select?: PreventiveActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreventiveAction
     */
    omit?: PreventiveActionOmit<ExtArgs> | null
    /**
     * Filter, which PreventiveAction to fetch.
     */
    where: PreventiveActionWhereUniqueInput
  }

  /**
   * PreventiveAction findFirst
   */
  export type PreventiveActionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreventiveAction
     */
    select?: PreventiveActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreventiveAction
     */
    omit?: PreventiveActionOmit<ExtArgs> | null
    /**
     * Filter, which PreventiveAction to fetch.
     */
    where?: PreventiveActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PreventiveActions to fetch.
     */
    orderBy?: PreventiveActionOrderByWithRelationInput | PreventiveActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PreventiveActions.
     */
    cursor?: PreventiveActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PreventiveActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PreventiveActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PreventiveActions.
     */
    distinct?: PreventiveActionScalarFieldEnum | PreventiveActionScalarFieldEnum[]
  }

  /**
   * PreventiveAction findFirstOrThrow
   */
  export type PreventiveActionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreventiveAction
     */
    select?: PreventiveActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreventiveAction
     */
    omit?: PreventiveActionOmit<ExtArgs> | null
    /**
     * Filter, which PreventiveAction to fetch.
     */
    where?: PreventiveActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PreventiveActions to fetch.
     */
    orderBy?: PreventiveActionOrderByWithRelationInput | PreventiveActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PreventiveActions.
     */
    cursor?: PreventiveActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PreventiveActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PreventiveActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PreventiveActions.
     */
    distinct?: PreventiveActionScalarFieldEnum | PreventiveActionScalarFieldEnum[]
  }

  /**
   * PreventiveAction findMany
   */
  export type PreventiveActionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreventiveAction
     */
    select?: PreventiveActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreventiveAction
     */
    omit?: PreventiveActionOmit<ExtArgs> | null
    /**
     * Filter, which PreventiveActions to fetch.
     */
    where?: PreventiveActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PreventiveActions to fetch.
     */
    orderBy?: PreventiveActionOrderByWithRelationInput | PreventiveActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PreventiveActions.
     */
    cursor?: PreventiveActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PreventiveActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PreventiveActions.
     */
    skip?: number
    distinct?: PreventiveActionScalarFieldEnum | PreventiveActionScalarFieldEnum[]
  }

  /**
   * PreventiveAction create
   */
  export type PreventiveActionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreventiveAction
     */
    select?: PreventiveActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreventiveAction
     */
    omit?: PreventiveActionOmit<ExtArgs> | null
    /**
     * The data needed to create a PreventiveAction.
     */
    data: XOR<PreventiveActionCreateInput, PreventiveActionUncheckedCreateInput>
  }

  /**
   * PreventiveAction createMany
   */
  export type PreventiveActionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PreventiveActions.
     */
    data: PreventiveActionCreateManyInput | PreventiveActionCreateManyInput[]
  }

  /**
   * PreventiveAction createManyAndReturn
   */
  export type PreventiveActionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreventiveAction
     */
    select?: PreventiveActionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PreventiveAction
     */
    omit?: PreventiveActionOmit<ExtArgs> | null
    /**
     * The data used to create many PreventiveActions.
     */
    data: PreventiveActionCreateManyInput | PreventiveActionCreateManyInput[]
  }

  /**
   * PreventiveAction update
   */
  export type PreventiveActionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreventiveAction
     */
    select?: PreventiveActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreventiveAction
     */
    omit?: PreventiveActionOmit<ExtArgs> | null
    /**
     * The data needed to update a PreventiveAction.
     */
    data: XOR<PreventiveActionUpdateInput, PreventiveActionUncheckedUpdateInput>
    /**
     * Choose, which PreventiveAction to update.
     */
    where: PreventiveActionWhereUniqueInput
  }

  /**
   * PreventiveAction updateMany
   */
  export type PreventiveActionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PreventiveActions.
     */
    data: XOR<PreventiveActionUpdateManyMutationInput, PreventiveActionUncheckedUpdateManyInput>
    /**
     * Filter which PreventiveActions to update
     */
    where?: PreventiveActionWhereInput
    /**
     * Limit how many PreventiveActions to update.
     */
    limit?: number
  }

  /**
   * PreventiveAction updateManyAndReturn
   */
  export type PreventiveActionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreventiveAction
     */
    select?: PreventiveActionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PreventiveAction
     */
    omit?: PreventiveActionOmit<ExtArgs> | null
    /**
     * The data used to update PreventiveActions.
     */
    data: XOR<PreventiveActionUpdateManyMutationInput, PreventiveActionUncheckedUpdateManyInput>
    /**
     * Filter which PreventiveActions to update
     */
    where?: PreventiveActionWhereInput
    /**
     * Limit how many PreventiveActions to update.
     */
    limit?: number
  }

  /**
   * PreventiveAction upsert
   */
  export type PreventiveActionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreventiveAction
     */
    select?: PreventiveActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreventiveAction
     */
    omit?: PreventiveActionOmit<ExtArgs> | null
    /**
     * The filter to search for the PreventiveAction to update in case it exists.
     */
    where: PreventiveActionWhereUniqueInput
    /**
     * In case the PreventiveAction found by the `where` argument doesn't exist, create a new PreventiveAction with this data.
     */
    create: XOR<PreventiveActionCreateInput, PreventiveActionUncheckedCreateInput>
    /**
     * In case the PreventiveAction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PreventiveActionUpdateInput, PreventiveActionUncheckedUpdateInput>
  }

  /**
   * PreventiveAction delete
   */
  export type PreventiveActionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreventiveAction
     */
    select?: PreventiveActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreventiveAction
     */
    omit?: PreventiveActionOmit<ExtArgs> | null
    /**
     * Filter which PreventiveAction to delete.
     */
    where: PreventiveActionWhereUniqueInput
  }

  /**
   * PreventiveAction deleteMany
   */
  export type PreventiveActionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PreventiveActions to delete
     */
    where?: PreventiveActionWhereInput
    /**
     * Limit how many PreventiveActions to delete.
     */
    limit?: number
  }

  /**
   * PreventiveAction without action
   */
  export type PreventiveActionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreventiveAction
     */
    select?: PreventiveActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreventiveAction
     */
    omit?: PreventiveActionOmit<ExtArgs> | null
  }


  /**
   * Model DocumentRecord
   */

  export type AggregateDocumentRecord = {
    _count: DocumentRecordCountAggregateOutputType | null
    _min: DocumentRecordMinAggregateOutputType | null
    _max: DocumentRecordMaxAggregateOutputType | null
  }

  export type DocumentRecordMinAggregateOutputType = {
    id: string | null
    documentType: string | null
    title: string | null
    issueDate: Date | null
    expiryDate: Date | null
    responsible: string | null
    status: string | null
    attachmentUrl: string | null
    observations: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentRecordMaxAggregateOutputType = {
    id: string | null
    documentType: string | null
    title: string | null
    issueDate: Date | null
    expiryDate: Date | null
    responsible: string | null
    status: string | null
    attachmentUrl: string | null
    observations: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentRecordCountAggregateOutputType = {
    id: number
    documentType: number
    title: number
    issueDate: number
    expiryDate: number
    responsible: number
    status: number
    attachmentUrl: number
    observations: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DocumentRecordMinAggregateInputType = {
    id?: true
    documentType?: true
    title?: true
    issueDate?: true
    expiryDate?: true
    responsible?: true
    status?: true
    attachmentUrl?: true
    observations?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentRecordMaxAggregateInputType = {
    id?: true
    documentType?: true
    title?: true
    issueDate?: true
    expiryDate?: true
    responsible?: true
    status?: true
    attachmentUrl?: true
    observations?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentRecordCountAggregateInputType = {
    id?: true
    documentType?: true
    title?: true
    issueDate?: true
    expiryDate?: true
    responsible?: true
    status?: true
    attachmentUrl?: true
    observations?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DocumentRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentRecord to aggregate.
     */
    where?: DocumentRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentRecords to fetch.
     */
    orderBy?: DocumentRecordOrderByWithRelationInput | DocumentRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DocumentRecords
    **/
    _count?: true | DocumentRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentRecordMaxAggregateInputType
  }

  export type GetDocumentRecordAggregateType<T extends DocumentRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentRecord[P]>
      : GetScalarType<T[P], AggregateDocumentRecord[P]>
  }




  export type DocumentRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentRecordWhereInput
    orderBy?: DocumentRecordOrderByWithAggregationInput | DocumentRecordOrderByWithAggregationInput[]
    by: DocumentRecordScalarFieldEnum[] | DocumentRecordScalarFieldEnum
    having?: DocumentRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentRecordCountAggregateInputType | true
    _min?: DocumentRecordMinAggregateInputType
    _max?: DocumentRecordMaxAggregateInputType
  }

  export type DocumentRecordGroupByOutputType = {
    id: string
    documentType: string
    title: string
    issueDate: Date
    expiryDate: Date
    responsible: string
    status: string
    attachmentUrl: string | null
    observations: string | null
    createdAt: Date
    updatedAt: Date
    _count: DocumentRecordCountAggregateOutputType | null
    _min: DocumentRecordMinAggregateOutputType | null
    _max: DocumentRecordMaxAggregateOutputType | null
  }

  type GetDocumentRecordGroupByPayload<T extends DocumentRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentRecordGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentRecordGroupByOutputType[P]>
        }
      >
    >


  export type DocumentRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentType?: boolean
    title?: boolean
    issueDate?: boolean
    expiryDate?: boolean
    responsible?: boolean
    status?: boolean
    attachmentUrl?: boolean
    observations?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    relatedActions?: boolean | DocumentRecord$relatedActionsArgs<ExtArgs>
    _count?: boolean | DocumentRecordCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentRecord"]>

  export type DocumentRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentType?: boolean
    title?: boolean
    issueDate?: boolean
    expiryDate?: boolean
    responsible?: boolean
    status?: boolean
    attachmentUrl?: boolean
    observations?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["documentRecord"]>

  export type DocumentRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentType?: boolean
    title?: boolean
    issueDate?: boolean
    expiryDate?: boolean
    responsible?: boolean
    status?: boolean
    attachmentUrl?: boolean
    observations?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["documentRecord"]>

  export type DocumentRecordSelectScalar = {
    id?: boolean
    documentType?: boolean
    title?: boolean
    issueDate?: boolean
    expiryDate?: boolean
    responsible?: boolean
    status?: boolean
    attachmentUrl?: boolean
    observations?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DocumentRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "documentType" | "title" | "issueDate" | "expiryDate" | "responsible" | "status" | "attachmentUrl" | "observations" | "createdAt" | "updatedAt", ExtArgs["result"]["documentRecord"]>
  export type DocumentRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    relatedActions?: boolean | DocumentRecord$relatedActionsArgs<ExtArgs>
    _count?: boolean | DocumentRecordCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DocumentRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DocumentRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DocumentRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DocumentRecord"
    objects: {
      relatedActions: Prisma.$DocumentActionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      documentType: string
      title: string
      issueDate: Date
      expiryDate: Date
      responsible: string
      status: string
      attachmentUrl: string | null
      observations: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["documentRecord"]>
    composites: {}
  }

  type DocumentRecordGetPayload<S extends boolean | null | undefined | DocumentRecordDefaultArgs> = $Result.GetResult<Prisma.$DocumentRecordPayload, S>

  type DocumentRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentRecordCountAggregateInputType | true
    }

  export interface DocumentRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DocumentRecord'], meta: { name: 'DocumentRecord' } }
    /**
     * Find zero or one DocumentRecord that matches the filter.
     * @param {DocumentRecordFindUniqueArgs} args - Arguments to find a DocumentRecord
     * @example
     * // Get one DocumentRecord
     * const documentRecord = await prisma.documentRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentRecordFindUniqueArgs>(args: SelectSubset<T, DocumentRecordFindUniqueArgs<ExtArgs>>): Prisma__DocumentRecordClient<$Result.GetResult<Prisma.$DocumentRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DocumentRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentRecordFindUniqueOrThrowArgs} args - Arguments to find a DocumentRecord
     * @example
     * // Get one DocumentRecord
     * const documentRecord = await prisma.documentRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentRecordClient<$Result.GetResult<Prisma.$DocumentRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentRecordFindFirstArgs} args - Arguments to find a DocumentRecord
     * @example
     * // Get one DocumentRecord
     * const documentRecord = await prisma.documentRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentRecordFindFirstArgs>(args?: SelectSubset<T, DocumentRecordFindFirstArgs<ExtArgs>>): Prisma__DocumentRecordClient<$Result.GetResult<Prisma.$DocumentRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentRecordFindFirstOrThrowArgs} args - Arguments to find a DocumentRecord
     * @example
     * // Get one DocumentRecord
     * const documentRecord = await prisma.documentRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentRecordClient<$Result.GetResult<Prisma.$DocumentRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DocumentRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DocumentRecords
     * const documentRecords = await prisma.documentRecord.findMany()
     * 
     * // Get first 10 DocumentRecords
     * const documentRecords = await prisma.documentRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentRecordWithIdOnly = await prisma.documentRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentRecordFindManyArgs>(args?: SelectSubset<T, DocumentRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DocumentRecord.
     * @param {DocumentRecordCreateArgs} args - Arguments to create a DocumentRecord.
     * @example
     * // Create one DocumentRecord
     * const DocumentRecord = await prisma.documentRecord.create({
     *   data: {
     *     // ... data to create a DocumentRecord
     *   }
     * })
     * 
     */
    create<T extends DocumentRecordCreateArgs>(args: SelectSubset<T, DocumentRecordCreateArgs<ExtArgs>>): Prisma__DocumentRecordClient<$Result.GetResult<Prisma.$DocumentRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DocumentRecords.
     * @param {DocumentRecordCreateManyArgs} args - Arguments to create many DocumentRecords.
     * @example
     * // Create many DocumentRecords
     * const documentRecord = await prisma.documentRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentRecordCreateManyArgs>(args?: SelectSubset<T, DocumentRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DocumentRecords and returns the data saved in the database.
     * @param {DocumentRecordCreateManyAndReturnArgs} args - Arguments to create many DocumentRecords.
     * @example
     * // Create many DocumentRecords
     * const documentRecord = await prisma.documentRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DocumentRecords and only return the `id`
     * const documentRecordWithIdOnly = await prisma.documentRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DocumentRecord.
     * @param {DocumentRecordDeleteArgs} args - Arguments to delete one DocumentRecord.
     * @example
     * // Delete one DocumentRecord
     * const DocumentRecord = await prisma.documentRecord.delete({
     *   where: {
     *     // ... filter to delete one DocumentRecord
     *   }
     * })
     * 
     */
    delete<T extends DocumentRecordDeleteArgs>(args: SelectSubset<T, DocumentRecordDeleteArgs<ExtArgs>>): Prisma__DocumentRecordClient<$Result.GetResult<Prisma.$DocumentRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DocumentRecord.
     * @param {DocumentRecordUpdateArgs} args - Arguments to update one DocumentRecord.
     * @example
     * // Update one DocumentRecord
     * const documentRecord = await prisma.documentRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentRecordUpdateArgs>(args: SelectSubset<T, DocumentRecordUpdateArgs<ExtArgs>>): Prisma__DocumentRecordClient<$Result.GetResult<Prisma.$DocumentRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DocumentRecords.
     * @param {DocumentRecordDeleteManyArgs} args - Arguments to filter DocumentRecords to delete.
     * @example
     * // Delete a few DocumentRecords
     * const { count } = await prisma.documentRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentRecordDeleteManyArgs>(args?: SelectSubset<T, DocumentRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DocumentRecords
     * const documentRecord = await prisma.documentRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentRecordUpdateManyArgs>(args: SelectSubset<T, DocumentRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentRecords and returns the data updated in the database.
     * @param {DocumentRecordUpdateManyAndReturnArgs} args - Arguments to update many DocumentRecords.
     * @example
     * // Update many DocumentRecords
     * const documentRecord = await prisma.documentRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DocumentRecords and only return the `id`
     * const documentRecordWithIdOnly = await prisma.documentRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DocumentRecord.
     * @param {DocumentRecordUpsertArgs} args - Arguments to update or create a DocumentRecord.
     * @example
     * // Update or create a DocumentRecord
     * const documentRecord = await prisma.documentRecord.upsert({
     *   create: {
     *     // ... data to create a DocumentRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DocumentRecord we want to update
     *   }
     * })
     */
    upsert<T extends DocumentRecordUpsertArgs>(args: SelectSubset<T, DocumentRecordUpsertArgs<ExtArgs>>): Prisma__DocumentRecordClient<$Result.GetResult<Prisma.$DocumentRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DocumentRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentRecordCountArgs} args - Arguments to filter DocumentRecords to count.
     * @example
     * // Count the number of DocumentRecords
     * const count = await prisma.documentRecord.count({
     *   where: {
     *     // ... the filter for the DocumentRecords we want to count
     *   }
     * })
    **/
    count<T extends DocumentRecordCountArgs>(
      args?: Subset<T, DocumentRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DocumentRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentRecordAggregateArgs>(args: Subset<T, DocumentRecordAggregateArgs>): Prisma.PrismaPromise<GetDocumentRecordAggregateType<T>>

    /**
     * Group by DocumentRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentRecordGroupByArgs['orderBy'] }
        : { orderBy?: DocumentRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DocumentRecord model
   */
  readonly fields: DocumentRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DocumentRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    relatedActions<T extends DocumentRecord$relatedActionsArgs<ExtArgs> = {}>(args?: Subset<T, DocumentRecord$relatedActionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DocumentRecord model
   */
  interface DocumentRecordFieldRefs {
    readonly id: FieldRef<"DocumentRecord", 'String'>
    readonly documentType: FieldRef<"DocumentRecord", 'String'>
    readonly title: FieldRef<"DocumentRecord", 'String'>
    readonly issueDate: FieldRef<"DocumentRecord", 'DateTime'>
    readonly expiryDate: FieldRef<"DocumentRecord", 'DateTime'>
    readonly responsible: FieldRef<"DocumentRecord", 'String'>
    readonly status: FieldRef<"DocumentRecord", 'String'>
    readonly attachmentUrl: FieldRef<"DocumentRecord", 'String'>
    readonly observations: FieldRef<"DocumentRecord", 'String'>
    readonly createdAt: FieldRef<"DocumentRecord", 'DateTime'>
    readonly updatedAt: FieldRef<"DocumentRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DocumentRecord findUnique
   */
  export type DocumentRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRecord
     */
    select?: DocumentRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentRecord
     */
    omit?: DocumentRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentRecordInclude<ExtArgs> | null
    /**
     * Filter, which DocumentRecord to fetch.
     */
    where: DocumentRecordWhereUniqueInput
  }

  /**
   * DocumentRecord findUniqueOrThrow
   */
  export type DocumentRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRecord
     */
    select?: DocumentRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentRecord
     */
    omit?: DocumentRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentRecordInclude<ExtArgs> | null
    /**
     * Filter, which DocumentRecord to fetch.
     */
    where: DocumentRecordWhereUniqueInput
  }

  /**
   * DocumentRecord findFirst
   */
  export type DocumentRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRecord
     */
    select?: DocumentRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentRecord
     */
    omit?: DocumentRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentRecordInclude<ExtArgs> | null
    /**
     * Filter, which DocumentRecord to fetch.
     */
    where?: DocumentRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentRecords to fetch.
     */
    orderBy?: DocumentRecordOrderByWithRelationInput | DocumentRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentRecords.
     */
    cursor?: DocumentRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentRecords.
     */
    distinct?: DocumentRecordScalarFieldEnum | DocumentRecordScalarFieldEnum[]
  }

  /**
   * DocumentRecord findFirstOrThrow
   */
  export type DocumentRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRecord
     */
    select?: DocumentRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentRecord
     */
    omit?: DocumentRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentRecordInclude<ExtArgs> | null
    /**
     * Filter, which DocumentRecord to fetch.
     */
    where?: DocumentRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentRecords to fetch.
     */
    orderBy?: DocumentRecordOrderByWithRelationInput | DocumentRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentRecords.
     */
    cursor?: DocumentRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentRecords.
     */
    distinct?: DocumentRecordScalarFieldEnum | DocumentRecordScalarFieldEnum[]
  }

  /**
   * DocumentRecord findMany
   */
  export type DocumentRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRecord
     */
    select?: DocumentRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentRecord
     */
    omit?: DocumentRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentRecordInclude<ExtArgs> | null
    /**
     * Filter, which DocumentRecords to fetch.
     */
    where?: DocumentRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentRecords to fetch.
     */
    orderBy?: DocumentRecordOrderByWithRelationInput | DocumentRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DocumentRecords.
     */
    cursor?: DocumentRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentRecords.
     */
    skip?: number
    distinct?: DocumentRecordScalarFieldEnum | DocumentRecordScalarFieldEnum[]
  }

  /**
   * DocumentRecord create
   */
  export type DocumentRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRecord
     */
    select?: DocumentRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentRecord
     */
    omit?: DocumentRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a DocumentRecord.
     */
    data: XOR<DocumentRecordCreateInput, DocumentRecordUncheckedCreateInput>
  }

  /**
   * DocumentRecord createMany
   */
  export type DocumentRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DocumentRecords.
     */
    data: DocumentRecordCreateManyInput | DocumentRecordCreateManyInput[]
  }

  /**
   * DocumentRecord createManyAndReturn
   */
  export type DocumentRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRecord
     */
    select?: DocumentRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentRecord
     */
    omit?: DocumentRecordOmit<ExtArgs> | null
    /**
     * The data used to create many DocumentRecords.
     */
    data: DocumentRecordCreateManyInput | DocumentRecordCreateManyInput[]
  }

  /**
   * DocumentRecord update
   */
  export type DocumentRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRecord
     */
    select?: DocumentRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentRecord
     */
    omit?: DocumentRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a DocumentRecord.
     */
    data: XOR<DocumentRecordUpdateInput, DocumentRecordUncheckedUpdateInput>
    /**
     * Choose, which DocumentRecord to update.
     */
    where: DocumentRecordWhereUniqueInput
  }

  /**
   * DocumentRecord updateMany
   */
  export type DocumentRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DocumentRecords.
     */
    data: XOR<DocumentRecordUpdateManyMutationInput, DocumentRecordUncheckedUpdateManyInput>
    /**
     * Filter which DocumentRecords to update
     */
    where?: DocumentRecordWhereInput
    /**
     * Limit how many DocumentRecords to update.
     */
    limit?: number
  }

  /**
   * DocumentRecord updateManyAndReturn
   */
  export type DocumentRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRecord
     */
    select?: DocumentRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentRecord
     */
    omit?: DocumentRecordOmit<ExtArgs> | null
    /**
     * The data used to update DocumentRecords.
     */
    data: XOR<DocumentRecordUpdateManyMutationInput, DocumentRecordUncheckedUpdateManyInput>
    /**
     * Filter which DocumentRecords to update
     */
    where?: DocumentRecordWhereInput
    /**
     * Limit how many DocumentRecords to update.
     */
    limit?: number
  }

  /**
   * DocumentRecord upsert
   */
  export type DocumentRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRecord
     */
    select?: DocumentRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentRecord
     */
    omit?: DocumentRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the DocumentRecord to update in case it exists.
     */
    where: DocumentRecordWhereUniqueInput
    /**
     * In case the DocumentRecord found by the `where` argument doesn't exist, create a new DocumentRecord with this data.
     */
    create: XOR<DocumentRecordCreateInput, DocumentRecordUncheckedCreateInput>
    /**
     * In case the DocumentRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentRecordUpdateInput, DocumentRecordUncheckedUpdateInput>
  }

  /**
   * DocumentRecord delete
   */
  export type DocumentRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRecord
     */
    select?: DocumentRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentRecord
     */
    omit?: DocumentRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentRecordInclude<ExtArgs> | null
    /**
     * Filter which DocumentRecord to delete.
     */
    where: DocumentRecordWhereUniqueInput
  }

  /**
   * DocumentRecord deleteMany
   */
  export type DocumentRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentRecords to delete
     */
    where?: DocumentRecordWhereInput
    /**
     * Limit how many DocumentRecords to delete.
     */
    limit?: number
  }

  /**
   * DocumentRecord.relatedActions
   */
  export type DocumentRecord$relatedActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAction
     */
    select?: DocumentActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAction
     */
    omit?: DocumentActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentActionInclude<ExtArgs> | null
    where?: DocumentActionWhereInput
    orderBy?: DocumentActionOrderByWithRelationInput | DocumentActionOrderByWithRelationInput[]
    cursor?: DocumentActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentActionScalarFieldEnum | DocumentActionScalarFieldEnum[]
  }

  /**
   * DocumentRecord without action
   */
  export type DocumentRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRecord
     */
    select?: DocumentRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentRecord
     */
    omit?: DocumentRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentRecordInclude<ExtArgs> | null
  }


  /**
   * Model DocumentAction
   */

  export type AggregateDocumentAction = {
    _count: DocumentActionCountAggregateOutputType | null
    _min: DocumentActionMinAggregateOutputType | null
    _max: DocumentActionMaxAggregateOutputType | null
  }

  export type DocumentActionMinAggregateOutputType = {
    id: string | null
    description: string | null
    responsible: string | null
    deadline: Date | null
    status: string | null
    documentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentActionMaxAggregateOutputType = {
    id: string | null
    description: string | null
    responsible: string | null
    deadline: Date | null
    status: string | null
    documentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentActionCountAggregateOutputType = {
    id: number
    description: number
    responsible: number
    deadline: number
    status: number
    documentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DocumentActionMinAggregateInputType = {
    id?: true
    description?: true
    responsible?: true
    deadline?: true
    status?: true
    documentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentActionMaxAggregateInputType = {
    id?: true
    description?: true
    responsible?: true
    deadline?: true
    status?: true
    documentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentActionCountAggregateInputType = {
    id?: true
    description?: true
    responsible?: true
    deadline?: true
    status?: true
    documentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DocumentActionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentAction to aggregate.
     */
    where?: DocumentActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentActions to fetch.
     */
    orderBy?: DocumentActionOrderByWithRelationInput | DocumentActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DocumentActions
    **/
    _count?: true | DocumentActionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentActionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentActionMaxAggregateInputType
  }

  export type GetDocumentActionAggregateType<T extends DocumentActionAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentAction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentAction[P]>
      : GetScalarType<T[P], AggregateDocumentAction[P]>
  }




  export type DocumentActionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentActionWhereInput
    orderBy?: DocumentActionOrderByWithAggregationInput | DocumentActionOrderByWithAggregationInput[]
    by: DocumentActionScalarFieldEnum[] | DocumentActionScalarFieldEnum
    having?: DocumentActionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentActionCountAggregateInputType | true
    _min?: DocumentActionMinAggregateInputType
    _max?: DocumentActionMaxAggregateInputType
  }

  export type DocumentActionGroupByOutputType = {
    id: string
    description: string
    responsible: string
    deadline: Date | null
    status: string
    documentId: string
    createdAt: Date
    updatedAt: Date
    _count: DocumentActionCountAggregateOutputType | null
    _min: DocumentActionMinAggregateOutputType | null
    _max: DocumentActionMaxAggregateOutputType | null
  }

  type GetDocumentActionGroupByPayload<T extends DocumentActionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentActionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentActionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentActionGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentActionGroupByOutputType[P]>
        }
      >
    >


  export type DocumentActionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    responsible?: boolean
    deadline?: boolean
    status?: boolean
    documentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    document?: boolean | DocumentRecordDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentAction"]>

  export type DocumentActionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    responsible?: boolean
    deadline?: boolean
    status?: boolean
    documentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    document?: boolean | DocumentRecordDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentAction"]>

  export type DocumentActionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    responsible?: boolean
    deadline?: boolean
    status?: boolean
    documentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    document?: boolean | DocumentRecordDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentAction"]>

  export type DocumentActionSelectScalar = {
    id?: boolean
    description?: boolean
    responsible?: boolean
    deadline?: boolean
    status?: boolean
    documentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DocumentActionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "description" | "responsible" | "deadline" | "status" | "documentId" | "createdAt" | "updatedAt", ExtArgs["result"]["documentAction"]>
  export type DocumentActionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentRecordDefaultArgs<ExtArgs>
  }
  export type DocumentActionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentRecordDefaultArgs<ExtArgs>
  }
  export type DocumentActionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentRecordDefaultArgs<ExtArgs>
  }

  export type $DocumentActionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DocumentAction"
    objects: {
      document: Prisma.$DocumentRecordPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      description: string
      responsible: string
      deadline: Date | null
      status: string
      documentId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["documentAction"]>
    composites: {}
  }

  type DocumentActionGetPayload<S extends boolean | null | undefined | DocumentActionDefaultArgs> = $Result.GetResult<Prisma.$DocumentActionPayload, S>

  type DocumentActionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentActionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentActionCountAggregateInputType | true
    }

  export interface DocumentActionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DocumentAction'], meta: { name: 'DocumentAction' } }
    /**
     * Find zero or one DocumentAction that matches the filter.
     * @param {DocumentActionFindUniqueArgs} args - Arguments to find a DocumentAction
     * @example
     * // Get one DocumentAction
     * const documentAction = await prisma.documentAction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentActionFindUniqueArgs>(args: SelectSubset<T, DocumentActionFindUniqueArgs<ExtArgs>>): Prisma__DocumentActionClient<$Result.GetResult<Prisma.$DocumentActionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DocumentAction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentActionFindUniqueOrThrowArgs} args - Arguments to find a DocumentAction
     * @example
     * // Get one DocumentAction
     * const documentAction = await prisma.documentAction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentActionFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentActionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentActionClient<$Result.GetResult<Prisma.$DocumentActionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentAction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentActionFindFirstArgs} args - Arguments to find a DocumentAction
     * @example
     * // Get one DocumentAction
     * const documentAction = await prisma.documentAction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentActionFindFirstArgs>(args?: SelectSubset<T, DocumentActionFindFirstArgs<ExtArgs>>): Prisma__DocumentActionClient<$Result.GetResult<Prisma.$DocumentActionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentAction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentActionFindFirstOrThrowArgs} args - Arguments to find a DocumentAction
     * @example
     * // Get one DocumentAction
     * const documentAction = await prisma.documentAction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentActionFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentActionFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentActionClient<$Result.GetResult<Prisma.$DocumentActionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DocumentActions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentActionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DocumentActions
     * const documentActions = await prisma.documentAction.findMany()
     * 
     * // Get first 10 DocumentActions
     * const documentActions = await prisma.documentAction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentActionWithIdOnly = await prisma.documentAction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentActionFindManyArgs>(args?: SelectSubset<T, DocumentActionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DocumentAction.
     * @param {DocumentActionCreateArgs} args - Arguments to create a DocumentAction.
     * @example
     * // Create one DocumentAction
     * const DocumentAction = await prisma.documentAction.create({
     *   data: {
     *     // ... data to create a DocumentAction
     *   }
     * })
     * 
     */
    create<T extends DocumentActionCreateArgs>(args: SelectSubset<T, DocumentActionCreateArgs<ExtArgs>>): Prisma__DocumentActionClient<$Result.GetResult<Prisma.$DocumentActionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DocumentActions.
     * @param {DocumentActionCreateManyArgs} args - Arguments to create many DocumentActions.
     * @example
     * // Create many DocumentActions
     * const documentAction = await prisma.documentAction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentActionCreateManyArgs>(args?: SelectSubset<T, DocumentActionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DocumentActions and returns the data saved in the database.
     * @param {DocumentActionCreateManyAndReturnArgs} args - Arguments to create many DocumentActions.
     * @example
     * // Create many DocumentActions
     * const documentAction = await prisma.documentAction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DocumentActions and only return the `id`
     * const documentActionWithIdOnly = await prisma.documentAction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentActionCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentActionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentActionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DocumentAction.
     * @param {DocumentActionDeleteArgs} args - Arguments to delete one DocumentAction.
     * @example
     * // Delete one DocumentAction
     * const DocumentAction = await prisma.documentAction.delete({
     *   where: {
     *     // ... filter to delete one DocumentAction
     *   }
     * })
     * 
     */
    delete<T extends DocumentActionDeleteArgs>(args: SelectSubset<T, DocumentActionDeleteArgs<ExtArgs>>): Prisma__DocumentActionClient<$Result.GetResult<Prisma.$DocumentActionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DocumentAction.
     * @param {DocumentActionUpdateArgs} args - Arguments to update one DocumentAction.
     * @example
     * // Update one DocumentAction
     * const documentAction = await prisma.documentAction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentActionUpdateArgs>(args: SelectSubset<T, DocumentActionUpdateArgs<ExtArgs>>): Prisma__DocumentActionClient<$Result.GetResult<Prisma.$DocumentActionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DocumentActions.
     * @param {DocumentActionDeleteManyArgs} args - Arguments to filter DocumentActions to delete.
     * @example
     * // Delete a few DocumentActions
     * const { count } = await prisma.documentAction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentActionDeleteManyArgs>(args?: SelectSubset<T, DocumentActionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentActionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DocumentActions
     * const documentAction = await prisma.documentAction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentActionUpdateManyArgs>(args: SelectSubset<T, DocumentActionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentActions and returns the data updated in the database.
     * @param {DocumentActionUpdateManyAndReturnArgs} args - Arguments to update many DocumentActions.
     * @example
     * // Update many DocumentActions
     * const documentAction = await prisma.documentAction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DocumentActions and only return the `id`
     * const documentActionWithIdOnly = await prisma.documentAction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentActionUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentActionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentActionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DocumentAction.
     * @param {DocumentActionUpsertArgs} args - Arguments to update or create a DocumentAction.
     * @example
     * // Update or create a DocumentAction
     * const documentAction = await prisma.documentAction.upsert({
     *   create: {
     *     // ... data to create a DocumentAction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DocumentAction we want to update
     *   }
     * })
     */
    upsert<T extends DocumentActionUpsertArgs>(args: SelectSubset<T, DocumentActionUpsertArgs<ExtArgs>>): Prisma__DocumentActionClient<$Result.GetResult<Prisma.$DocumentActionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DocumentActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentActionCountArgs} args - Arguments to filter DocumentActions to count.
     * @example
     * // Count the number of DocumentActions
     * const count = await prisma.documentAction.count({
     *   where: {
     *     // ... the filter for the DocumentActions we want to count
     *   }
     * })
    **/
    count<T extends DocumentActionCountArgs>(
      args?: Subset<T, DocumentActionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentActionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DocumentAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentActionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentActionAggregateArgs>(args: Subset<T, DocumentActionAggregateArgs>): Prisma.PrismaPromise<GetDocumentActionAggregateType<T>>

    /**
     * Group by DocumentAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentActionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentActionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentActionGroupByArgs['orderBy'] }
        : { orderBy?: DocumentActionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentActionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentActionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DocumentAction model
   */
  readonly fields: DocumentActionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DocumentAction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentActionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    document<T extends DocumentRecordDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DocumentRecordDefaultArgs<ExtArgs>>): Prisma__DocumentRecordClient<$Result.GetResult<Prisma.$DocumentRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DocumentAction model
   */
  interface DocumentActionFieldRefs {
    readonly id: FieldRef<"DocumentAction", 'String'>
    readonly description: FieldRef<"DocumentAction", 'String'>
    readonly responsible: FieldRef<"DocumentAction", 'String'>
    readonly deadline: FieldRef<"DocumentAction", 'DateTime'>
    readonly status: FieldRef<"DocumentAction", 'String'>
    readonly documentId: FieldRef<"DocumentAction", 'String'>
    readonly createdAt: FieldRef<"DocumentAction", 'DateTime'>
    readonly updatedAt: FieldRef<"DocumentAction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DocumentAction findUnique
   */
  export type DocumentActionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAction
     */
    select?: DocumentActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAction
     */
    omit?: DocumentActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentActionInclude<ExtArgs> | null
    /**
     * Filter, which DocumentAction to fetch.
     */
    where: DocumentActionWhereUniqueInput
  }

  /**
   * DocumentAction findUniqueOrThrow
   */
  export type DocumentActionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAction
     */
    select?: DocumentActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAction
     */
    omit?: DocumentActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentActionInclude<ExtArgs> | null
    /**
     * Filter, which DocumentAction to fetch.
     */
    where: DocumentActionWhereUniqueInput
  }

  /**
   * DocumentAction findFirst
   */
  export type DocumentActionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAction
     */
    select?: DocumentActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAction
     */
    omit?: DocumentActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentActionInclude<ExtArgs> | null
    /**
     * Filter, which DocumentAction to fetch.
     */
    where?: DocumentActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentActions to fetch.
     */
    orderBy?: DocumentActionOrderByWithRelationInput | DocumentActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentActions.
     */
    cursor?: DocumentActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentActions.
     */
    distinct?: DocumentActionScalarFieldEnum | DocumentActionScalarFieldEnum[]
  }

  /**
   * DocumentAction findFirstOrThrow
   */
  export type DocumentActionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAction
     */
    select?: DocumentActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAction
     */
    omit?: DocumentActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentActionInclude<ExtArgs> | null
    /**
     * Filter, which DocumentAction to fetch.
     */
    where?: DocumentActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentActions to fetch.
     */
    orderBy?: DocumentActionOrderByWithRelationInput | DocumentActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentActions.
     */
    cursor?: DocumentActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentActions.
     */
    distinct?: DocumentActionScalarFieldEnum | DocumentActionScalarFieldEnum[]
  }

  /**
   * DocumentAction findMany
   */
  export type DocumentActionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAction
     */
    select?: DocumentActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAction
     */
    omit?: DocumentActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentActionInclude<ExtArgs> | null
    /**
     * Filter, which DocumentActions to fetch.
     */
    where?: DocumentActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentActions to fetch.
     */
    orderBy?: DocumentActionOrderByWithRelationInput | DocumentActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DocumentActions.
     */
    cursor?: DocumentActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentActions.
     */
    skip?: number
    distinct?: DocumentActionScalarFieldEnum | DocumentActionScalarFieldEnum[]
  }

  /**
   * DocumentAction create
   */
  export type DocumentActionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAction
     */
    select?: DocumentActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAction
     */
    omit?: DocumentActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentActionInclude<ExtArgs> | null
    /**
     * The data needed to create a DocumentAction.
     */
    data: XOR<DocumentActionCreateInput, DocumentActionUncheckedCreateInput>
  }

  /**
   * DocumentAction createMany
   */
  export type DocumentActionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DocumentActions.
     */
    data: DocumentActionCreateManyInput | DocumentActionCreateManyInput[]
  }

  /**
   * DocumentAction createManyAndReturn
   */
  export type DocumentActionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAction
     */
    select?: DocumentActionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAction
     */
    omit?: DocumentActionOmit<ExtArgs> | null
    /**
     * The data used to create many DocumentActions.
     */
    data: DocumentActionCreateManyInput | DocumentActionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentActionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentAction update
   */
  export type DocumentActionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAction
     */
    select?: DocumentActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAction
     */
    omit?: DocumentActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentActionInclude<ExtArgs> | null
    /**
     * The data needed to update a DocumentAction.
     */
    data: XOR<DocumentActionUpdateInput, DocumentActionUncheckedUpdateInput>
    /**
     * Choose, which DocumentAction to update.
     */
    where: DocumentActionWhereUniqueInput
  }

  /**
   * DocumentAction updateMany
   */
  export type DocumentActionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DocumentActions.
     */
    data: XOR<DocumentActionUpdateManyMutationInput, DocumentActionUncheckedUpdateManyInput>
    /**
     * Filter which DocumentActions to update
     */
    where?: DocumentActionWhereInput
    /**
     * Limit how many DocumentActions to update.
     */
    limit?: number
  }

  /**
   * DocumentAction updateManyAndReturn
   */
  export type DocumentActionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAction
     */
    select?: DocumentActionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAction
     */
    omit?: DocumentActionOmit<ExtArgs> | null
    /**
     * The data used to update DocumentActions.
     */
    data: XOR<DocumentActionUpdateManyMutationInput, DocumentActionUncheckedUpdateManyInput>
    /**
     * Filter which DocumentActions to update
     */
    where?: DocumentActionWhereInput
    /**
     * Limit how many DocumentActions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentActionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentAction upsert
   */
  export type DocumentActionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAction
     */
    select?: DocumentActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAction
     */
    omit?: DocumentActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentActionInclude<ExtArgs> | null
    /**
     * The filter to search for the DocumentAction to update in case it exists.
     */
    where: DocumentActionWhereUniqueInput
    /**
     * In case the DocumentAction found by the `where` argument doesn't exist, create a new DocumentAction with this data.
     */
    create: XOR<DocumentActionCreateInput, DocumentActionUncheckedCreateInput>
    /**
     * In case the DocumentAction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentActionUpdateInput, DocumentActionUncheckedUpdateInput>
  }

  /**
   * DocumentAction delete
   */
  export type DocumentActionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAction
     */
    select?: DocumentActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAction
     */
    omit?: DocumentActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentActionInclude<ExtArgs> | null
    /**
     * Filter which DocumentAction to delete.
     */
    where: DocumentActionWhereUniqueInput
  }

  /**
   * DocumentAction deleteMany
   */
  export type DocumentActionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentActions to delete
     */
    where?: DocumentActionWhereInput
    /**
     * Limit how many DocumentActions to delete.
     */
    limit?: number
  }

  /**
   * DocumentAction without action
   */
  export type DocumentActionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAction
     */
    select?: DocumentActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAction
     */
    omit?: DocumentActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentActionInclude<ExtArgs> | null
  }


  /**
   * Model LawsuitRecord
   */

  export type AggregateLawsuitRecord = {
    _count: LawsuitRecordCountAggregateOutputType | null
    _avg: LawsuitRecordAvgAggregateOutputType | null
    _sum: LawsuitRecordSumAggregateOutputType | null
    _min: LawsuitRecordMinAggregateOutputType | null
    _max: LawsuitRecordMaxAggregateOutputType | null
  }

  export type LawsuitRecordAvgAggregateOutputType = {
    estimatedCost: number | null
    finalCost: number | null
  }

  export type LawsuitRecordSumAggregateOutputType = {
    estimatedCost: number | null
    finalCost: number | null
  }

  export type LawsuitRecordMinAggregateOutputType = {
    id: string | null
    processNumber: string | null
    plaintiff: string | null
    subject: string | null
    status: string | null
    filingDate: Date | null
    hearingDate: Date | null
    estimatedCost: number | null
    finalCost: number | null
    lawyer: string | null
    details: string | null
    relatedNRsJson: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LawsuitRecordMaxAggregateOutputType = {
    id: string | null
    processNumber: string | null
    plaintiff: string | null
    subject: string | null
    status: string | null
    filingDate: Date | null
    hearingDate: Date | null
    estimatedCost: number | null
    finalCost: number | null
    lawyer: string | null
    details: string | null
    relatedNRsJson: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LawsuitRecordCountAggregateOutputType = {
    id: number
    processNumber: number
    plaintiff: number
    subject: number
    status: number
    filingDate: number
    hearingDate: number
    estimatedCost: number
    finalCost: number
    lawyer: number
    details: number
    relatedNRsJson: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LawsuitRecordAvgAggregateInputType = {
    estimatedCost?: true
    finalCost?: true
  }

  export type LawsuitRecordSumAggregateInputType = {
    estimatedCost?: true
    finalCost?: true
  }

  export type LawsuitRecordMinAggregateInputType = {
    id?: true
    processNumber?: true
    plaintiff?: true
    subject?: true
    status?: true
    filingDate?: true
    hearingDate?: true
    estimatedCost?: true
    finalCost?: true
    lawyer?: true
    details?: true
    relatedNRsJson?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LawsuitRecordMaxAggregateInputType = {
    id?: true
    processNumber?: true
    plaintiff?: true
    subject?: true
    status?: true
    filingDate?: true
    hearingDate?: true
    estimatedCost?: true
    finalCost?: true
    lawyer?: true
    details?: true
    relatedNRsJson?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LawsuitRecordCountAggregateInputType = {
    id?: true
    processNumber?: true
    plaintiff?: true
    subject?: true
    status?: true
    filingDate?: true
    hearingDate?: true
    estimatedCost?: true
    finalCost?: true
    lawyer?: true
    details?: true
    relatedNRsJson?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LawsuitRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LawsuitRecord to aggregate.
     */
    where?: LawsuitRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LawsuitRecords to fetch.
     */
    orderBy?: LawsuitRecordOrderByWithRelationInput | LawsuitRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LawsuitRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LawsuitRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LawsuitRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LawsuitRecords
    **/
    _count?: true | LawsuitRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LawsuitRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LawsuitRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LawsuitRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LawsuitRecordMaxAggregateInputType
  }

  export type GetLawsuitRecordAggregateType<T extends LawsuitRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateLawsuitRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLawsuitRecord[P]>
      : GetScalarType<T[P], AggregateLawsuitRecord[P]>
  }




  export type LawsuitRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LawsuitRecordWhereInput
    orderBy?: LawsuitRecordOrderByWithAggregationInput | LawsuitRecordOrderByWithAggregationInput[]
    by: LawsuitRecordScalarFieldEnum[] | LawsuitRecordScalarFieldEnum
    having?: LawsuitRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LawsuitRecordCountAggregateInputType | true
    _avg?: LawsuitRecordAvgAggregateInputType
    _sum?: LawsuitRecordSumAggregateInputType
    _min?: LawsuitRecordMinAggregateInputType
    _max?: LawsuitRecordMaxAggregateInputType
  }

  export type LawsuitRecordGroupByOutputType = {
    id: string
    processNumber: string
    plaintiff: string
    subject: string
    status: string
    filingDate: Date
    hearingDate: Date | null
    estimatedCost: number | null
    finalCost: number | null
    lawyer: string | null
    details: string
    relatedNRsJson: string | null
    createdAt: Date
    updatedAt: Date
    _count: LawsuitRecordCountAggregateOutputType | null
    _avg: LawsuitRecordAvgAggregateOutputType | null
    _sum: LawsuitRecordSumAggregateOutputType | null
    _min: LawsuitRecordMinAggregateOutputType | null
    _max: LawsuitRecordMaxAggregateOutputType | null
  }

  type GetLawsuitRecordGroupByPayload<T extends LawsuitRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LawsuitRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LawsuitRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LawsuitRecordGroupByOutputType[P]>
            : GetScalarType<T[P], LawsuitRecordGroupByOutputType[P]>
        }
      >
    >


  export type LawsuitRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    processNumber?: boolean
    plaintiff?: boolean
    subject?: boolean
    status?: boolean
    filingDate?: boolean
    hearingDate?: boolean
    estimatedCost?: boolean
    finalCost?: boolean
    lawyer?: boolean
    details?: boolean
    relatedNRsJson?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["lawsuitRecord"]>

  export type LawsuitRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    processNumber?: boolean
    plaintiff?: boolean
    subject?: boolean
    status?: boolean
    filingDate?: boolean
    hearingDate?: boolean
    estimatedCost?: boolean
    finalCost?: boolean
    lawyer?: boolean
    details?: boolean
    relatedNRsJson?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["lawsuitRecord"]>

  export type LawsuitRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    processNumber?: boolean
    plaintiff?: boolean
    subject?: boolean
    status?: boolean
    filingDate?: boolean
    hearingDate?: boolean
    estimatedCost?: boolean
    finalCost?: boolean
    lawyer?: boolean
    details?: boolean
    relatedNRsJson?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["lawsuitRecord"]>

  export type LawsuitRecordSelectScalar = {
    id?: boolean
    processNumber?: boolean
    plaintiff?: boolean
    subject?: boolean
    status?: boolean
    filingDate?: boolean
    hearingDate?: boolean
    estimatedCost?: boolean
    finalCost?: boolean
    lawyer?: boolean
    details?: boolean
    relatedNRsJson?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LawsuitRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "processNumber" | "plaintiff" | "subject" | "status" | "filingDate" | "hearingDate" | "estimatedCost" | "finalCost" | "lawyer" | "details" | "relatedNRsJson" | "createdAt" | "updatedAt", ExtArgs["result"]["lawsuitRecord"]>

  export type $LawsuitRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LawsuitRecord"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      processNumber: string
      plaintiff: string
      subject: string
      status: string
      filingDate: Date
      hearingDate: Date | null
      estimatedCost: number | null
      finalCost: number | null
      lawyer: string | null
      details: string
      relatedNRsJson: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["lawsuitRecord"]>
    composites: {}
  }

  type LawsuitRecordGetPayload<S extends boolean | null | undefined | LawsuitRecordDefaultArgs> = $Result.GetResult<Prisma.$LawsuitRecordPayload, S>

  type LawsuitRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LawsuitRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LawsuitRecordCountAggregateInputType | true
    }

  export interface LawsuitRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LawsuitRecord'], meta: { name: 'LawsuitRecord' } }
    /**
     * Find zero or one LawsuitRecord that matches the filter.
     * @param {LawsuitRecordFindUniqueArgs} args - Arguments to find a LawsuitRecord
     * @example
     * // Get one LawsuitRecord
     * const lawsuitRecord = await prisma.lawsuitRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LawsuitRecordFindUniqueArgs>(args: SelectSubset<T, LawsuitRecordFindUniqueArgs<ExtArgs>>): Prisma__LawsuitRecordClient<$Result.GetResult<Prisma.$LawsuitRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LawsuitRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LawsuitRecordFindUniqueOrThrowArgs} args - Arguments to find a LawsuitRecord
     * @example
     * // Get one LawsuitRecord
     * const lawsuitRecord = await prisma.lawsuitRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LawsuitRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, LawsuitRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LawsuitRecordClient<$Result.GetResult<Prisma.$LawsuitRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LawsuitRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LawsuitRecordFindFirstArgs} args - Arguments to find a LawsuitRecord
     * @example
     * // Get one LawsuitRecord
     * const lawsuitRecord = await prisma.lawsuitRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LawsuitRecordFindFirstArgs>(args?: SelectSubset<T, LawsuitRecordFindFirstArgs<ExtArgs>>): Prisma__LawsuitRecordClient<$Result.GetResult<Prisma.$LawsuitRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LawsuitRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LawsuitRecordFindFirstOrThrowArgs} args - Arguments to find a LawsuitRecord
     * @example
     * // Get one LawsuitRecord
     * const lawsuitRecord = await prisma.lawsuitRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LawsuitRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, LawsuitRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__LawsuitRecordClient<$Result.GetResult<Prisma.$LawsuitRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LawsuitRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LawsuitRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LawsuitRecords
     * const lawsuitRecords = await prisma.lawsuitRecord.findMany()
     * 
     * // Get first 10 LawsuitRecords
     * const lawsuitRecords = await prisma.lawsuitRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lawsuitRecordWithIdOnly = await prisma.lawsuitRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LawsuitRecordFindManyArgs>(args?: SelectSubset<T, LawsuitRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LawsuitRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LawsuitRecord.
     * @param {LawsuitRecordCreateArgs} args - Arguments to create a LawsuitRecord.
     * @example
     * // Create one LawsuitRecord
     * const LawsuitRecord = await prisma.lawsuitRecord.create({
     *   data: {
     *     // ... data to create a LawsuitRecord
     *   }
     * })
     * 
     */
    create<T extends LawsuitRecordCreateArgs>(args: SelectSubset<T, LawsuitRecordCreateArgs<ExtArgs>>): Prisma__LawsuitRecordClient<$Result.GetResult<Prisma.$LawsuitRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LawsuitRecords.
     * @param {LawsuitRecordCreateManyArgs} args - Arguments to create many LawsuitRecords.
     * @example
     * // Create many LawsuitRecords
     * const lawsuitRecord = await prisma.lawsuitRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LawsuitRecordCreateManyArgs>(args?: SelectSubset<T, LawsuitRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LawsuitRecords and returns the data saved in the database.
     * @param {LawsuitRecordCreateManyAndReturnArgs} args - Arguments to create many LawsuitRecords.
     * @example
     * // Create many LawsuitRecords
     * const lawsuitRecord = await prisma.lawsuitRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LawsuitRecords and only return the `id`
     * const lawsuitRecordWithIdOnly = await prisma.lawsuitRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LawsuitRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, LawsuitRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LawsuitRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LawsuitRecord.
     * @param {LawsuitRecordDeleteArgs} args - Arguments to delete one LawsuitRecord.
     * @example
     * // Delete one LawsuitRecord
     * const LawsuitRecord = await prisma.lawsuitRecord.delete({
     *   where: {
     *     // ... filter to delete one LawsuitRecord
     *   }
     * })
     * 
     */
    delete<T extends LawsuitRecordDeleteArgs>(args: SelectSubset<T, LawsuitRecordDeleteArgs<ExtArgs>>): Prisma__LawsuitRecordClient<$Result.GetResult<Prisma.$LawsuitRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LawsuitRecord.
     * @param {LawsuitRecordUpdateArgs} args - Arguments to update one LawsuitRecord.
     * @example
     * // Update one LawsuitRecord
     * const lawsuitRecord = await prisma.lawsuitRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LawsuitRecordUpdateArgs>(args: SelectSubset<T, LawsuitRecordUpdateArgs<ExtArgs>>): Prisma__LawsuitRecordClient<$Result.GetResult<Prisma.$LawsuitRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LawsuitRecords.
     * @param {LawsuitRecordDeleteManyArgs} args - Arguments to filter LawsuitRecords to delete.
     * @example
     * // Delete a few LawsuitRecords
     * const { count } = await prisma.lawsuitRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LawsuitRecordDeleteManyArgs>(args?: SelectSubset<T, LawsuitRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LawsuitRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LawsuitRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LawsuitRecords
     * const lawsuitRecord = await prisma.lawsuitRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LawsuitRecordUpdateManyArgs>(args: SelectSubset<T, LawsuitRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LawsuitRecords and returns the data updated in the database.
     * @param {LawsuitRecordUpdateManyAndReturnArgs} args - Arguments to update many LawsuitRecords.
     * @example
     * // Update many LawsuitRecords
     * const lawsuitRecord = await prisma.lawsuitRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LawsuitRecords and only return the `id`
     * const lawsuitRecordWithIdOnly = await prisma.lawsuitRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LawsuitRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, LawsuitRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LawsuitRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LawsuitRecord.
     * @param {LawsuitRecordUpsertArgs} args - Arguments to update or create a LawsuitRecord.
     * @example
     * // Update or create a LawsuitRecord
     * const lawsuitRecord = await prisma.lawsuitRecord.upsert({
     *   create: {
     *     // ... data to create a LawsuitRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LawsuitRecord we want to update
     *   }
     * })
     */
    upsert<T extends LawsuitRecordUpsertArgs>(args: SelectSubset<T, LawsuitRecordUpsertArgs<ExtArgs>>): Prisma__LawsuitRecordClient<$Result.GetResult<Prisma.$LawsuitRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LawsuitRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LawsuitRecordCountArgs} args - Arguments to filter LawsuitRecords to count.
     * @example
     * // Count the number of LawsuitRecords
     * const count = await prisma.lawsuitRecord.count({
     *   where: {
     *     // ... the filter for the LawsuitRecords we want to count
     *   }
     * })
    **/
    count<T extends LawsuitRecordCountArgs>(
      args?: Subset<T, LawsuitRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LawsuitRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LawsuitRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LawsuitRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LawsuitRecordAggregateArgs>(args: Subset<T, LawsuitRecordAggregateArgs>): Prisma.PrismaPromise<GetLawsuitRecordAggregateType<T>>

    /**
     * Group by LawsuitRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LawsuitRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LawsuitRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LawsuitRecordGroupByArgs['orderBy'] }
        : { orderBy?: LawsuitRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LawsuitRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLawsuitRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LawsuitRecord model
   */
  readonly fields: LawsuitRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LawsuitRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LawsuitRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LawsuitRecord model
   */
  interface LawsuitRecordFieldRefs {
    readonly id: FieldRef<"LawsuitRecord", 'String'>
    readonly processNumber: FieldRef<"LawsuitRecord", 'String'>
    readonly plaintiff: FieldRef<"LawsuitRecord", 'String'>
    readonly subject: FieldRef<"LawsuitRecord", 'String'>
    readonly status: FieldRef<"LawsuitRecord", 'String'>
    readonly filingDate: FieldRef<"LawsuitRecord", 'DateTime'>
    readonly hearingDate: FieldRef<"LawsuitRecord", 'DateTime'>
    readonly estimatedCost: FieldRef<"LawsuitRecord", 'Float'>
    readonly finalCost: FieldRef<"LawsuitRecord", 'Float'>
    readonly lawyer: FieldRef<"LawsuitRecord", 'String'>
    readonly details: FieldRef<"LawsuitRecord", 'String'>
    readonly relatedNRsJson: FieldRef<"LawsuitRecord", 'String'>
    readonly createdAt: FieldRef<"LawsuitRecord", 'DateTime'>
    readonly updatedAt: FieldRef<"LawsuitRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LawsuitRecord findUnique
   */
  export type LawsuitRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LawsuitRecord
     */
    select?: LawsuitRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LawsuitRecord
     */
    omit?: LawsuitRecordOmit<ExtArgs> | null
    /**
     * Filter, which LawsuitRecord to fetch.
     */
    where: LawsuitRecordWhereUniqueInput
  }

  /**
   * LawsuitRecord findUniqueOrThrow
   */
  export type LawsuitRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LawsuitRecord
     */
    select?: LawsuitRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LawsuitRecord
     */
    omit?: LawsuitRecordOmit<ExtArgs> | null
    /**
     * Filter, which LawsuitRecord to fetch.
     */
    where: LawsuitRecordWhereUniqueInput
  }

  /**
   * LawsuitRecord findFirst
   */
  export type LawsuitRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LawsuitRecord
     */
    select?: LawsuitRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LawsuitRecord
     */
    omit?: LawsuitRecordOmit<ExtArgs> | null
    /**
     * Filter, which LawsuitRecord to fetch.
     */
    where?: LawsuitRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LawsuitRecords to fetch.
     */
    orderBy?: LawsuitRecordOrderByWithRelationInput | LawsuitRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LawsuitRecords.
     */
    cursor?: LawsuitRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LawsuitRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LawsuitRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LawsuitRecords.
     */
    distinct?: LawsuitRecordScalarFieldEnum | LawsuitRecordScalarFieldEnum[]
  }

  /**
   * LawsuitRecord findFirstOrThrow
   */
  export type LawsuitRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LawsuitRecord
     */
    select?: LawsuitRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LawsuitRecord
     */
    omit?: LawsuitRecordOmit<ExtArgs> | null
    /**
     * Filter, which LawsuitRecord to fetch.
     */
    where?: LawsuitRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LawsuitRecords to fetch.
     */
    orderBy?: LawsuitRecordOrderByWithRelationInput | LawsuitRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LawsuitRecords.
     */
    cursor?: LawsuitRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LawsuitRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LawsuitRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LawsuitRecords.
     */
    distinct?: LawsuitRecordScalarFieldEnum | LawsuitRecordScalarFieldEnum[]
  }

  /**
   * LawsuitRecord findMany
   */
  export type LawsuitRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LawsuitRecord
     */
    select?: LawsuitRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LawsuitRecord
     */
    omit?: LawsuitRecordOmit<ExtArgs> | null
    /**
     * Filter, which LawsuitRecords to fetch.
     */
    where?: LawsuitRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LawsuitRecords to fetch.
     */
    orderBy?: LawsuitRecordOrderByWithRelationInput | LawsuitRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LawsuitRecords.
     */
    cursor?: LawsuitRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LawsuitRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LawsuitRecords.
     */
    skip?: number
    distinct?: LawsuitRecordScalarFieldEnum | LawsuitRecordScalarFieldEnum[]
  }

  /**
   * LawsuitRecord create
   */
  export type LawsuitRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LawsuitRecord
     */
    select?: LawsuitRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LawsuitRecord
     */
    omit?: LawsuitRecordOmit<ExtArgs> | null
    /**
     * The data needed to create a LawsuitRecord.
     */
    data: XOR<LawsuitRecordCreateInput, LawsuitRecordUncheckedCreateInput>
  }

  /**
   * LawsuitRecord createMany
   */
  export type LawsuitRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LawsuitRecords.
     */
    data: LawsuitRecordCreateManyInput | LawsuitRecordCreateManyInput[]
  }

  /**
   * LawsuitRecord createManyAndReturn
   */
  export type LawsuitRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LawsuitRecord
     */
    select?: LawsuitRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LawsuitRecord
     */
    omit?: LawsuitRecordOmit<ExtArgs> | null
    /**
     * The data used to create many LawsuitRecords.
     */
    data: LawsuitRecordCreateManyInput | LawsuitRecordCreateManyInput[]
  }

  /**
   * LawsuitRecord update
   */
  export type LawsuitRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LawsuitRecord
     */
    select?: LawsuitRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LawsuitRecord
     */
    omit?: LawsuitRecordOmit<ExtArgs> | null
    /**
     * The data needed to update a LawsuitRecord.
     */
    data: XOR<LawsuitRecordUpdateInput, LawsuitRecordUncheckedUpdateInput>
    /**
     * Choose, which LawsuitRecord to update.
     */
    where: LawsuitRecordWhereUniqueInput
  }

  /**
   * LawsuitRecord updateMany
   */
  export type LawsuitRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LawsuitRecords.
     */
    data: XOR<LawsuitRecordUpdateManyMutationInput, LawsuitRecordUncheckedUpdateManyInput>
    /**
     * Filter which LawsuitRecords to update
     */
    where?: LawsuitRecordWhereInput
    /**
     * Limit how many LawsuitRecords to update.
     */
    limit?: number
  }

  /**
   * LawsuitRecord updateManyAndReturn
   */
  export type LawsuitRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LawsuitRecord
     */
    select?: LawsuitRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LawsuitRecord
     */
    omit?: LawsuitRecordOmit<ExtArgs> | null
    /**
     * The data used to update LawsuitRecords.
     */
    data: XOR<LawsuitRecordUpdateManyMutationInput, LawsuitRecordUncheckedUpdateManyInput>
    /**
     * Filter which LawsuitRecords to update
     */
    where?: LawsuitRecordWhereInput
    /**
     * Limit how many LawsuitRecords to update.
     */
    limit?: number
  }

  /**
   * LawsuitRecord upsert
   */
  export type LawsuitRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LawsuitRecord
     */
    select?: LawsuitRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LawsuitRecord
     */
    omit?: LawsuitRecordOmit<ExtArgs> | null
    /**
     * The filter to search for the LawsuitRecord to update in case it exists.
     */
    where: LawsuitRecordWhereUniqueInput
    /**
     * In case the LawsuitRecord found by the `where` argument doesn't exist, create a new LawsuitRecord with this data.
     */
    create: XOR<LawsuitRecordCreateInput, LawsuitRecordUncheckedCreateInput>
    /**
     * In case the LawsuitRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LawsuitRecordUpdateInput, LawsuitRecordUncheckedUpdateInput>
  }

  /**
   * LawsuitRecord delete
   */
  export type LawsuitRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LawsuitRecord
     */
    select?: LawsuitRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LawsuitRecord
     */
    omit?: LawsuitRecordOmit<ExtArgs> | null
    /**
     * Filter which LawsuitRecord to delete.
     */
    where: LawsuitRecordWhereUniqueInput
  }

  /**
   * LawsuitRecord deleteMany
   */
  export type LawsuitRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LawsuitRecords to delete
     */
    where?: LawsuitRecordWhereInput
    /**
     * Limit how many LawsuitRecords to delete.
     */
    limit?: number
  }

  /**
   * LawsuitRecord without action
   */
  export type LawsuitRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LawsuitRecord
     */
    select?: LawsuitRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LawsuitRecord
     */
    omit?: LawsuitRecordOmit<ExtArgs> | null
  }


  /**
   * Model AccidentRecord
   */

  export type AggregateAccidentRecord = {
    _count: AccidentRecordCountAggregateOutputType | null
    _avg: AccidentRecordAvgAggregateOutputType | null
    _sum: AccidentRecordSumAggregateOutputType | null
    _min: AccidentRecordMinAggregateOutputType | null
    _max: AccidentRecordMaxAggregateOutputType | null
  }

  export type AccidentRecordAvgAggregateOutputType = {
    daysOff: number | null
  }

  export type AccidentRecordSumAggregateOutputType = {
    daysOff: number | null
  }

  export type AccidentRecordMinAggregateOutputType = {
    id: string | null
    date: Date | null
    time: string | null
    employeeId: string | null
    department: string | null
    location: string | null
    type: string | null
    cause: string | null
    causeDetails: string | null
    daysOff: number | null
    description: string | null
    cid10Code: string | null
    catIssued: boolean | null
    investigationStatus: string | null
    reportUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccidentRecordMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    time: string | null
    employeeId: string | null
    department: string | null
    location: string | null
    type: string | null
    cause: string | null
    causeDetails: string | null
    daysOff: number | null
    description: string | null
    cid10Code: string | null
    catIssued: boolean | null
    investigationStatus: string | null
    reportUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccidentRecordCountAggregateOutputType = {
    id: number
    date: number
    time: number
    employeeId: number
    department: number
    location: number
    type: number
    cause: number
    causeDetails: number
    daysOff: number
    description: number
    cid10Code: number
    catIssued: number
    investigationStatus: number
    reportUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccidentRecordAvgAggregateInputType = {
    daysOff?: true
  }

  export type AccidentRecordSumAggregateInputType = {
    daysOff?: true
  }

  export type AccidentRecordMinAggregateInputType = {
    id?: true
    date?: true
    time?: true
    employeeId?: true
    department?: true
    location?: true
    type?: true
    cause?: true
    causeDetails?: true
    daysOff?: true
    description?: true
    cid10Code?: true
    catIssued?: true
    investigationStatus?: true
    reportUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccidentRecordMaxAggregateInputType = {
    id?: true
    date?: true
    time?: true
    employeeId?: true
    department?: true
    location?: true
    type?: true
    cause?: true
    causeDetails?: true
    daysOff?: true
    description?: true
    cid10Code?: true
    catIssued?: true
    investigationStatus?: true
    reportUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccidentRecordCountAggregateInputType = {
    id?: true
    date?: true
    time?: true
    employeeId?: true
    department?: true
    location?: true
    type?: true
    cause?: true
    causeDetails?: true
    daysOff?: true
    description?: true
    cid10Code?: true
    catIssued?: true
    investigationStatus?: true
    reportUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccidentRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccidentRecord to aggregate.
     */
    where?: AccidentRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccidentRecords to fetch.
     */
    orderBy?: AccidentRecordOrderByWithRelationInput | AccidentRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccidentRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccidentRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccidentRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccidentRecords
    **/
    _count?: true | AccidentRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccidentRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccidentRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccidentRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccidentRecordMaxAggregateInputType
  }

  export type GetAccidentRecordAggregateType<T extends AccidentRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateAccidentRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccidentRecord[P]>
      : GetScalarType<T[P], AggregateAccidentRecord[P]>
  }




  export type AccidentRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccidentRecordWhereInput
    orderBy?: AccidentRecordOrderByWithAggregationInput | AccidentRecordOrderByWithAggregationInput[]
    by: AccidentRecordScalarFieldEnum[] | AccidentRecordScalarFieldEnum
    having?: AccidentRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccidentRecordCountAggregateInputType | true
    _avg?: AccidentRecordAvgAggregateInputType
    _sum?: AccidentRecordSumAggregateInputType
    _min?: AccidentRecordMinAggregateInputType
    _max?: AccidentRecordMaxAggregateInputType
  }

  export type AccidentRecordGroupByOutputType = {
    id: string
    date: Date
    time: string | null
    employeeId: string
    department: string
    location: string
    type: string
    cause: string
    causeDetails: string | null
    daysOff: number
    description: string
    cid10Code: string | null
    catIssued: boolean
    investigationStatus: string
    reportUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: AccidentRecordCountAggregateOutputType | null
    _avg: AccidentRecordAvgAggregateOutputType | null
    _sum: AccidentRecordSumAggregateOutputType | null
    _min: AccidentRecordMinAggregateOutputType | null
    _max: AccidentRecordMaxAggregateOutputType | null
  }

  type GetAccidentRecordGroupByPayload<T extends AccidentRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccidentRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccidentRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccidentRecordGroupByOutputType[P]>
            : GetScalarType<T[P], AccidentRecordGroupByOutputType[P]>
        }
      >
    >


  export type AccidentRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    time?: boolean
    employeeId?: boolean
    department?: boolean
    location?: boolean
    type?: boolean
    cause?: boolean
    causeDetails?: boolean
    daysOff?: boolean
    description?: boolean
    cid10Code?: boolean
    catIssued?: boolean
    investigationStatus?: boolean
    reportUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accidentRecord"]>

  export type AccidentRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    time?: boolean
    employeeId?: boolean
    department?: boolean
    location?: boolean
    type?: boolean
    cause?: boolean
    causeDetails?: boolean
    daysOff?: boolean
    description?: boolean
    cid10Code?: boolean
    catIssued?: boolean
    investigationStatus?: boolean
    reportUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accidentRecord"]>

  export type AccidentRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    time?: boolean
    employeeId?: boolean
    department?: boolean
    location?: boolean
    type?: boolean
    cause?: boolean
    causeDetails?: boolean
    daysOff?: boolean
    description?: boolean
    cid10Code?: boolean
    catIssued?: boolean
    investigationStatus?: boolean
    reportUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accidentRecord"]>

  export type AccidentRecordSelectScalar = {
    id?: boolean
    date?: boolean
    time?: boolean
    employeeId?: boolean
    department?: boolean
    location?: boolean
    type?: boolean
    cause?: boolean
    causeDetails?: boolean
    daysOff?: boolean
    description?: boolean
    cid10Code?: boolean
    catIssued?: boolean
    investigationStatus?: boolean
    reportUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccidentRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "time" | "employeeId" | "department" | "location" | "type" | "cause" | "causeDetails" | "daysOff" | "description" | "cid10Code" | "catIssued" | "investigationStatus" | "reportUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["accidentRecord"]>
  export type AccidentRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type AccidentRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type AccidentRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $AccidentRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AccidentRecord"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      time: string | null
      employeeId: string
      department: string
      location: string
      type: string
      cause: string
      causeDetails: string | null
      daysOff: number
      description: string
      cid10Code: string | null
      catIssued: boolean
      investigationStatus: string
      reportUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["accidentRecord"]>
    composites: {}
  }

  type AccidentRecordGetPayload<S extends boolean | null | undefined | AccidentRecordDefaultArgs> = $Result.GetResult<Prisma.$AccidentRecordPayload, S>

  type AccidentRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccidentRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccidentRecordCountAggregateInputType | true
    }

  export interface AccidentRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccidentRecord'], meta: { name: 'AccidentRecord' } }
    /**
     * Find zero or one AccidentRecord that matches the filter.
     * @param {AccidentRecordFindUniqueArgs} args - Arguments to find a AccidentRecord
     * @example
     * // Get one AccidentRecord
     * const accidentRecord = await prisma.accidentRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccidentRecordFindUniqueArgs>(args: SelectSubset<T, AccidentRecordFindUniqueArgs<ExtArgs>>): Prisma__AccidentRecordClient<$Result.GetResult<Prisma.$AccidentRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AccidentRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccidentRecordFindUniqueOrThrowArgs} args - Arguments to find a AccidentRecord
     * @example
     * // Get one AccidentRecord
     * const accidentRecord = await prisma.accidentRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccidentRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, AccidentRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccidentRecordClient<$Result.GetResult<Prisma.$AccidentRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccidentRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccidentRecordFindFirstArgs} args - Arguments to find a AccidentRecord
     * @example
     * // Get one AccidentRecord
     * const accidentRecord = await prisma.accidentRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccidentRecordFindFirstArgs>(args?: SelectSubset<T, AccidentRecordFindFirstArgs<ExtArgs>>): Prisma__AccidentRecordClient<$Result.GetResult<Prisma.$AccidentRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccidentRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccidentRecordFindFirstOrThrowArgs} args - Arguments to find a AccidentRecord
     * @example
     * // Get one AccidentRecord
     * const accidentRecord = await prisma.accidentRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccidentRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, AccidentRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccidentRecordClient<$Result.GetResult<Prisma.$AccidentRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AccidentRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccidentRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccidentRecords
     * const accidentRecords = await prisma.accidentRecord.findMany()
     * 
     * // Get first 10 AccidentRecords
     * const accidentRecords = await prisma.accidentRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accidentRecordWithIdOnly = await prisma.accidentRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccidentRecordFindManyArgs>(args?: SelectSubset<T, AccidentRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccidentRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AccidentRecord.
     * @param {AccidentRecordCreateArgs} args - Arguments to create a AccidentRecord.
     * @example
     * // Create one AccidentRecord
     * const AccidentRecord = await prisma.accidentRecord.create({
     *   data: {
     *     // ... data to create a AccidentRecord
     *   }
     * })
     * 
     */
    create<T extends AccidentRecordCreateArgs>(args: SelectSubset<T, AccidentRecordCreateArgs<ExtArgs>>): Prisma__AccidentRecordClient<$Result.GetResult<Prisma.$AccidentRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AccidentRecords.
     * @param {AccidentRecordCreateManyArgs} args - Arguments to create many AccidentRecords.
     * @example
     * // Create many AccidentRecords
     * const accidentRecord = await prisma.accidentRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccidentRecordCreateManyArgs>(args?: SelectSubset<T, AccidentRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AccidentRecords and returns the data saved in the database.
     * @param {AccidentRecordCreateManyAndReturnArgs} args - Arguments to create many AccidentRecords.
     * @example
     * // Create many AccidentRecords
     * const accidentRecord = await prisma.accidentRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AccidentRecords and only return the `id`
     * const accidentRecordWithIdOnly = await prisma.accidentRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccidentRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, AccidentRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccidentRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AccidentRecord.
     * @param {AccidentRecordDeleteArgs} args - Arguments to delete one AccidentRecord.
     * @example
     * // Delete one AccidentRecord
     * const AccidentRecord = await prisma.accidentRecord.delete({
     *   where: {
     *     // ... filter to delete one AccidentRecord
     *   }
     * })
     * 
     */
    delete<T extends AccidentRecordDeleteArgs>(args: SelectSubset<T, AccidentRecordDeleteArgs<ExtArgs>>): Prisma__AccidentRecordClient<$Result.GetResult<Prisma.$AccidentRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AccidentRecord.
     * @param {AccidentRecordUpdateArgs} args - Arguments to update one AccidentRecord.
     * @example
     * // Update one AccidentRecord
     * const accidentRecord = await prisma.accidentRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccidentRecordUpdateArgs>(args: SelectSubset<T, AccidentRecordUpdateArgs<ExtArgs>>): Prisma__AccidentRecordClient<$Result.GetResult<Prisma.$AccidentRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AccidentRecords.
     * @param {AccidentRecordDeleteManyArgs} args - Arguments to filter AccidentRecords to delete.
     * @example
     * // Delete a few AccidentRecords
     * const { count } = await prisma.accidentRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccidentRecordDeleteManyArgs>(args?: SelectSubset<T, AccidentRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccidentRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccidentRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccidentRecords
     * const accidentRecord = await prisma.accidentRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccidentRecordUpdateManyArgs>(args: SelectSubset<T, AccidentRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccidentRecords and returns the data updated in the database.
     * @param {AccidentRecordUpdateManyAndReturnArgs} args - Arguments to update many AccidentRecords.
     * @example
     * // Update many AccidentRecords
     * const accidentRecord = await prisma.accidentRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AccidentRecords and only return the `id`
     * const accidentRecordWithIdOnly = await prisma.accidentRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccidentRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, AccidentRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccidentRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AccidentRecord.
     * @param {AccidentRecordUpsertArgs} args - Arguments to update or create a AccidentRecord.
     * @example
     * // Update or create a AccidentRecord
     * const accidentRecord = await prisma.accidentRecord.upsert({
     *   create: {
     *     // ... data to create a AccidentRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccidentRecord we want to update
     *   }
     * })
     */
    upsert<T extends AccidentRecordUpsertArgs>(args: SelectSubset<T, AccidentRecordUpsertArgs<ExtArgs>>): Prisma__AccidentRecordClient<$Result.GetResult<Prisma.$AccidentRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AccidentRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccidentRecordCountArgs} args - Arguments to filter AccidentRecords to count.
     * @example
     * // Count the number of AccidentRecords
     * const count = await prisma.accidentRecord.count({
     *   where: {
     *     // ... the filter for the AccidentRecords we want to count
     *   }
     * })
    **/
    count<T extends AccidentRecordCountArgs>(
      args?: Subset<T, AccidentRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccidentRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccidentRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccidentRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccidentRecordAggregateArgs>(args: Subset<T, AccidentRecordAggregateArgs>): Prisma.PrismaPromise<GetAccidentRecordAggregateType<T>>

    /**
     * Group by AccidentRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccidentRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccidentRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccidentRecordGroupByArgs['orderBy'] }
        : { orderBy?: AccidentRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccidentRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccidentRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AccidentRecord model
   */
  readonly fields: AccidentRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AccidentRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccidentRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AccidentRecord model
   */
  interface AccidentRecordFieldRefs {
    readonly id: FieldRef<"AccidentRecord", 'String'>
    readonly date: FieldRef<"AccidentRecord", 'DateTime'>
    readonly time: FieldRef<"AccidentRecord", 'String'>
    readonly employeeId: FieldRef<"AccidentRecord", 'String'>
    readonly department: FieldRef<"AccidentRecord", 'String'>
    readonly location: FieldRef<"AccidentRecord", 'String'>
    readonly type: FieldRef<"AccidentRecord", 'String'>
    readonly cause: FieldRef<"AccidentRecord", 'String'>
    readonly causeDetails: FieldRef<"AccidentRecord", 'String'>
    readonly daysOff: FieldRef<"AccidentRecord", 'Int'>
    readonly description: FieldRef<"AccidentRecord", 'String'>
    readonly cid10Code: FieldRef<"AccidentRecord", 'String'>
    readonly catIssued: FieldRef<"AccidentRecord", 'Boolean'>
    readonly investigationStatus: FieldRef<"AccidentRecord", 'String'>
    readonly reportUrl: FieldRef<"AccidentRecord", 'String'>
    readonly createdAt: FieldRef<"AccidentRecord", 'DateTime'>
    readonly updatedAt: FieldRef<"AccidentRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AccidentRecord findUnique
   */
  export type AccidentRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccidentRecord
     */
    select?: AccidentRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccidentRecord
     */
    omit?: AccidentRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccidentRecordInclude<ExtArgs> | null
    /**
     * Filter, which AccidentRecord to fetch.
     */
    where: AccidentRecordWhereUniqueInput
  }

  /**
   * AccidentRecord findUniqueOrThrow
   */
  export type AccidentRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccidentRecord
     */
    select?: AccidentRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccidentRecord
     */
    omit?: AccidentRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccidentRecordInclude<ExtArgs> | null
    /**
     * Filter, which AccidentRecord to fetch.
     */
    where: AccidentRecordWhereUniqueInput
  }

  /**
   * AccidentRecord findFirst
   */
  export type AccidentRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccidentRecord
     */
    select?: AccidentRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccidentRecord
     */
    omit?: AccidentRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccidentRecordInclude<ExtArgs> | null
    /**
     * Filter, which AccidentRecord to fetch.
     */
    where?: AccidentRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccidentRecords to fetch.
     */
    orderBy?: AccidentRecordOrderByWithRelationInput | AccidentRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccidentRecords.
     */
    cursor?: AccidentRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccidentRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccidentRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccidentRecords.
     */
    distinct?: AccidentRecordScalarFieldEnum | AccidentRecordScalarFieldEnum[]
  }

  /**
   * AccidentRecord findFirstOrThrow
   */
  export type AccidentRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccidentRecord
     */
    select?: AccidentRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccidentRecord
     */
    omit?: AccidentRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccidentRecordInclude<ExtArgs> | null
    /**
     * Filter, which AccidentRecord to fetch.
     */
    where?: AccidentRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccidentRecords to fetch.
     */
    orderBy?: AccidentRecordOrderByWithRelationInput | AccidentRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccidentRecords.
     */
    cursor?: AccidentRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccidentRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccidentRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccidentRecords.
     */
    distinct?: AccidentRecordScalarFieldEnum | AccidentRecordScalarFieldEnum[]
  }

  /**
   * AccidentRecord findMany
   */
  export type AccidentRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccidentRecord
     */
    select?: AccidentRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccidentRecord
     */
    omit?: AccidentRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccidentRecordInclude<ExtArgs> | null
    /**
     * Filter, which AccidentRecords to fetch.
     */
    where?: AccidentRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccidentRecords to fetch.
     */
    orderBy?: AccidentRecordOrderByWithRelationInput | AccidentRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccidentRecords.
     */
    cursor?: AccidentRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccidentRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccidentRecords.
     */
    skip?: number
    distinct?: AccidentRecordScalarFieldEnum | AccidentRecordScalarFieldEnum[]
  }

  /**
   * AccidentRecord create
   */
  export type AccidentRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccidentRecord
     */
    select?: AccidentRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccidentRecord
     */
    omit?: AccidentRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccidentRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a AccidentRecord.
     */
    data: XOR<AccidentRecordCreateInput, AccidentRecordUncheckedCreateInput>
  }

  /**
   * AccidentRecord createMany
   */
  export type AccidentRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AccidentRecords.
     */
    data: AccidentRecordCreateManyInput | AccidentRecordCreateManyInput[]
  }

  /**
   * AccidentRecord createManyAndReturn
   */
  export type AccidentRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccidentRecord
     */
    select?: AccidentRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AccidentRecord
     */
    omit?: AccidentRecordOmit<ExtArgs> | null
    /**
     * The data used to create many AccidentRecords.
     */
    data: AccidentRecordCreateManyInput | AccidentRecordCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccidentRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AccidentRecord update
   */
  export type AccidentRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccidentRecord
     */
    select?: AccidentRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccidentRecord
     */
    omit?: AccidentRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccidentRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a AccidentRecord.
     */
    data: XOR<AccidentRecordUpdateInput, AccidentRecordUncheckedUpdateInput>
    /**
     * Choose, which AccidentRecord to update.
     */
    where: AccidentRecordWhereUniqueInput
  }

  /**
   * AccidentRecord updateMany
   */
  export type AccidentRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AccidentRecords.
     */
    data: XOR<AccidentRecordUpdateManyMutationInput, AccidentRecordUncheckedUpdateManyInput>
    /**
     * Filter which AccidentRecords to update
     */
    where?: AccidentRecordWhereInput
    /**
     * Limit how many AccidentRecords to update.
     */
    limit?: number
  }

  /**
   * AccidentRecord updateManyAndReturn
   */
  export type AccidentRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccidentRecord
     */
    select?: AccidentRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AccidentRecord
     */
    omit?: AccidentRecordOmit<ExtArgs> | null
    /**
     * The data used to update AccidentRecords.
     */
    data: XOR<AccidentRecordUpdateManyMutationInput, AccidentRecordUncheckedUpdateManyInput>
    /**
     * Filter which AccidentRecords to update
     */
    where?: AccidentRecordWhereInput
    /**
     * Limit how many AccidentRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccidentRecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AccidentRecord upsert
   */
  export type AccidentRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccidentRecord
     */
    select?: AccidentRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccidentRecord
     */
    omit?: AccidentRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccidentRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the AccidentRecord to update in case it exists.
     */
    where: AccidentRecordWhereUniqueInput
    /**
     * In case the AccidentRecord found by the `where` argument doesn't exist, create a new AccidentRecord with this data.
     */
    create: XOR<AccidentRecordCreateInput, AccidentRecordUncheckedCreateInput>
    /**
     * In case the AccidentRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccidentRecordUpdateInput, AccidentRecordUncheckedUpdateInput>
  }

  /**
   * AccidentRecord delete
   */
  export type AccidentRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccidentRecord
     */
    select?: AccidentRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccidentRecord
     */
    omit?: AccidentRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccidentRecordInclude<ExtArgs> | null
    /**
     * Filter which AccidentRecord to delete.
     */
    where: AccidentRecordWhereUniqueInput
  }

  /**
   * AccidentRecord deleteMany
   */
  export type AccidentRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccidentRecords to delete
     */
    where?: AccidentRecordWhereInput
    /**
     * Limit how many AccidentRecords to delete.
     */
    limit?: number
  }

  /**
   * AccidentRecord without action
   */
  export type AccidentRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccidentRecord
     */
    select?: AccidentRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccidentRecord
     */
    omit?: AccidentRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccidentRecordInclude<ExtArgs> | null
  }


  /**
   * Model OccupationalDiseaseRecord
   */

  export type AggregateOccupationalDiseaseRecord = {
    _count: OccupationalDiseaseRecordCountAggregateOutputType | null
    _avg: OccupationalDiseaseRecordAvgAggregateOutputType | null
    _sum: OccupationalDiseaseRecordSumAggregateOutputType | null
    _min: OccupationalDiseaseRecordMinAggregateOutputType | null
    _max: OccupationalDiseaseRecordMaxAggregateOutputType | null
  }

  export type OccupationalDiseaseRecordAvgAggregateOutputType = {
    daysOff: number | null
  }

  export type OccupationalDiseaseRecordSumAggregateOutputType = {
    daysOff: number | null
  }

  export type OccupationalDiseaseRecordMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    diseaseType: string | null
    cid10Code: string | null
    diagnosisDate: Date | null
    relatedTask: string | null
    daysOff: number | null
    status: string | null
    medicalReportUrl: string | null
    pcmsoLink: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OccupationalDiseaseRecordMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    diseaseType: string | null
    cid10Code: string | null
    diagnosisDate: Date | null
    relatedTask: string | null
    daysOff: number | null
    status: string | null
    medicalReportUrl: string | null
    pcmsoLink: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OccupationalDiseaseRecordCountAggregateOutputType = {
    id: number
    employeeId: number
    diseaseType: number
    cid10Code: number
    diagnosisDate: number
    relatedTask: number
    daysOff: number
    status: number
    medicalReportUrl: number
    pcmsoLink: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OccupationalDiseaseRecordAvgAggregateInputType = {
    daysOff?: true
  }

  export type OccupationalDiseaseRecordSumAggregateInputType = {
    daysOff?: true
  }

  export type OccupationalDiseaseRecordMinAggregateInputType = {
    id?: true
    employeeId?: true
    diseaseType?: true
    cid10Code?: true
    diagnosisDate?: true
    relatedTask?: true
    daysOff?: true
    status?: true
    medicalReportUrl?: true
    pcmsoLink?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OccupationalDiseaseRecordMaxAggregateInputType = {
    id?: true
    employeeId?: true
    diseaseType?: true
    cid10Code?: true
    diagnosisDate?: true
    relatedTask?: true
    daysOff?: true
    status?: true
    medicalReportUrl?: true
    pcmsoLink?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OccupationalDiseaseRecordCountAggregateInputType = {
    id?: true
    employeeId?: true
    diseaseType?: true
    cid10Code?: true
    diagnosisDate?: true
    relatedTask?: true
    daysOff?: true
    status?: true
    medicalReportUrl?: true
    pcmsoLink?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OccupationalDiseaseRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OccupationalDiseaseRecord to aggregate.
     */
    where?: OccupationalDiseaseRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OccupationalDiseaseRecords to fetch.
     */
    orderBy?: OccupationalDiseaseRecordOrderByWithRelationInput | OccupationalDiseaseRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OccupationalDiseaseRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OccupationalDiseaseRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OccupationalDiseaseRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OccupationalDiseaseRecords
    **/
    _count?: true | OccupationalDiseaseRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OccupationalDiseaseRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OccupationalDiseaseRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OccupationalDiseaseRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OccupationalDiseaseRecordMaxAggregateInputType
  }

  export type GetOccupationalDiseaseRecordAggregateType<T extends OccupationalDiseaseRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateOccupationalDiseaseRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOccupationalDiseaseRecord[P]>
      : GetScalarType<T[P], AggregateOccupationalDiseaseRecord[P]>
  }




  export type OccupationalDiseaseRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OccupationalDiseaseRecordWhereInput
    orderBy?: OccupationalDiseaseRecordOrderByWithAggregationInput | OccupationalDiseaseRecordOrderByWithAggregationInput[]
    by: OccupationalDiseaseRecordScalarFieldEnum[] | OccupationalDiseaseRecordScalarFieldEnum
    having?: OccupationalDiseaseRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OccupationalDiseaseRecordCountAggregateInputType | true
    _avg?: OccupationalDiseaseRecordAvgAggregateInputType
    _sum?: OccupationalDiseaseRecordSumAggregateInputType
    _min?: OccupationalDiseaseRecordMinAggregateInputType
    _max?: OccupationalDiseaseRecordMaxAggregateInputType
  }

  export type OccupationalDiseaseRecordGroupByOutputType = {
    id: string
    employeeId: string
    diseaseType: string
    cid10Code: string
    diagnosisDate: Date
    relatedTask: string | null
    daysOff: number
    status: string
    medicalReportUrl: string | null
    pcmsoLink: string | null
    createdAt: Date
    updatedAt: Date
    _count: OccupationalDiseaseRecordCountAggregateOutputType | null
    _avg: OccupationalDiseaseRecordAvgAggregateOutputType | null
    _sum: OccupationalDiseaseRecordSumAggregateOutputType | null
    _min: OccupationalDiseaseRecordMinAggregateOutputType | null
    _max: OccupationalDiseaseRecordMaxAggregateOutputType | null
  }

  type GetOccupationalDiseaseRecordGroupByPayload<T extends OccupationalDiseaseRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OccupationalDiseaseRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OccupationalDiseaseRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OccupationalDiseaseRecordGroupByOutputType[P]>
            : GetScalarType<T[P], OccupationalDiseaseRecordGroupByOutputType[P]>
        }
      >
    >


  export type OccupationalDiseaseRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    diseaseType?: boolean
    cid10Code?: boolean
    diagnosisDate?: boolean
    relatedTask?: boolean
    daysOff?: boolean
    status?: boolean
    medicalReportUrl?: boolean
    pcmsoLink?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["occupationalDiseaseRecord"]>

  export type OccupationalDiseaseRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    diseaseType?: boolean
    cid10Code?: boolean
    diagnosisDate?: boolean
    relatedTask?: boolean
    daysOff?: boolean
    status?: boolean
    medicalReportUrl?: boolean
    pcmsoLink?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["occupationalDiseaseRecord"]>

  export type OccupationalDiseaseRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    diseaseType?: boolean
    cid10Code?: boolean
    diagnosisDate?: boolean
    relatedTask?: boolean
    daysOff?: boolean
    status?: boolean
    medicalReportUrl?: boolean
    pcmsoLink?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["occupationalDiseaseRecord"]>

  export type OccupationalDiseaseRecordSelectScalar = {
    id?: boolean
    employeeId?: boolean
    diseaseType?: boolean
    cid10Code?: boolean
    diagnosisDate?: boolean
    relatedTask?: boolean
    daysOff?: boolean
    status?: boolean
    medicalReportUrl?: boolean
    pcmsoLink?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OccupationalDiseaseRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "diseaseType" | "cid10Code" | "diagnosisDate" | "relatedTask" | "daysOff" | "status" | "medicalReportUrl" | "pcmsoLink" | "createdAt" | "updatedAt", ExtArgs["result"]["occupationalDiseaseRecord"]>
  export type OccupationalDiseaseRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type OccupationalDiseaseRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type OccupationalDiseaseRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $OccupationalDiseaseRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OccupationalDiseaseRecord"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      diseaseType: string
      cid10Code: string
      diagnosisDate: Date
      relatedTask: string | null
      daysOff: number
      status: string
      medicalReportUrl: string | null
      pcmsoLink: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["occupationalDiseaseRecord"]>
    composites: {}
  }

  type OccupationalDiseaseRecordGetPayload<S extends boolean | null | undefined | OccupationalDiseaseRecordDefaultArgs> = $Result.GetResult<Prisma.$OccupationalDiseaseRecordPayload, S>

  type OccupationalDiseaseRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OccupationalDiseaseRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OccupationalDiseaseRecordCountAggregateInputType | true
    }

  export interface OccupationalDiseaseRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OccupationalDiseaseRecord'], meta: { name: 'OccupationalDiseaseRecord' } }
    /**
     * Find zero or one OccupationalDiseaseRecord that matches the filter.
     * @param {OccupationalDiseaseRecordFindUniqueArgs} args - Arguments to find a OccupationalDiseaseRecord
     * @example
     * // Get one OccupationalDiseaseRecord
     * const occupationalDiseaseRecord = await prisma.occupationalDiseaseRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OccupationalDiseaseRecordFindUniqueArgs>(args: SelectSubset<T, OccupationalDiseaseRecordFindUniqueArgs<ExtArgs>>): Prisma__OccupationalDiseaseRecordClient<$Result.GetResult<Prisma.$OccupationalDiseaseRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OccupationalDiseaseRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OccupationalDiseaseRecordFindUniqueOrThrowArgs} args - Arguments to find a OccupationalDiseaseRecord
     * @example
     * // Get one OccupationalDiseaseRecord
     * const occupationalDiseaseRecord = await prisma.occupationalDiseaseRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OccupationalDiseaseRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, OccupationalDiseaseRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OccupationalDiseaseRecordClient<$Result.GetResult<Prisma.$OccupationalDiseaseRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OccupationalDiseaseRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OccupationalDiseaseRecordFindFirstArgs} args - Arguments to find a OccupationalDiseaseRecord
     * @example
     * // Get one OccupationalDiseaseRecord
     * const occupationalDiseaseRecord = await prisma.occupationalDiseaseRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OccupationalDiseaseRecordFindFirstArgs>(args?: SelectSubset<T, OccupationalDiseaseRecordFindFirstArgs<ExtArgs>>): Prisma__OccupationalDiseaseRecordClient<$Result.GetResult<Prisma.$OccupationalDiseaseRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OccupationalDiseaseRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OccupationalDiseaseRecordFindFirstOrThrowArgs} args - Arguments to find a OccupationalDiseaseRecord
     * @example
     * // Get one OccupationalDiseaseRecord
     * const occupationalDiseaseRecord = await prisma.occupationalDiseaseRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OccupationalDiseaseRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, OccupationalDiseaseRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__OccupationalDiseaseRecordClient<$Result.GetResult<Prisma.$OccupationalDiseaseRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OccupationalDiseaseRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OccupationalDiseaseRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OccupationalDiseaseRecords
     * const occupationalDiseaseRecords = await prisma.occupationalDiseaseRecord.findMany()
     * 
     * // Get first 10 OccupationalDiseaseRecords
     * const occupationalDiseaseRecords = await prisma.occupationalDiseaseRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const occupationalDiseaseRecordWithIdOnly = await prisma.occupationalDiseaseRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OccupationalDiseaseRecordFindManyArgs>(args?: SelectSubset<T, OccupationalDiseaseRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OccupationalDiseaseRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OccupationalDiseaseRecord.
     * @param {OccupationalDiseaseRecordCreateArgs} args - Arguments to create a OccupationalDiseaseRecord.
     * @example
     * // Create one OccupationalDiseaseRecord
     * const OccupationalDiseaseRecord = await prisma.occupationalDiseaseRecord.create({
     *   data: {
     *     // ... data to create a OccupationalDiseaseRecord
     *   }
     * })
     * 
     */
    create<T extends OccupationalDiseaseRecordCreateArgs>(args: SelectSubset<T, OccupationalDiseaseRecordCreateArgs<ExtArgs>>): Prisma__OccupationalDiseaseRecordClient<$Result.GetResult<Prisma.$OccupationalDiseaseRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OccupationalDiseaseRecords.
     * @param {OccupationalDiseaseRecordCreateManyArgs} args - Arguments to create many OccupationalDiseaseRecords.
     * @example
     * // Create many OccupationalDiseaseRecords
     * const occupationalDiseaseRecord = await prisma.occupationalDiseaseRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OccupationalDiseaseRecordCreateManyArgs>(args?: SelectSubset<T, OccupationalDiseaseRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OccupationalDiseaseRecords and returns the data saved in the database.
     * @param {OccupationalDiseaseRecordCreateManyAndReturnArgs} args - Arguments to create many OccupationalDiseaseRecords.
     * @example
     * // Create many OccupationalDiseaseRecords
     * const occupationalDiseaseRecord = await prisma.occupationalDiseaseRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OccupationalDiseaseRecords and only return the `id`
     * const occupationalDiseaseRecordWithIdOnly = await prisma.occupationalDiseaseRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OccupationalDiseaseRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, OccupationalDiseaseRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OccupationalDiseaseRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OccupationalDiseaseRecord.
     * @param {OccupationalDiseaseRecordDeleteArgs} args - Arguments to delete one OccupationalDiseaseRecord.
     * @example
     * // Delete one OccupationalDiseaseRecord
     * const OccupationalDiseaseRecord = await prisma.occupationalDiseaseRecord.delete({
     *   where: {
     *     // ... filter to delete one OccupationalDiseaseRecord
     *   }
     * })
     * 
     */
    delete<T extends OccupationalDiseaseRecordDeleteArgs>(args: SelectSubset<T, OccupationalDiseaseRecordDeleteArgs<ExtArgs>>): Prisma__OccupationalDiseaseRecordClient<$Result.GetResult<Prisma.$OccupationalDiseaseRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OccupationalDiseaseRecord.
     * @param {OccupationalDiseaseRecordUpdateArgs} args - Arguments to update one OccupationalDiseaseRecord.
     * @example
     * // Update one OccupationalDiseaseRecord
     * const occupationalDiseaseRecord = await prisma.occupationalDiseaseRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OccupationalDiseaseRecordUpdateArgs>(args: SelectSubset<T, OccupationalDiseaseRecordUpdateArgs<ExtArgs>>): Prisma__OccupationalDiseaseRecordClient<$Result.GetResult<Prisma.$OccupationalDiseaseRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OccupationalDiseaseRecords.
     * @param {OccupationalDiseaseRecordDeleteManyArgs} args - Arguments to filter OccupationalDiseaseRecords to delete.
     * @example
     * // Delete a few OccupationalDiseaseRecords
     * const { count } = await prisma.occupationalDiseaseRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OccupationalDiseaseRecordDeleteManyArgs>(args?: SelectSubset<T, OccupationalDiseaseRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OccupationalDiseaseRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OccupationalDiseaseRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OccupationalDiseaseRecords
     * const occupationalDiseaseRecord = await prisma.occupationalDiseaseRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OccupationalDiseaseRecordUpdateManyArgs>(args: SelectSubset<T, OccupationalDiseaseRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OccupationalDiseaseRecords and returns the data updated in the database.
     * @param {OccupationalDiseaseRecordUpdateManyAndReturnArgs} args - Arguments to update many OccupationalDiseaseRecords.
     * @example
     * // Update many OccupationalDiseaseRecords
     * const occupationalDiseaseRecord = await prisma.occupationalDiseaseRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OccupationalDiseaseRecords and only return the `id`
     * const occupationalDiseaseRecordWithIdOnly = await prisma.occupationalDiseaseRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OccupationalDiseaseRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, OccupationalDiseaseRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OccupationalDiseaseRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OccupationalDiseaseRecord.
     * @param {OccupationalDiseaseRecordUpsertArgs} args - Arguments to update or create a OccupationalDiseaseRecord.
     * @example
     * // Update or create a OccupationalDiseaseRecord
     * const occupationalDiseaseRecord = await prisma.occupationalDiseaseRecord.upsert({
     *   create: {
     *     // ... data to create a OccupationalDiseaseRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OccupationalDiseaseRecord we want to update
     *   }
     * })
     */
    upsert<T extends OccupationalDiseaseRecordUpsertArgs>(args: SelectSubset<T, OccupationalDiseaseRecordUpsertArgs<ExtArgs>>): Prisma__OccupationalDiseaseRecordClient<$Result.GetResult<Prisma.$OccupationalDiseaseRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OccupationalDiseaseRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OccupationalDiseaseRecordCountArgs} args - Arguments to filter OccupationalDiseaseRecords to count.
     * @example
     * // Count the number of OccupationalDiseaseRecords
     * const count = await prisma.occupationalDiseaseRecord.count({
     *   where: {
     *     // ... the filter for the OccupationalDiseaseRecords we want to count
     *   }
     * })
    **/
    count<T extends OccupationalDiseaseRecordCountArgs>(
      args?: Subset<T, OccupationalDiseaseRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OccupationalDiseaseRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OccupationalDiseaseRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OccupationalDiseaseRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OccupationalDiseaseRecordAggregateArgs>(args: Subset<T, OccupationalDiseaseRecordAggregateArgs>): Prisma.PrismaPromise<GetOccupationalDiseaseRecordAggregateType<T>>

    /**
     * Group by OccupationalDiseaseRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OccupationalDiseaseRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OccupationalDiseaseRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OccupationalDiseaseRecordGroupByArgs['orderBy'] }
        : { orderBy?: OccupationalDiseaseRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OccupationalDiseaseRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOccupationalDiseaseRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OccupationalDiseaseRecord model
   */
  readonly fields: OccupationalDiseaseRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OccupationalDiseaseRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OccupationalDiseaseRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OccupationalDiseaseRecord model
   */
  interface OccupationalDiseaseRecordFieldRefs {
    readonly id: FieldRef<"OccupationalDiseaseRecord", 'String'>
    readonly employeeId: FieldRef<"OccupationalDiseaseRecord", 'String'>
    readonly diseaseType: FieldRef<"OccupationalDiseaseRecord", 'String'>
    readonly cid10Code: FieldRef<"OccupationalDiseaseRecord", 'String'>
    readonly diagnosisDate: FieldRef<"OccupationalDiseaseRecord", 'DateTime'>
    readonly relatedTask: FieldRef<"OccupationalDiseaseRecord", 'String'>
    readonly daysOff: FieldRef<"OccupationalDiseaseRecord", 'Int'>
    readonly status: FieldRef<"OccupationalDiseaseRecord", 'String'>
    readonly medicalReportUrl: FieldRef<"OccupationalDiseaseRecord", 'String'>
    readonly pcmsoLink: FieldRef<"OccupationalDiseaseRecord", 'String'>
    readonly createdAt: FieldRef<"OccupationalDiseaseRecord", 'DateTime'>
    readonly updatedAt: FieldRef<"OccupationalDiseaseRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OccupationalDiseaseRecord findUnique
   */
  export type OccupationalDiseaseRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OccupationalDiseaseRecord
     */
    select?: OccupationalDiseaseRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OccupationalDiseaseRecord
     */
    omit?: OccupationalDiseaseRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccupationalDiseaseRecordInclude<ExtArgs> | null
    /**
     * Filter, which OccupationalDiseaseRecord to fetch.
     */
    where: OccupationalDiseaseRecordWhereUniqueInput
  }

  /**
   * OccupationalDiseaseRecord findUniqueOrThrow
   */
  export type OccupationalDiseaseRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OccupationalDiseaseRecord
     */
    select?: OccupationalDiseaseRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OccupationalDiseaseRecord
     */
    omit?: OccupationalDiseaseRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccupationalDiseaseRecordInclude<ExtArgs> | null
    /**
     * Filter, which OccupationalDiseaseRecord to fetch.
     */
    where: OccupationalDiseaseRecordWhereUniqueInput
  }

  /**
   * OccupationalDiseaseRecord findFirst
   */
  export type OccupationalDiseaseRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OccupationalDiseaseRecord
     */
    select?: OccupationalDiseaseRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OccupationalDiseaseRecord
     */
    omit?: OccupationalDiseaseRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccupationalDiseaseRecordInclude<ExtArgs> | null
    /**
     * Filter, which OccupationalDiseaseRecord to fetch.
     */
    where?: OccupationalDiseaseRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OccupationalDiseaseRecords to fetch.
     */
    orderBy?: OccupationalDiseaseRecordOrderByWithRelationInput | OccupationalDiseaseRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OccupationalDiseaseRecords.
     */
    cursor?: OccupationalDiseaseRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OccupationalDiseaseRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OccupationalDiseaseRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OccupationalDiseaseRecords.
     */
    distinct?: OccupationalDiseaseRecordScalarFieldEnum | OccupationalDiseaseRecordScalarFieldEnum[]
  }

  /**
   * OccupationalDiseaseRecord findFirstOrThrow
   */
  export type OccupationalDiseaseRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OccupationalDiseaseRecord
     */
    select?: OccupationalDiseaseRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OccupationalDiseaseRecord
     */
    omit?: OccupationalDiseaseRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccupationalDiseaseRecordInclude<ExtArgs> | null
    /**
     * Filter, which OccupationalDiseaseRecord to fetch.
     */
    where?: OccupationalDiseaseRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OccupationalDiseaseRecords to fetch.
     */
    orderBy?: OccupationalDiseaseRecordOrderByWithRelationInput | OccupationalDiseaseRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OccupationalDiseaseRecords.
     */
    cursor?: OccupationalDiseaseRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OccupationalDiseaseRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OccupationalDiseaseRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OccupationalDiseaseRecords.
     */
    distinct?: OccupationalDiseaseRecordScalarFieldEnum | OccupationalDiseaseRecordScalarFieldEnum[]
  }

  /**
   * OccupationalDiseaseRecord findMany
   */
  export type OccupationalDiseaseRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OccupationalDiseaseRecord
     */
    select?: OccupationalDiseaseRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OccupationalDiseaseRecord
     */
    omit?: OccupationalDiseaseRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccupationalDiseaseRecordInclude<ExtArgs> | null
    /**
     * Filter, which OccupationalDiseaseRecords to fetch.
     */
    where?: OccupationalDiseaseRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OccupationalDiseaseRecords to fetch.
     */
    orderBy?: OccupationalDiseaseRecordOrderByWithRelationInput | OccupationalDiseaseRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OccupationalDiseaseRecords.
     */
    cursor?: OccupationalDiseaseRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OccupationalDiseaseRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OccupationalDiseaseRecords.
     */
    skip?: number
    distinct?: OccupationalDiseaseRecordScalarFieldEnum | OccupationalDiseaseRecordScalarFieldEnum[]
  }

  /**
   * OccupationalDiseaseRecord create
   */
  export type OccupationalDiseaseRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OccupationalDiseaseRecord
     */
    select?: OccupationalDiseaseRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OccupationalDiseaseRecord
     */
    omit?: OccupationalDiseaseRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccupationalDiseaseRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a OccupationalDiseaseRecord.
     */
    data: XOR<OccupationalDiseaseRecordCreateInput, OccupationalDiseaseRecordUncheckedCreateInput>
  }

  /**
   * OccupationalDiseaseRecord createMany
   */
  export type OccupationalDiseaseRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OccupationalDiseaseRecords.
     */
    data: OccupationalDiseaseRecordCreateManyInput | OccupationalDiseaseRecordCreateManyInput[]
  }

  /**
   * OccupationalDiseaseRecord createManyAndReturn
   */
  export type OccupationalDiseaseRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OccupationalDiseaseRecord
     */
    select?: OccupationalDiseaseRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OccupationalDiseaseRecord
     */
    omit?: OccupationalDiseaseRecordOmit<ExtArgs> | null
    /**
     * The data used to create many OccupationalDiseaseRecords.
     */
    data: OccupationalDiseaseRecordCreateManyInput | OccupationalDiseaseRecordCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccupationalDiseaseRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OccupationalDiseaseRecord update
   */
  export type OccupationalDiseaseRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OccupationalDiseaseRecord
     */
    select?: OccupationalDiseaseRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OccupationalDiseaseRecord
     */
    omit?: OccupationalDiseaseRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccupationalDiseaseRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a OccupationalDiseaseRecord.
     */
    data: XOR<OccupationalDiseaseRecordUpdateInput, OccupationalDiseaseRecordUncheckedUpdateInput>
    /**
     * Choose, which OccupationalDiseaseRecord to update.
     */
    where: OccupationalDiseaseRecordWhereUniqueInput
  }

  /**
   * OccupationalDiseaseRecord updateMany
   */
  export type OccupationalDiseaseRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OccupationalDiseaseRecords.
     */
    data: XOR<OccupationalDiseaseRecordUpdateManyMutationInput, OccupationalDiseaseRecordUncheckedUpdateManyInput>
    /**
     * Filter which OccupationalDiseaseRecords to update
     */
    where?: OccupationalDiseaseRecordWhereInput
    /**
     * Limit how many OccupationalDiseaseRecords to update.
     */
    limit?: number
  }

  /**
   * OccupationalDiseaseRecord updateManyAndReturn
   */
  export type OccupationalDiseaseRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OccupationalDiseaseRecord
     */
    select?: OccupationalDiseaseRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OccupationalDiseaseRecord
     */
    omit?: OccupationalDiseaseRecordOmit<ExtArgs> | null
    /**
     * The data used to update OccupationalDiseaseRecords.
     */
    data: XOR<OccupationalDiseaseRecordUpdateManyMutationInput, OccupationalDiseaseRecordUncheckedUpdateManyInput>
    /**
     * Filter which OccupationalDiseaseRecords to update
     */
    where?: OccupationalDiseaseRecordWhereInput
    /**
     * Limit how many OccupationalDiseaseRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccupationalDiseaseRecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OccupationalDiseaseRecord upsert
   */
  export type OccupationalDiseaseRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OccupationalDiseaseRecord
     */
    select?: OccupationalDiseaseRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OccupationalDiseaseRecord
     */
    omit?: OccupationalDiseaseRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccupationalDiseaseRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the OccupationalDiseaseRecord to update in case it exists.
     */
    where: OccupationalDiseaseRecordWhereUniqueInput
    /**
     * In case the OccupationalDiseaseRecord found by the `where` argument doesn't exist, create a new OccupationalDiseaseRecord with this data.
     */
    create: XOR<OccupationalDiseaseRecordCreateInput, OccupationalDiseaseRecordUncheckedCreateInput>
    /**
     * In case the OccupationalDiseaseRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OccupationalDiseaseRecordUpdateInput, OccupationalDiseaseRecordUncheckedUpdateInput>
  }

  /**
   * OccupationalDiseaseRecord delete
   */
  export type OccupationalDiseaseRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OccupationalDiseaseRecord
     */
    select?: OccupationalDiseaseRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OccupationalDiseaseRecord
     */
    omit?: OccupationalDiseaseRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccupationalDiseaseRecordInclude<ExtArgs> | null
    /**
     * Filter which OccupationalDiseaseRecord to delete.
     */
    where: OccupationalDiseaseRecordWhereUniqueInput
  }

  /**
   * OccupationalDiseaseRecord deleteMany
   */
  export type OccupationalDiseaseRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OccupationalDiseaseRecords to delete
     */
    where?: OccupationalDiseaseRecordWhereInput
    /**
     * Limit how many OccupationalDiseaseRecords to delete.
     */
    limit?: number
  }

  /**
   * OccupationalDiseaseRecord without action
   */
  export type OccupationalDiseaseRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OccupationalDiseaseRecord
     */
    select?: OccupationalDiseaseRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OccupationalDiseaseRecord
     */
    omit?: OccupationalDiseaseRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccupationalDiseaseRecordInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const EmployeeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    department: 'department',
    position: 'position',
    hireDate: 'hireDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmployeeScalarFieldEnum = (typeof EmployeeScalarFieldEnum)[keyof typeof EmployeeScalarFieldEnum]


  export const TrainingTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    validityMonths: 'validityMonths',
    requiredNrsJson: 'requiredNrsJson',
    defaultDuration: 'defaultDuration',
    defaultLocation: 'defaultLocation',
    defaultCost: 'defaultCost',
    instructorsJson: 'instructorsJson',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TrainingTypeScalarFieldEnum = (typeof TrainingTypeScalarFieldEnum)[keyof typeof TrainingTypeScalarFieldEnum]


  export const TrainingRecordScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    trainingTypeId: 'trainingTypeId',
    trainingDate: 'trainingDate',
    expiryDate: 'expiryDate',
    status: 'status',
    attendanceListUrl: 'attendanceListUrl',
    certificateUrl: 'certificateUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TrainingRecordScalarFieldEnum = (typeof TrainingRecordScalarFieldEnum)[keyof typeof TrainingRecordScalarFieldEnum]


  export const PpeRecordScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    ppeType: 'ppeType',
    caNumber: 'caNumber',
    deliveryDate: 'deliveryDate',
    quantity: 'quantity',
    returnDate: 'returnDate',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PpeRecordScalarFieldEnum = (typeof PpeRecordScalarFieldEnum)[keyof typeof PpeRecordScalarFieldEnum]


  export const AsoRecordScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    examType: 'examType',
    examDate: 'examDate',
    expiryDate: 'expiryDate',
    result: 'result',
    status: 'status',
    attachmentUrl: 'attachmentUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AsoRecordScalarFieldEnum = (typeof AsoRecordScalarFieldEnum)[keyof typeof AsoRecordScalarFieldEnum]


  export const ChemicalRecordScalarFieldEnum: {
    id: 'id',
    productName: 'productName',
    casNumber: 'casNumber',
    location: 'location',
    quantity: 'quantity',
    unit: 'unit',
    sdsUrl: 'sdsUrl',
    lastUpdated: 'lastUpdated',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChemicalRecordScalarFieldEnum = (typeof ChemicalRecordScalarFieldEnum)[keyof typeof ChemicalRecordScalarFieldEnum]


  export const JsaRecordScalarFieldEnum: {
    id: 'id',
    taskName: 'taskName',
    department: 'department',
    analysisDate: 'analysisDate',
    reviewDate: 'reviewDate',
    status: 'status',
    attachmentUrl: 'attachmentUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type JsaRecordScalarFieldEnum = (typeof JsaRecordScalarFieldEnum)[keyof typeof JsaRecordScalarFieldEnum]


  export const RiskItemScalarFieldEnum: {
    id: 'id',
    jsaId: 'jsaId',
    description: 'description',
    controls: 'controls',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RiskItemScalarFieldEnum = (typeof RiskItemScalarFieldEnum)[keyof typeof RiskItemScalarFieldEnum]


  export const CipaMeetingScalarFieldEnum: {
    id: 'id',
    date: 'date',
    participantsJson: 'participantsJson',
    agenda: 'agenda',
    status: 'status',
    minutesUrl: 'minutesUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CipaMeetingScalarFieldEnum = (typeof CipaMeetingScalarFieldEnum)[keyof typeof CipaMeetingScalarFieldEnum]


  export const CipaActionScalarFieldEnum: {
    id: 'id',
    description: 'description',
    responsible: 'responsible',
    deadline: 'deadline',
    status: 'status',
    meetingId: 'meetingId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CipaActionScalarFieldEnum = (typeof CipaActionScalarFieldEnum)[keyof typeof CipaActionScalarFieldEnum]


  export const PreventiveActionScalarFieldEnum: {
    id: 'id',
    description: 'description',
    category: 'category',
    responsible: 'responsible',
    frequency: 'frequency',
    dueDate: 'dueDate',
    lastCompletedDate: 'lastCompletedDate',
    status: 'status',
    evidenceUrl: 'evidenceUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PreventiveActionScalarFieldEnum = (typeof PreventiveActionScalarFieldEnum)[keyof typeof PreventiveActionScalarFieldEnum]


  export const DocumentRecordScalarFieldEnum: {
    id: 'id',
    documentType: 'documentType',
    title: 'title',
    issueDate: 'issueDate',
    expiryDate: 'expiryDate',
    responsible: 'responsible',
    status: 'status',
    attachmentUrl: 'attachmentUrl',
    observations: 'observations',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DocumentRecordScalarFieldEnum = (typeof DocumentRecordScalarFieldEnum)[keyof typeof DocumentRecordScalarFieldEnum]


  export const DocumentActionScalarFieldEnum: {
    id: 'id',
    description: 'description',
    responsible: 'responsible',
    deadline: 'deadline',
    status: 'status',
    documentId: 'documentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DocumentActionScalarFieldEnum = (typeof DocumentActionScalarFieldEnum)[keyof typeof DocumentActionScalarFieldEnum]


  export const LawsuitRecordScalarFieldEnum: {
    id: 'id',
    processNumber: 'processNumber',
    plaintiff: 'plaintiff',
    subject: 'subject',
    status: 'status',
    filingDate: 'filingDate',
    hearingDate: 'hearingDate',
    estimatedCost: 'estimatedCost',
    finalCost: 'finalCost',
    lawyer: 'lawyer',
    details: 'details',
    relatedNRsJson: 'relatedNRsJson',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LawsuitRecordScalarFieldEnum = (typeof LawsuitRecordScalarFieldEnum)[keyof typeof LawsuitRecordScalarFieldEnum]


  export const AccidentRecordScalarFieldEnum: {
    id: 'id',
    date: 'date',
    time: 'time',
    employeeId: 'employeeId',
    department: 'department',
    location: 'location',
    type: 'type',
    cause: 'cause',
    causeDetails: 'causeDetails',
    daysOff: 'daysOff',
    description: 'description',
    cid10Code: 'cid10Code',
    catIssued: 'catIssued',
    investigationStatus: 'investigationStatus',
    reportUrl: 'reportUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccidentRecordScalarFieldEnum = (typeof AccidentRecordScalarFieldEnum)[keyof typeof AccidentRecordScalarFieldEnum]


  export const OccupationalDiseaseRecordScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    diseaseType: 'diseaseType',
    cid10Code: 'cid10Code',
    diagnosisDate: 'diagnosisDate',
    relatedTask: 'relatedTask',
    daysOff: 'daysOff',
    status: 'status',
    medicalReportUrl: 'medicalReportUrl',
    pcmsoLink: 'pcmsoLink',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OccupationalDiseaseRecordScalarFieldEnum = (typeof OccupationalDiseaseRecordScalarFieldEnum)[keyof typeof OccupationalDiseaseRecordScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type EmployeeWhereInput = {
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    id?: StringFilter<"Employee"> | string
    name?: StringFilter<"Employee"> | string
    department?: StringNullableFilter<"Employee"> | string | null
    position?: StringNullableFilter<"Employee"> | string | null
    hireDate?: DateTimeNullableFilter<"Employee"> | Date | string | null
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    ppeRecords?: PpeRecordListRelationFilter
    asoRecords?: AsoRecordListRelationFilter
    trainings?: TrainingRecordListRelationFilter
    accidents?: AccidentRecordListRelationFilter
    diseases?: OccupationalDiseaseRecordListRelationFilter
  }

  export type EmployeeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    department?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    hireDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ppeRecords?: PpeRecordOrderByRelationAggregateInput
    asoRecords?: AsoRecordOrderByRelationAggregateInput
    trainings?: TrainingRecordOrderByRelationAggregateInput
    accidents?: AccidentRecordOrderByRelationAggregateInput
    diseases?: OccupationalDiseaseRecordOrderByRelationAggregateInput
  }

  export type EmployeeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    name?: StringFilter<"Employee"> | string
    department?: StringNullableFilter<"Employee"> | string | null
    position?: StringNullableFilter<"Employee"> | string | null
    hireDate?: DateTimeNullableFilter<"Employee"> | Date | string | null
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    ppeRecords?: PpeRecordListRelationFilter
    asoRecords?: AsoRecordListRelationFilter
    trainings?: TrainingRecordListRelationFilter
    accidents?: AccidentRecordListRelationFilter
    diseases?: OccupationalDiseaseRecordListRelationFilter
  }, "id">

  export type EmployeeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    department?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    hireDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmployeeCountOrderByAggregateInput
    _max?: EmployeeMaxOrderByAggregateInput
    _min?: EmployeeMinOrderByAggregateInput
  }

  export type EmployeeScalarWhereWithAggregatesInput = {
    AND?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    OR?: EmployeeScalarWhereWithAggregatesInput[]
    NOT?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Employee"> | string
    name?: StringWithAggregatesFilter<"Employee"> | string
    department?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    position?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    hireDate?: DateTimeNullableWithAggregatesFilter<"Employee"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
  }

  export type TrainingTypeWhereInput = {
    AND?: TrainingTypeWhereInput | TrainingTypeWhereInput[]
    OR?: TrainingTypeWhereInput[]
    NOT?: TrainingTypeWhereInput | TrainingTypeWhereInput[]
    id?: StringFilter<"TrainingType"> | string
    name?: StringFilter<"TrainingType"> | string
    description?: StringNullableFilter<"TrainingType"> | string | null
    validityMonths?: IntNullableFilter<"TrainingType"> | number | null
    requiredNrsJson?: StringNullableFilter<"TrainingType"> | string | null
    defaultDuration?: IntNullableFilter<"TrainingType"> | number | null
    defaultLocation?: StringNullableFilter<"TrainingType"> | string | null
    defaultCost?: FloatNullableFilter<"TrainingType"> | number | null
    instructorsJson?: StringNullableFilter<"TrainingType"> | string | null
    createdAt?: DateTimeFilter<"TrainingType"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingType"> | Date | string
    trainingRecords?: TrainingRecordListRelationFilter
  }

  export type TrainingTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    validityMonths?: SortOrderInput | SortOrder
    requiredNrsJson?: SortOrderInput | SortOrder
    defaultDuration?: SortOrderInput | SortOrder
    defaultLocation?: SortOrderInput | SortOrder
    defaultCost?: SortOrderInput | SortOrder
    instructorsJson?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    trainingRecords?: TrainingRecordOrderByRelationAggregateInput
  }

  export type TrainingTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: TrainingTypeWhereInput | TrainingTypeWhereInput[]
    OR?: TrainingTypeWhereInput[]
    NOT?: TrainingTypeWhereInput | TrainingTypeWhereInput[]
    description?: StringNullableFilter<"TrainingType"> | string | null
    validityMonths?: IntNullableFilter<"TrainingType"> | number | null
    requiredNrsJson?: StringNullableFilter<"TrainingType"> | string | null
    defaultDuration?: IntNullableFilter<"TrainingType"> | number | null
    defaultLocation?: StringNullableFilter<"TrainingType"> | string | null
    defaultCost?: FloatNullableFilter<"TrainingType"> | number | null
    instructorsJson?: StringNullableFilter<"TrainingType"> | string | null
    createdAt?: DateTimeFilter<"TrainingType"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingType"> | Date | string
    trainingRecords?: TrainingRecordListRelationFilter
  }, "id" | "name">

  export type TrainingTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    validityMonths?: SortOrderInput | SortOrder
    requiredNrsJson?: SortOrderInput | SortOrder
    defaultDuration?: SortOrderInput | SortOrder
    defaultLocation?: SortOrderInput | SortOrder
    defaultCost?: SortOrderInput | SortOrder
    instructorsJson?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TrainingTypeCountOrderByAggregateInput
    _avg?: TrainingTypeAvgOrderByAggregateInput
    _max?: TrainingTypeMaxOrderByAggregateInput
    _min?: TrainingTypeMinOrderByAggregateInput
    _sum?: TrainingTypeSumOrderByAggregateInput
  }

  export type TrainingTypeScalarWhereWithAggregatesInput = {
    AND?: TrainingTypeScalarWhereWithAggregatesInput | TrainingTypeScalarWhereWithAggregatesInput[]
    OR?: TrainingTypeScalarWhereWithAggregatesInput[]
    NOT?: TrainingTypeScalarWhereWithAggregatesInput | TrainingTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrainingType"> | string
    name?: StringWithAggregatesFilter<"TrainingType"> | string
    description?: StringNullableWithAggregatesFilter<"TrainingType"> | string | null
    validityMonths?: IntNullableWithAggregatesFilter<"TrainingType"> | number | null
    requiredNrsJson?: StringNullableWithAggregatesFilter<"TrainingType"> | string | null
    defaultDuration?: IntNullableWithAggregatesFilter<"TrainingType"> | number | null
    defaultLocation?: StringNullableWithAggregatesFilter<"TrainingType"> | string | null
    defaultCost?: FloatNullableWithAggregatesFilter<"TrainingType"> | number | null
    instructorsJson?: StringNullableWithAggregatesFilter<"TrainingType"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TrainingType"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TrainingType"> | Date | string
  }

  export type TrainingRecordWhereInput = {
    AND?: TrainingRecordWhereInput | TrainingRecordWhereInput[]
    OR?: TrainingRecordWhereInput[]
    NOT?: TrainingRecordWhereInput | TrainingRecordWhereInput[]
    id?: StringFilter<"TrainingRecord"> | string
    employeeId?: StringFilter<"TrainingRecord"> | string
    trainingTypeId?: StringFilter<"TrainingRecord"> | string
    trainingDate?: DateTimeFilter<"TrainingRecord"> | Date | string
    expiryDate?: DateTimeNullableFilter<"TrainingRecord"> | Date | string | null
    status?: StringFilter<"TrainingRecord"> | string
    attendanceListUrl?: StringNullableFilter<"TrainingRecord"> | string | null
    certificateUrl?: StringNullableFilter<"TrainingRecord"> | string | null
    createdAt?: DateTimeFilter<"TrainingRecord"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingRecord"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    trainingType?: XOR<TrainingTypeScalarRelationFilter, TrainingTypeWhereInput>
  }

  export type TrainingRecordOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    trainingTypeId?: SortOrder
    trainingDate?: SortOrder
    expiryDate?: SortOrderInput | SortOrder
    status?: SortOrder
    attendanceListUrl?: SortOrderInput | SortOrder
    certificateUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
    trainingType?: TrainingTypeOrderByWithRelationInput
  }

  export type TrainingRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TrainingRecordWhereInput | TrainingRecordWhereInput[]
    OR?: TrainingRecordWhereInput[]
    NOT?: TrainingRecordWhereInput | TrainingRecordWhereInput[]
    employeeId?: StringFilter<"TrainingRecord"> | string
    trainingTypeId?: StringFilter<"TrainingRecord"> | string
    trainingDate?: DateTimeFilter<"TrainingRecord"> | Date | string
    expiryDate?: DateTimeNullableFilter<"TrainingRecord"> | Date | string | null
    status?: StringFilter<"TrainingRecord"> | string
    attendanceListUrl?: StringNullableFilter<"TrainingRecord"> | string | null
    certificateUrl?: StringNullableFilter<"TrainingRecord"> | string | null
    createdAt?: DateTimeFilter<"TrainingRecord"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingRecord"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    trainingType?: XOR<TrainingTypeScalarRelationFilter, TrainingTypeWhereInput>
  }, "id">

  export type TrainingRecordOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    trainingTypeId?: SortOrder
    trainingDate?: SortOrder
    expiryDate?: SortOrderInput | SortOrder
    status?: SortOrder
    attendanceListUrl?: SortOrderInput | SortOrder
    certificateUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TrainingRecordCountOrderByAggregateInput
    _max?: TrainingRecordMaxOrderByAggregateInput
    _min?: TrainingRecordMinOrderByAggregateInput
  }

  export type TrainingRecordScalarWhereWithAggregatesInput = {
    AND?: TrainingRecordScalarWhereWithAggregatesInput | TrainingRecordScalarWhereWithAggregatesInput[]
    OR?: TrainingRecordScalarWhereWithAggregatesInput[]
    NOT?: TrainingRecordScalarWhereWithAggregatesInput | TrainingRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrainingRecord"> | string
    employeeId?: StringWithAggregatesFilter<"TrainingRecord"> | string
    trainingTypeId?: StringWithAggregatesFilter<"TrainingRecord"> | string
    trainingDate?: DateTimeWithAggregatesFilter<"TrainingRecord"> | Date | string
    expiryDate?: DateTimeNullableWithAggregatesFilter<"TrainingRecord"> | Date | string | null
    status?: StringWithAggregatesFilter<"TrainingRecord"> | string
    attendanceListUrl?: StringNullableWithAggregatesFilter<"TrainingRecord"> | string | null
    certificateUrl?: StringNullableWithAggregatesFilter<"TrainingRecord"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TrainingRecord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TrainingRecord"> | Date | string
  }

  export type PpeRecordWhereInput = {
    AND?: PpeRecordWhereInput | PpeRecordWhereInput[]
    OR?: PpeRecordWhereInput[]
    NOT?: PpeRecordWhereInput | PpeRecordWhereInput[]
    id?: StringFilter<"PpeRecord"> | string
    employeeId?: StringFilter<"PpeRecord"> | string
    ppeType?: StringFilter<"PpeRecord"> | string
    caNumber?: StringNullableFilter<"PpeRecord"> | string | null
    deliveryDate?: DateTimeFilter<"PpeRecord"> | Date | string
    quantity?: IntFilter<"PpeRecord"> | number
    returnDate?: DateTimeNullableFilter<"PpeRecord"> | Date | string | null
    status?: StringFilter<"PpeRecord"> | string
    createdAt?: DateTimeFilter<"PpeRecord"> | Date | string
    updatedAt?: DateTimeFilter<"PpeRecord"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }

  export type PpeRecordOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    ppeType?: SortOrder
    caNumber?: SortOrderInput | SortOrder
    deliveryDate?: SortOrder
    quantity?: SortOrder
    returnDate?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
  }

  export type PpeRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PpeRecordWhereInput | PpeRecordWhereInput[]
    OR?: PpeRecordWhereInput[]
    NOT?: PpeRecordWhereInput | PpeRecordWhereInput[]
    employeeId?: StringFilter<"PpeRecord"> | string
    ppeType?: StringFilter<"PpeRecord"> | string
    caNumber?: StringNullableFilter<"PpeRecord"> | string | null
    deliveryDate?: DateTimeFilter<"PpeRecord"> | Date | string
    quantity?: IntFilter<"PpeRecord"> | number
    returnDate?: DateTimeNullableFilter<"PpeRecord"> | Date | string | null
    status?: StringFilter<"PpeRecord"> | string
    createdAt?: DateTimeFilter<"PpeRecord"> | Date | string
    updatedAt?: DateTimeFilter<"PpeRecord"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }, "id">

  export type PpeRecordOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    ppeType?: SortOrder
    caNumber?: SortOrderInput | SortOrder
    deliveryDate?: SortOrder
    quantity?: SortOrder
    returnDate?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PpeRecordCountOrderByAggregateInput
    _avg?: PpeRecordAvgOrderByAggregateInput
    _max?: PpeRecordMaxOrderByAggregateInput
    _min?: PpeRecordMinOrderByAggregateInput
    _sum?: PpeRecordSumOrderByAggregateInput
  }

  export type PpeRecordScalarWhereWithAggregatesInput = {
    AND?: PpeRecordScalarWhereWithAggregatesInput | PpeRecordScalarWhereWithAggregatesInput[]
    OR?: PpeRecordScalarWhereWithAggregatesInput[]
    NOT?: PpeRecordScalarWhereWithAggregatesInput | PpeRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PpeRecord"> | string
    employeeId?: StringWithAggregatesFilter<"PpeRecord"> | string
    ppeType?: StringWithAggregatesFilter<"PpeRecord"> | string
    caNumber?: StringNullableWithAggregatesFilter<"PpeRecord"> | string | null
    deliveryDate?: DateTimeWithAggregatesFilter<"PpeRecord"> | Date | string
    quantity?: IntWithAggregatesFilter<"PpeRecord"> | number
    returnDate?: DateTimeNullableWithAggregatesFilter<"PpeRecord"> | Date | string | null
    status?: StringWithAggregatesFilter<"PpeRecord"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PpeRecord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PpeRecord"> | Date | string
  }

  export type AsoRecordWhereInput = {
    AND?: AsoRecordWhereInput | AsoRecordWhereInput[]
    OR?: AsoRecordWhereInput[]
    NOT?: AsoRecordWhereInput | AsoRecordWhereInput[]
    id?: StringFilter<"AsoRecord"> | string
    employeeId?: StringFilter<"AsoRecord"> | string
    examType?: StringFilter<"AsoRecord"> | string
    examDate?: DateTimeFilter<"AsoRecord"> | Date | string
    expiryDate?: DateTimeFilter<"AsoRecord"> | Date | string
    result?: StringFilter<"AsoRecord"> | string
    status?: StringFilter<"AsoRecord"> | string
    attachmentUrl?: StringNullableFilter<"AsoRecord"> | string | null
    createdAt?: DateTimeFilter<"AsoRecord"> | Date | string
    updatedAt?: DateTimeFilter<"AsoRecord"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }

  export type AsoRecordOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    examType?: SortOrder
    examDate?: SortOrder
    expiryDate?: SortOrder
    result?: SortOrder
    status?: SortOrder
    attachmentUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
  }

  export type AsoRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AsoRecordWhereInput | AsoRecordWhereInput[]
    OR?: AsoRecordWhereInput[]
    NOT?: AsoRecordWhereInput | AsoRecordWhereInput[]
    employeeId?: StringFilter<"AsoRecord"> | string
    examType?: StringFilter<"AsoRecord"> | string
    examDate?: DateTimeFilter<"AsoRecord"> | Date | string
    expiryDate?: DateTimeFilter<"AsoRecord"> | Date | string
    result?: StringFilter<"AsoRecord"> | string
    status?: StringFilter<"AsoRecord"> | string
    attachmentUrl?: StringNullableFilter<"AsoRecord"> | string | null
    createdAt?: DateTimeFilter<"AsoRecord"> | Date | string
    updatedAt?: DateTimeFilter<"AsoRecord"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }, "id">

  export type AsoRecordOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    examType?: SortOrder
    examDate?: SortOrder
    expiryDate?: SortOrder
    result?: SortOrder
    status?: SortOrder
    attachmentUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AsoRecordCountOrderByAggregateInput
    _max?: AsoRecordMaxOrderByAggregateInput
    _min?: AsoRecordMinOrderByAggregateInput
  }

  export type AsoRecordScalarWhereWithAggregatesInput = {
    AND?: AsoRecordScalarWhereWithAggregatesInput | AsoRecordScalarWhereWithAggregatesInput[]
    OR?: AsoRecordScalarWhereWithAggregatesInput[]
    NOT?: AsoRecordScalarWhereWithAggregatesInput | AsoRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AsoRecord"> | string
    employeeId?: StringWithAggregatesFilter<"AsoRecord"> | string
    examType?: StringWithAggregatesFilter<"AsoRecord"> | string
    examDate?: DateTimeWithAggregatesFilter<"AsoRecord"> | Date | string
    expiryDate?: DateTimeWithAggregatesFilter<"AsoRecord"> | Date | string
    result?: StringWithAggregatesFilter<"AsoRecord"> | string
    status?: StringWithAggregatesFilter<"AsoRecord"> | string
    attachmentUrl?: StringNullableWithAggregatesFilter<"AsoRecord"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AsoRecord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AsoRecord"> | Date | string
  }

  export type ChemicalRecordWhereInput = {
    AND?: ChemicalRecordWhereInput | ChemicalRecordWhereInput[]
    OR?: ChemicalRecordWhereInput[]
    NOT?: ChemicalRecordWhereInput | ChemicalRecordWhereInput[]
    id?: StringFilter<"ChemicalRecord"> | string
    productName?: StringFilter<"ChemicalRecord"> | string
    casNumber?: StringNullableFilter<"ChemicalRecord"> | string | null
    location?: StringFilter<"ChemicalRecord"> | string
    quantity?: FloatFilter<"ChemicalRecord"> | number
    unit?: StringFilter<"ChemicalRecord"> | string
    sdsUrl?: StringNullableFilter<"ChemicalRecord"> | string | null
    lastUpdated?: DateTimeFilter<"ChemicalRecord"> | Date | string
    createdAt?: DateTimeFilter<"ChemicalRecord"> | Date | string
    updatedAt?: DateTimeFilter<"ChemicalRecord"> | Date | string
  }

  export type ChemicalRecordOrderByWithRelationInput = {
    id?: SortOrder
    productName?: SortOrder
    casNumber?: SortOrderInput | SortOrder
    location?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    sdsUrl?: SortOrderInput | SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChemicalRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChemicalRecordWhereInput | ChemicalRecordWhereInput[]
    OR?: ChemicalRecordWhereInput[]
    NOT?: ChemicalRecordWhereInput | ChemicalRecordWhereInput[]
    productName?: StringFilter<"ChemicalRecord"> | string
    casNumber?: StringNullableFilter<"ChemicalRecord"> | string | null
    location?: StringFilter<"ChemicalRecord"> | string
    quantity?: FloatFilter<"ChemicalRecord"> | number
    unit?: StringFilter<"ChemicalRecord"> | string
    sdsUrl?: StringNullableFilter<"ChemicalRecord"> | string | null
    lastUpdated?: DateTimeFilter<"ChemicalRecord"> | Date | string
    createdAt?: DateTimeFilter<"ChemicalRecord"> | Date | string
    updatedAt?: DateTimeFilter<"ChemicalRecord"> | Date | string
  }, "id">

  export type ChemicalRecordOrderByWithAggregationInput = {
    id?: SortOrder
    productName?: SortOrder
    casNumber?: SortOrderInput | SortOrder
    location?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    sdsUrl?: SortOrderInput | SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChemicalRecordCountOrderByAggregateInput
    _avg?: ChemicalRecordAvgOrderByAggregateInput
    _max?: ChemicalRecordMaxOrderByAggregateInput
    _min?: ChemicalRecordMinOrderByAggregateInput
    _sum?: ChemicalRecordSumOrderByAggregateInput
  }

  export type ChemicalRecordScalarWhereWithAggregatesInput = {
    AND?: ChemicalRecordScalarWhereWithAggregatesInput | ChemicalRecordScalarWhereWithAggregatesInput[]
    OR?: ChemicalRecordScalarWhereWithAggregatesInput[]
    NOT?: ChemicalRecordScalarWhereWithAggregatesInput | ChemicalRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChemicalRecord"> | string
    productName?: StringWithAggregatesFilter<"ChemicalRecord"> | string
    casNumber?: StringNullableWithAggregatesFilter<"ChemicalRecord"> | string | null
    location?: StringWithAggregatesFilter<"ChemicalRecord"> | string
    quantity?: FloatWithAggregatesFilter<"ChemicalRecord"> | number
    unit?: StringWithAggregatesFilter<"ChemicalRecord"> | string
    sdsUrl?: StringNullableWithAggregatesFilter<"ChemicalRecord"> | string | null
    lastUpdated?: DateTimeWithAggregatesFilter<"ChemicalRecord"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"ChemicalRecord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChemicalRecord"> | Date | string
  }

  export type JsaRecordWhereInput = {
    AND?: JsaRecordWhereInput | JsaRecordWhereInput[]
    OR?: JsaRecordWhereInput[]
    NOT?: JsaRecordWhereInput | JsaRecordWhereInput[]
    id?: StringFilter<"JsaRecord"> | string
    taskName?: StringFilter<"JsaRecord"> | string
    department?: StringFilter<"JsaRecord"> | string
    analysisDate?: DateTimeFilter<"JsaRecord"> | Date | string
    reviewDate?: DateTimeNullableFilter<"JsaRecord"> | Date | string | null
    status?: StringFilter<"JsaRecord"> | string
    attachmentUrl?: StringNullableFilter<"JsaRecord"> | string | null
    createdAt?: DateTimeFilter<"JsaRecord"> | Date | string
    updatedAt?: DateTimeFilter<"JsaRecord"> | Date | string
    risks?: RiskItemListRelationFilter
  }

  export type JsaRecordOrderByWithRelationInput = {
    id?: SortOrder
    taskName?: SortOrder
    department?: SortOrder
    analysisDate?: SortOrder
    reviewDate?: SortOrderInput | SortOrder
    status?: SortOrder
    attachmentUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    risks?: RiskItemOrderByRelationAggregateInput
  }

  export type JsaRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JsaRecordWhereInput | JsaRecordWhereInput[]
    OR?: JsaRecordWhereInput[]
    NOT?: JsaRecordWhereInput | JsaRecordWhereInput[]
    taskName?: StringFilter<"JsaRecord"> | string
    department?: StringFilter<"JsaRecord"> | string
    analysisDate?: DateTimeFilter<"JsaRecord"> | Date | string
    reviewDate?: DateTimeNullableFilter<"JsaRecord"> | Date | string | null
    status?: StringFilter<"JsaRecord"> | string
    attachmentUrl?: StringNullableFilter<"JsaRecord"> | string | null
    createdAt?: DateTimeFilter<"JsaRecord"> | Date | string
    updatedAt?: DateTimeFilter<"JsaRecord"> | Date | string
    risks?: RiskItemListRelationFilter
  }, "id">

  export type JsaRecordOrderByWithAggregationInput = {
    id?: SortOrder
    taskName?: SortOrder
    department?: SortOrder
    analysisDate?: SortOrder
    reviewDate?: SortOrderInput | SortOrder
    status?: SortOrder
    attachmentUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: JsaRecordCountOrderByAggregateInput
    _max?: JsaRecordMaxOrderByAggregateInput
    _min?: JsaRecordMinOrderByAggregateInput
  }

  export type JsaRecordScalarWhereWithAggregatesInput = {
    AND?: JsaRecordScalarWhereWithAggregatesInput | JsaRecordScalarWhereWithAggregatesInput[]
    OR?: JsaRecordScalarWhereWithAggregatesInput[]
    NOT?: JsaRecordScalarWhereWithAggregatesInput | JsaRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JsaRecord"> | string
    taskName?: StringWithAggregatesFilter<"JsaRecord"> | string
    department?: StringWithAggregatesFilter<"JsaRecord"> | string
    analysisDate?: DateTimeWithAggregatesFilter<"JsaRecord"> | Date | string
    reviewDate?: DateTimeNullableWithAggregatesFilter<"JsaRecord"> | Date | string | null
    status?: StringWithAggregatesFilter<"JsaRecord"> | string
    attachmentUrl?: StringNullableWithAggregatesFilter<"JsaRecord"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"JsaRecord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"JsaRecord"> | Date | string
  }

  export type RiskItemWhereInput = {
    AND?: RiskItemWhereInput | RiskItemWhereInput[]
    OR?: RiskItemWhereInput[]
    NOT?: RiskItemWhereInput | RiskItemWhereInput[]
    id?: StringFilter<"RiskItem"> | string
    jsaId?: StringFilter<"RiskItem"> | string
    description?: StringFilter<"RiskItem"> | string
    controls?: StringFilter<"RiskItem"> | string
    createdAt?: DateTimeFilter<"RiskItem"> | Date | string
    updatedAt?: DateTimeFilter<"RiskItem"> | Date | string
    jsa?: XOR<JsaRecordScalarRelationFilter, JsaRecordWhereInput>
  }

  export type RiskItemOrderByWithRelationInput = {
    id?: SortOrder
    jsaId?: SortOrder
    description?: SortOrder
    controls?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    jsa?: JsaRecordOrderByWithRelationInput
  }

  export type RiskItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RiskItemWhereInput | RiskItemWhereInput[]
    OR?: RiskItemWhereInput[]
    NOT?: RiskItemWhereInput | RiskItemWhereInput[]
    jsaId?: StringFilter<"RiskItem"> | string
    description?: StringFilter<"RiskItem"> | string
    controls?: StringFilter<"RiskItem"> | string
    createdAt?: DateTimeFilter<"RiskItem"> | Date | string
    updatedAt?: DateTimeFilter<"RiskItem"> | Date | string
    jsa?: XOR<JsaRecordScalarRelationFilter, JsaRecordWhereInput>
  }, "id">

  export type RiskItemOrderByWithAggregationInput = {
    id?: SortOrder
    jsaId?: SortOrder
    description?: SortOrder
    controls?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RiskItemCountOrderByAggregateInput
    _max?: RiskItemMaxOrderByAggregateInput
    _min?: RiskItemMinOrderByAggregateInput
  }

  export type RiskItemScalarWhereWithAggregatesInput = {
    AND?: RiskItemScalarWhereWithAggregatesInput | RiskItemScalarWhereWithAggregatesInput[]
    OR?: RiskItemScalarWhereWithAggregatesInput[]
    NOT?: RiskItemScalarWhereWithAggregatesInput | RiskItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RiskItem"> | string
    jsaId?: StringWithAggregatesFilter<"RiskItem"> | string
    description?: StringWithAggregatesFilter<"RiskItem"> | string
    controls?: StringWithAggregatesFilter<"RiskItem"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RiskItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RiskItem"> | Date | string
  }

  export type CipaMeetingWhereInput = {
    AND?: CipaMeetingWhereInput | CipaMeetingWhereInput[]
    OR?: CipaMeetingWhereInput[]
    NOT?: CipaMeetingWhereInput | CipaMeetingWhereInput[]
    id?: StringFilter<"CipaMeeting"> | string
    date?: DateTimeFilter<"CipaMeeting"> | Date | string
    participantsJson?: StringNullableFilter<"CipaMeeting"> | string | null
    agenda?: StringFilter<"CipaMeeting"> | string
    status?: StringFilter<"CipaMeeting"> | string
    minutesUrl?: StringNullableFilter<"CipaMeeting"> | string | null
    createdAt?: DateTimeFilter<"CipaMeeting"> | Date | string
    updatedAt?: DateTimeFilter<"CipaMeeting"> | Date | string
    actionsDefined?: CipaActionListRelationFilter
  }

  export type CipaMeetingOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    participantsJson?: SortOrderInput | SortOrder
    agenda?: SortOrder
    status?: SortOrder
    minutesUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    actionsDefined?: CipaActionOrderByRelationAggregateInput
  }

  export type CipaMeetingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CipaMeetingWhereInput | CipaMeetingWhereInput[]
    OR?: CipaMeetingWhereInput[]
    NOT?: CipaMeetingWhereInput | CipaMeetingWhereInput[]
    date?: DateTimeFilter<"CipaMeeting"> | Date | string
    participantsJson?: StringNullableFilter<"CipaMeeting"> | string | null
    agenda?: StringFilter<"CipaMeeting"> | string
    status?: StringFilter<"CipaMeeting"> | string
    minutesUrl?: StringNullableFilter<"CipaMeeting"> | string | null
    createdAt?: DateTimeFilter<"CipaMeeting"> | Date | string
    updatedAt?: DateTimeFilter<"CipaMeeting"> | Date | string
    actionsDefined?: CipaActionListRelationFilter
  }, "id">

  export type CipaMeetingOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    participantsJson?: SortOrderInput | SortOrder
    agenda?: SortOrder
    status?: SortOrder
    minutesUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CipaMeetingCountOrderByAggregateInput
    _max?: CipaMeetingMaxOrderByAggregateInput
    _min?: CipaMeetingMinOrderByAggregateInput
  }

  export type CipaMeetingScalarWhereWithAggregatesInput = {
    AND?: CipaMeetingScalarWhereWithAggregatesInput | CipaMeetingScalarWhereWithAggregatesInput[]
    OR?: CipaMeetingScalarWhereWithAggregatesInput[]
    NOT?: CipaMeetingScalarWhereWithAggregatesInput | CipaMeetingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CipaMeeting"> | string
    date?: DateTimeWithAggregatesFilter<"CipaMeeting"> | Date | string
    participantsJson?: StringNullableWithAggregatesFilter<"CipaMeeting"> | string | null
    agenda?: StringWithAggregatesFilter<"CipaMeeting"> | string
    status?: StringWithAggregatesFilter<"CipaMeeting"> | string
    minutesUrl?: StringNullableWithAggregatesFilter<"CipaMeeting"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CipaMeeting"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CipaMeeting"> | Date | string
  }

  export type CipaActionWhereInput = {
    AND?: CipaActionWhereInput | CipaActionWhereInput[]
    OR?: CipaActionWhereInput[]
    NOT?: CipaActionWhereInput | CipaActionWhereInput[]
    id?: StringFilter<"CipaAction"> | string
    description?: StringFilter<"CipaAction"> | string
    responsible?: StringFilter<"CipaAction"> | string
    deadline?: DateTimeNullableFilter<"CipaAction"> | Date | string | null
    status?: StringFilter<"CipaAction"> | string
    meetingId?: StringFilter<"CipaAction"> | string
    createdAt?: DateTimeFilter<"CipaAction"> | Date | string
    updatedAt?: DateTimeFilter<"CipaAction"> | Date | string
    meeting?: XOR<CipaMeetingScalarRelationFilter, CipaMeetingWhereInput>
  }

  export type CipaActionOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrder
    responsible?: SortOrder
    deadline?: SortOrderInput | SortOrder
    status?: SortOrder
    meetingId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    meeting?: CipaMeetingOrderByWithRelationInput
  }

  export type CipaActionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CipaActionWhereInput | CipaActionWhereInput[]
    OR?: CipaActionWhereInput[]
    NOT?: CipaActionWhereInput | CipaActionWhereInput[]
    description?: StringFilter<"CipaAction"> | string
    responsible?: StringFilter<"CipaAction"> | string
    deadline?: DateTimeNullableFilter<"CipaAction"> | Date | string | null
    status?: StringFilter<"CipaAction"> | string
    meetingId?: StringFilter<"CipaAction"> | string
    createdAt?: DateTimeFilter<"CipaAction"> | Date | string
    updatedAt?: DateTimeFilter<"CipaAction"> | Date | string
    meeting?: XOR<CipaMeetingScalarRelationFilter, CipaMeetingWhereInput>
  }, "id">

  export type CipaActionOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    responsible?: SortOrder
    deadline?: SortOrderInput | SortOrder
    status?: SortOrder
    meetingId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CipaActionCountOrderByAggregateInput
    _max?: CipaActionMaxOrderByAggregateInput
    _min?: CipaActionMinOrderByAggregateInput
  }

  export type CipaActionScalarWhereWithAggregatesInput = {
    AND?: CipaActionScalarWhereWithAggregatesInput | CipaActionScalarWhereWithAggregatesInput[]
    OR?: CipaActionScalarWhereWithAggregatesInput[]
    NOT?: CipaActionScalarWhereWithAggregatesInput | CipaActionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CipaAction"> | string
    description?: StringWithAggregatesFilter<"CipaAction"> | string
    responsible?: StringWithAggregatesFilter<"CipaAction"> | string
    deadline?: DateTimeNullableWithAggregatesFilter<"CipaAction"> | Date | string | null
    status?: StringWithAggregatesFilter<"CipaAction"> | string
    meetingId?: StringWithAggregatesFilter<"CipaAction"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CipaAction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CipaAction"> | Date | string
  }

  export type PreventiveActionWhereInput = {
    AND?: PreventiveActionWhereInput | PreventiveActionWhereInput[]
    OR?: PreventiveActionWhereInput[]
    NOT?: PreventiveActionWhereInput | PreventiveActionWhereInput[]
    id?: StringFilter<"PreventiveAction"> | string
    description?: StringFilter<"PreventiveAction"> | string
    category?: StringFilter<"PreventiveAction"> | string
    responsible?: StringFilter<"PreventiveAction"> | string
    frequency?: StringNullableFilter<"PreventiveAction"> | string | null
    dueDate?: DateTimeNullableFilter<"PreventiveAction"> | Date | string | null
    lastCompletedDate?: DateTimeNullableFilter<"PreventiveAction"> | Date | string | null
    status?: StringFilter<"PreventiveAction"> | string
    evidenceUrl?: StringNullableFilter<"PreventiveAction"> | string | null
    createdAt?: DateTimeFilter<"PreventiveAction"> | Date | string
    updatedAt?: DateTimeFilter<"PreventiveAction"> | Date | string
  }

  export type PreventiveActionOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrder
    category?: SortOrder
    responsible?: SortOrder
    frequency?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    lastCompletedDate?: SortOrderInput | SortOrder
    status?: SortOrder
    evidenceUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PreventiveActionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PreventiveActionWhereInput | PreventiveActionWhereInput[]
    OR?: PreventiveActionWhereInput[]
    NOT?: PreventiveActionWhereInput | PreventiveActionWhereInput[]
    description?: StringFilter<"PreventiveAction"> | string
    category?: StringFilter<"PreventiveAction"> | string
    responsible?: StringFilter<"PreventiveAction"> | string
    frequency?: StringNullableFilter<"PreventiveAction"> | string | null
    dueDate?: DateTimeNullableFilter<"PreventiveAction"> | Date | string | null
    lastCompletedDate?: DateTimeNullableFilter<"PreventiveAction"> | Date | string | null
    status?: StringFilter<"PreventiveAction"> | string
    evidenceUrl?: StringNullableFilter<"PreventiveAction"> | string | null
    createdAt?: DateTimeFilter<"PreventiveAction"> | Date | string
    updatedAt?: DateTimeFilter<"PreventiveAction"> | Date | string
  }, "id">

  export type PreventiveActionOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    category?: SortOrder
    responsible?: SortOrder
    frequency?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    lastCompletedDate?: SortOrderInput | SortOrder
    status?: SortOrder
    evidenceUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PreventiveActionCountOrderByAggregateInput
    _max?: PreventiveActionMaxOrderByAggregateInput
    _min?: PreventiveActionMinOrderByAggregateInput
  }

  export type PreventiveActionScalarWhereWithAggregatesInput = {
    AND?: PreventiveActionScalarWhereWithAggregatesInput | PreventiveActionScalarWhereWithAggregatesInput[]
    OR?: PreventiveActionScalarWhereWithAggregatesInput[]
    NOT?: PreventiveActionScalarWhereWithAggregatesInput | PreventiveActionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PreventiveAction"> | string
    description?: StringWithAggregatesFilter<"PreventiveAction"> | string
    category?: StringWithAggregatesFilter<"PreventiveAction"> | string
    responsible?: StringWithAggregatesFilter<"PreventiveAction"> | string
    frequency?: StringNullableWithAggregatesFilter<"PreventiveAction"> | string | null
    dueDate?: DateTimeNullableWithAggregatesFilter<"PreventiveAction"> | Date | string | null
    lastCompletedDate?: DateTimeNullableWithAggregatesFilter<"PreventiveAction"> | Date | string | null
    status?: StringWithAggregatesFilter<"PreventiveAction"> | string
    evidenceUrl?: StringNullableWithAggregatesFilter<"PreventiveAction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PreventiveAction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PreventiveAction"> | Date | string
  }

  export type DocumentRecordWhereInput = {
    AND?: DocumentRecordWhereInput | DocumentRecordWhereInput[]
    OR?: DocumentRecordWhereInput[]
    NOT?: DocumentRecordWhereInput | DocumentRecordWhereInput[]
    id?: StringFilter<"DocumentRecord"> | string
    documentType?: StringFilter<"DocumentRecord"> | string
    title?: StringFilter<"DocumentRecord"> | string
    issueDate?: DateTimeFilter<"DocumentRecord"> | Date | string
    expiryDate?: DateTimeFilter<"DocumentRecord"> | Date | string
    responsible?: StringFilter<"DocumentRecord"> | string
    status?: StringFilter<"DocumentRecord"> | string
    attachmentUrl?: StringNullableFilter<"DocumentRecord"> | string | null
    observations?: StringNullableFilter<"DocumentRecord"> | string | null
    createdAt?: DateTimeFilter<"DocumentRecord"> | Date | string
    updatedAt?: DateTimeFilter<"DocumentRecord"> | Date | string
    relatedActions?: DocumentActionListRelationFilter
  }

  export type DocumentRecordOrderByWithRelationInput = {
    id?: SortOrder
    documentType?: SortOrder
    title?: SortOrder
    issueDate?: SortOrder
    expiryDate?: SortOrder
    responsible?: SortOrder
    status?: SortOrder
    attachmentUrl?: SortOrderInput | SortOrder
    observations?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    relatedActions?: DocumentActionOrderByRelationAggregateInput
  }

  export type DocumentRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentRecordWhereInput | DocumentRecordWhereInput[]
    OR?: DocumentRecordWhereInput[]
    NOT?: DocumentRecordWhereInput | DocumentRecordWhereInput[]
    documentType?: StringFilter<"DocumentRecord"> | string
    title?: StringFilter<"DocumentRecord"> | string
    issueDate?: DateTimeFilter<"DocumentRecord"> | Date | string
    expiryDate?: DateTimeFilter<"DocumentRecord"> | Date | string
    responsible?: StringFilter<"DocumentRecord"> | string
    status?: StringFilter<"DocumentRecord"> | string
    attachmentUrl?: StringNullableFilter<"DocumentRecord"> | string | null
    observations?: StringNullableFilter<"DocumentRecord"> | string | null
    createdAt?: DateTimeFilter<"DocumentRecord"> | Date | string
    updatedAt?: DateTimeFilter<"DocumentRecord"> | Date | string
    relatedActions?: DocumentActionListRelationFilter
  }, "id">

  export type DocumentRecordOrderByWithAggregationInput = {
    id?: SortOrder
    documentType?: SortOrder
    title?: SortOrder
    issueDate?: SortOrder
    expiryDate?: SortOrder
    responsible?: SortOrder
    status?: SortOrder
    attachmentUrl?: SortOrderInput | SortOrder
    observations?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DocumentRecordCountOrderByAggregateInput
    _max?: DocumentRecordMaxOrderByAggregateInput
    _min?: DocumentRecordMinOrderByAggregateInput
  }

  export type DocumentRecordScalarWhereWithAggregatesInput = {
    AND?: DocumentRecordScalarWhereWithAggregatesInput | DocumentRecordScalarWhereWithAggregatesInput[]
    OR?: DocumentRecordScalarWhereWithAggregatesInput[]
    NOT?: DocumentRecordScalarWhereWithAggregatesInput | DocumentRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DocumentRecord"> | string
    documentType?: StringWithAggregatesFilter<"DocumentRecord"> | string
    title?: StringWithAggregatesFilter<"DocumentRecord"> | string
    issueDate?: DateTimeWithAggregatesFilter<"DocumentRecord"> | Date | string
    expiryDate?: DateTimeWithAggregatesFilter<"DocumentRecord"> | Date | string
    responsible?: StringWithAggregatesFilter<"DocumentRecord"> | string
    status?: StringWithAggregatesFilter<"DocumentRecord"> | string
    attachmentUrl?: StringNullableWithAggregatesFilter<"DocumentRecord"> | string | null
    observations?: StringNullableWithAggregatesFilter<"DocumentRecord"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DocumentRecord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DocumentRecord"> | Date | string
  }

  export type DocumentActionWhereInput = {
    AND?: DocumentActionWhereInput | DocumentActionWhereInput[]
    OR?: DocumentActionWhereInput[]
    NOT?: DocumentActionWhereInput | DocumentActionWhereInput[]
    id?: StringFilter<"DocumentAction"> | string
    description?: StringFilter<"DocumentAction"> | string
    responsible?: StringFilter<"DocumentAction"> | string
    deadline?: DateTimeNullableFilter<"DocumentAction"> | Date | string | null
    status?: StringFilter<"DocumentAction"> | string
    documentId?: StringFilter<"DocumentAction"> | string
    createdAt?: DateTimeFilter<"DocumentAction"> | Date | string
    updatedAt?: DateTimeFilter<"DocumentAction"> | Date | string
    document?: XOR<DocumentRecordScalarRelationFilter, DocumentRecordWhereInput>
  }

  export type DocumentActionOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrder
    responsible?: SortOrder
    deadline?: SortOrderInput | SortOrder
    status?: SortOrder
    documentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    document?: DocumentRecordOrderByWithRelationInput
  }

  export type DocumentActionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentActionWhereInput | DocumentActionWhereInput[]
    OR?: DocumentActionWhereInput[]
    NOT?: DocumentActionWhereInput | DocumentActionWhereInput[]
    description?: StringFilter<"DocumentAction"> | string
    responsible?: StringFilter<"DocumentAction"> | string
    deadline?: DateTimeNullableFilter<"DocumentAction"> | Date | string | null
    status?: StringFilter<"DocumentAction"> | string
    documentId?: StringFilter<"DocumentAction"> | string
    createdAt?: DateTimeFilter<"DocumentAction"> | Date | string
    updatedAt?: DateTimeFilter<"DocumentAction"> | Date | string
    document?: XOR<DocumentRecordScalarRelationFilter, DocumentRecordWhereInput>
  }, "id">

  export type DocumentActionOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    responsible?: SortOrder
    deadline?: SortOrderInput | SortOrder
    status?: SortOrder
    documentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DocumentActionCountOrderByAggregateInput
    _max?: DocumentActionMaxOrderByAggregateInput
    _min?: DocumentActionMinOrderByAggregateInput
  }

  export type DocumentActionScalarWhereWithAggregatesInput = {
    AND?: DocumentActionScalarWhereWithAggregatesInput | DocumentActionScalarWhereWithAggregatesInput[]
    OR?: DocumentActionScalarWhereWithAggregatesInput[]
    NOT?: DocumentActionScalarWhereWithAggregatesInput | DocumentActionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DocumentAction"> | string
    description?: StringWithAggregatesFilter<"DocumentAction"> | string
    responsible?: StringWithAggregatesFilter<"DocumentAction"> | string
    deadline?: DateTimeNullableWithAggregatesFilter<"DocumentAction"> | Date | string | null
    status?: StringWithAggregatesFilter<"DocumentAction"> | string
    documentId?: StringWithAggregatesFilter<"DocumentAction"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DocumentAction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DocumentAction"> | Date | string
  }

  export type LawsuitRecordWhereInput = {
    AND?: LawsuitRecordWhereInput | LawsuitRecordWhereInput[]
    OR?: LawsuitRecordWhereInput[]
    NOT?: LawsuitRecordWhereInput | LawsuitRecordWhereInput[]
    id?: StringFilter<"LawsuitRecord"> | string
    processNumber?: StringFilter<"LawsuitRecord"> | string
    plaintiff?: StringFilter<"LawsuitRecord"> | string
    subject?: StringFilter<"LawsuitRecord"> | string
    status?: StringFilter<"LawsuitRecord"> | string
    filingDate?: DateTimeFilter<"LawsuitRecord"> | Date | string
    hearingDate?: DateTimeNullableFilter<"LawsuitRecord"> | Date | string | null
    estimatedCost?: FloatNullableFilter<"LawsuitRecord"> | number | null
    finalCost?: FloatNullableFilter<"LawsuitRecord"> | number | null
    lawyer?: StringNullableFilter<"LawsuitRecord"> | string | null
    details?: StringFilter<"LawsuitRecord"> | string
    relatedNRsJson?: StringNullableFilter<"LawsuitRecord"> | string | null
    createdAt?: DateTimeFilter<"LawsuitRecord"> | Date | string
    updatedAt?: DateTimeFilter<"LawsuitRecord"> | Date | string
  }

  export type LawsuitRecordOrderByWithRelationInput = {
    id?: SortOrder
    processNumber?: SortOrder
    plaintiff?: SortOrder
    subject?: SortOrder
    status?: SortOrder
    filingDate?: SortOrder
    hearingDate?: SortOrderInput | SortOrder
    estimatedCost?: SortOrderInput | SortOrder
    finalCost?: SortOrderInput | SortOrder
    lawyer?: SortOrderInput | SortOrder
    details?: SortOrder
    relatedNRsJson?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LawsuitRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    processNumber?: string
    AND?: LawsuitRecordWhereInput | LawsuitRecordWhereInput[]
    OR?: LawsuitRecordWhereInput[]
    NOT?: LawsuitRecordWhereInput | LawsuitRecordWhereInput[]
    plaintiff?: StringFilter<"LawsuitRecord"> | string
    subject?: StringFilter<"LawsuitRecord"> | string
    status?: StringFilter<"LawsuitRecord"> | string
    filingDate?: DateTimeFilter<"LawsuitRecord"> | Date | string
    hearingDate?: DateTimeNullableFilter<"LawsuitRecord"> | Date | string | null
    estimatedCost?: FloatNullableFilter<"LawsuitRecord"> | number | null
    finalCost?: FloatNullableFilter<"LawsuitRecord"> | number | null
    lawyer?: StringNullableFilter<"LawsuitRecord"> | string | null
    details?: StringFilter<"LawsuitRecord"> | string
    relatedNRsJson?: StringNullableFilter<"LawsuitRecord"> | string | null
    createdAt?: DateTimeFilter<"LawsuitRecord"> | Date | string
    updatedAt?: DateTimeFilter<"LawsuitRecord"> | Date | string
  }, "id" | "processNumber">

  export type LawsuitRecordOrderByWithAggregationInput = {
    id?: SortOrder
    processNumber?: SortOrder
    plaintiff?: SortOrder
    subject?: SortOrder
    status?: SortOrder
    filingDate?: SortOrder
    hearingDate?: SortOrderInput | SortOrder
    estimatedCost?: SortOrderInput | SortOrder
    finalCost?: SortOrderInput | SortOrder
    lawyer?: SortOrderInput | SortOrder
    details?: SortOrder
    relatedNRsJson?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LawsuitRecordCountOrderByAggregateInput
    _avg?: LawsuitRecordAvgOrderByAggregateInput
    _max?: LawsuitRecordMaxOrderByAggregateInput
    _min?: LawsuitRecordMinOrderByAggregateInput
    _sum?: LawsuitRecordSumOrderByAggregateInput
  }

  export type LawsuitRecordScalarWhereWithAggregatesInput = {
    AND?: LawsuitRecordScalarWhereWithAggregatesInput | LawsuitRecordScalarWhereWithAggregatesInput[]
    OR?: LawsuitRecordScalarWhereWithAggregatesInput[]
    NOT?: LawsuitRecordScalarWhereWithAggregatesInput | LawsuitRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LawsuitRecord"> | string
    processNumber?: StringWithAggregatesFilter<"LawsuitRecord"> | string
    plaintiff?: StringWithAggregatesFilter<"LawsuitRecord"> | string
    subject?: StringWithAggregatesFilter<"LawsuitRecord"> | string
    status?: StringWithAggregatesFilter<"LawsuitRecord"> | string
    filingDate?: DateTimeWithAggregatesFilter<"LawsuitRecord"> | Date | string
    hearingDate?: DateTimeNullableWithAggregatesFilter<"LawsuitRecord"> | Date | string | null
    estimatedCost?: FloatNullableWithAggregatesFilter<"LawsuitRecord"> | number | null
    finalCost?: FloatNullableWithAggregatesFilter<"LawsuitRecord"> | number | null
    lawyer?: StringNullableWithAggregatesFilter<"LawsuitRecord"> | string | null
    details?: StringWithAggregatesFilter<"LawsuitRecord"> | string
    relatedNRsJson?: StringNullableWithAggregatesFilter<"LawsuitRecord"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LawsuitRecord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LawsuitRecord"> | Date | string
  }

  export type AccidentRecordWhereInput = {
    AND?: AccidentRecordWhereInput | AccidentRecordWhereInput[]
    OR?: AccidentRecordWhereInput[]
    NOT?: AccidentRecordWhereInput | AccidentRecordWhereInput[]
    id?: StringFilter<"AccidentRecord"> | string
    date?: DateTimeFilter<"AccidentRecord"> | Date | string
    time?: StringNullableFilter<"AccidentRecord"> | string | null
    employeeId?: StringFilter<"AccidentRecord"> | string
    department?: StringFilter<"AccidentRecord"> | string
    location?: StringFilter<"AccidentRecord"> | string
    type?: StringFilter<"AccidentRecord"> | string
    cause?: StringFilter<"AccidentRecord"> | string
    causeDetails?: StringNullableFilter<"AccidentRecord"> | string | null
    daysOff?: IntFilter<"AccidentRecord"> | number
    description?: StringFilter<"AccidentRecord"> | string
    cid10Code?: StringNullableFilter<"AccidentRecord"> | string | null
    catIssued?: BoolFilter<"AccidentRecord"> | boolean
    investigationStatus?: StringFilter<"AccidentRecord"> | string
    reportUrl?: StringNullableFilter<"AccidentRecord"> | string | null
    createdAt?: DateTimeFilter<"AccidentRecord"> | Date | string
    updatedAt?: DateTimeFilter<"AccidentRecord"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }

  export type AccidentRecordOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    time?: SortOrderInput | SortOrder
    employeeId?: SortOrder
    department?: SortOrder
    location?: SortOrder
    type?: SortOrder
    cause?: SortOrder
    causeDetails?: SortOrderInput | SortOrder
    daysOff?: SortOrder
    description?: SortOrder
    cid10Code?: SortOrderInput | SortOrder
    catIssued?: SortOrder
    investigationStatus?: SortOrder
    reportUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
  }

  export type AccidentRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccidentRecordWhereInput | AccidentRecordWhereInput[]
    OR?: AccidentRecordWhereInput[]
    NOT?: AccidentRecordWhereInput | AccidentRecordWhereInput[]
    date?: DateTimeFilter<"AccidentRecord"> | Date | string
    time?: StringNullableFilter<"AccidentRecord"> | string | null
    employeeId?: StringFilter<"AccidentRecord"> | string
    department?: StringFilter<"AccidentRecord"> | string
    location?: StringFilter<"AccidentRecord"> | string
    type?: StringFilter<"AccidentRecord"> | string
    cause?: StringFilter<"AccidentRecord"> | string
    causeDetails?: StringNullableFilter<"AccidentRecord"> | string | null
    daysOff?: IntFilter<"AccidentRecord"> | number
    description?: StringFilter<"AccidentRecord"> | string
    cid10Code?: StringNullableFilter<"AccidentRecord"> | string | null
    catIssued?: BoolFilter<"AccidentRecord"> | boolean
    investigationStatus?: StringFilter<"AccidentRecord"> | string
    reportUrl?: StringNullableFilter<"AccidentRecord"> | string | null
    createdAt?: DateTimeFilter<"AccidentRecord"> | Date | string
    updatedAt?: DateTimeFilter<"AccidentRecord"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }, "id">

  export type AccidentRecordOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    time?: SortOrderInput | SortOrder
    employeeId?: SortOrder
    department?: SortOrder
    location?: SortOrder
    type?: SortOrder
    cause?: SortOrder
    causeDetails?: SortOrderInput | SortOrder
    daysOff?: SortOrder
    description?: SortOrder
    cid10Code?: SortOrderInput | SortOrder
    catIssued?: SortOrder
    investigationStatus?: SortOrder
    reportUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccidentRecordCountOrderByAggregateInput
    _avg?: AccidentRecordAvgOrderByAggregateInput
    _max?: AccidentRecordMaxOrderByAggregateInput
    _min?: AccidentRecordMinOrderByAggregateInput
    _sum?: AccidentRecordSumOrderByAggregateInput
  }

  export type AccidentRecordScalarWhereWithAggregatesInput = {
    AND?: AccidentRecordScalarWhereWithAggregatesInput | AccidentRecordScalarWhereWithAggregatesInput[]
    OR?: AccidentRecordScalarWhereWithAggregatesInput[]
    NOT?: AccidentRecordScalarWhereWithAggregatesInput | AccidentRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AccidentRecord"> | string
    date?: DateTimeWithAggregatesFilter<"AccidentRecord"> | Date | string
    time?: StringNullableWithAggregatesFilter<"AccidentRecord"> | string | null
    employeeId?: StringWithAggregatesFilter<"AccidentRecord"> | string
    department?: StringWithAggregatesFilter<"AccidentRecord"> | string
    location?: StringWithAggregatesFilter<"AccidentRecord"> | string
    type?: StringWithAggregatesFilter<"AccidentRecord"> | string
    cause?: StringWithAggregatesFilter<"AccidentRecord"> | string
    causeDetails?: StringNullableWithAggregatesFilter<"AccidentRecord"> | string | null
    daysOff?: IntWithAggregatesFilter<"AccidentRecord"> | number
    description?: StringWithAggregatesFilter<"AccidentRecord"> | string
    cid10Code?: StringNullableWithAggregatesFilter<"AccidentRecord"> | string | null
    catIssued?: BoolWithAggregatesFilter<"AccidentRecord"> | boolean
    investigationStatus?: StringWithAggregatesFilter<"AccidentRecord"> | string
    reportUrl?: StringNullableWithAggregatesFilter<"AccidentRecord"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AccidentRecord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AccidentRecord"> | Date | string
  }

  export type OccupationalDiseaseRecordWhereInput = {
    AND?: OccupationalDiseaseRecordWhereInput | OccupationalDiseaseRecordWhereInput[]
    OR?: OccupationalDiseaseRecordWhereInput[]
    NOT?: OccupationalDiseaseRecordWhereInput | OccupationalDiseaseRecordWhereInput[]
    id?: StringFilter<"OccupationalDiseaseRecord"> | string
    employeeId?: StringFilter<"OccupationalDiseaseRecord"> | string
    diseaseType?: StringFilter<"OccupationalDiseaseRecord"> | string
    cid10Code?: StringFilter<"OccupationalDiseaseRecord"> | string
    diagnosisDate?: DateTimeFilter<"OccupationalDiseaseRecord"> | Date | string
    relatedTask?: StringNullableFilter<"OccupationalDiseaseRecord"> | string | null
    daysOff?: IntFilter<"OccupationalDiseaseRecord"> | number
    status?: StringFilter<"OccupationalDiseaseRecord"> | string
    medicalReportUrl?: StringNullableFilter<"OccupationalDiseaseRecord"> | string | null
    pcmsoLink?: StringNullableFilter<"OccupationalDiseaseRecord"> | string | null
    createdAt?: DateTimeFilter<"OccupationalDiseaseRecord"> | Date | string
    updatedAt?: DateTimeFilter<"OccupationalDiseaseRecord"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }

  export type OccupationalDiseaseRecordOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    diseaseType?: SortOrder
    cid10Code?: SortOrder
    diagnosisDate?: SortOrder
    relatedTask?: SortOrderInput | SortOrder
    daysOff?: SortOrder
    status?: SortOrder
    medicalReportUrl?: SortOrderInput | SortOrder
    pcmsoLink?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
  }

  export type OccupationalDiseaseRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OccupationalDiseaseRecordWhereInput | OccupationalDiseaseRecordWhereInput[]
    OR?: OccupationalDiseaseRecordWhereInput[]
    NOT?: OccupationalDiseaseRecordWhereInput | OccupationalDiseaseRecordWhereInput[]
    employeeId?: StringFilter<"OccupationalDiseaseRecord"> | string
    diseaseType?: StringFilter<"OccupationalDiseaseRecord"> | string
    cid10Code?: StringFilter<"OccupationalDiseaseRecord"> | string
    diagnosisDate?: DateTimeFilter<"OccupationalDiseaseRecord"> | Date | string
    relatedTask?: StringNullableFilter<"OccupationalDiseaseRecord"> | string | null
    daysOff?: IntFilter<"OccupationalDiseaseRecord"> | number
    status?: StringFilter<"OccupationalDiseaseRecord"> | string
    medicalReportUrl?: StringNullableFilter<"OccupationalDiseaseRecord"> | string | null
    pcmsoLink?: StringNullableFilter<"OccupationalDiseaseRecord"> | string | null
    createdAt?: DateTimeFilter<"OccupationalDiseaseRecord"> | Date | string
    updatedAt?: DateTimeFilter<"OccupationalDiseaseRecord"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }, "id">

  export type OccupationalDiseaseRecordOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    diseaseType?: SortOrder
    cid10Code?: SortOrder
    diagnosisDate?: SortOrder
    relatedTask?: SortOrderInput | SortOrder
    daysOff?: SortOrder
    status?: SortOrder
    medicalReportUrl?: SortOrderInput | SortOrder
    pcmsoLink?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OccupationalDiseaseRecordCountOrderByAggregateInput
    _avg?: OccupationalDiseaseRecordAvgOrderByAggregateInput
    _max?: OccupationalDiseaseRecordMaxOrderByAggregateInput
    _min?: OccupationalDiseaseRecordMinOrderByAggregateInput
    _sum?: OccupationalDiseaseRecordSumOrderByAggregateInput
  }

  export type OccupationalDiseaseRecordScalarWhereWithAggregatesInput = {
    AND?: OccupationalDiseaseRecordScalarWhereWithAggregatesInput | OccupationalDiseaseRecordScalarWhereWithAggregatesInput[]
    OR?: OccupationalDiseaseRecordScalarWhereWithAggregatesInput[]
    NOT?: OccupationalDiseaseRecordScalarWhereWithAggregatesInput | OccupationalDiseaseRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OccupationalDiseaseRecord"> | string
    employeeId?: StringWithAggregatesFilter<"OccupationalDiseaseRecord"> | string
    diseaseType?: StringWithAggregatesFilter<"OccupationalDiseaseRecord"> | string
    cid10Code?: StringWithAggregatesFilter<"OccupationalDiseaseRecord"> | string
    diagnosisDate?: DateTimeWithAggregatesFilter<"OccupationalDiseaseRecord"> | Date | string
    relatedTask?: StringNullableWithAggregatesFilter<"OccupationalDiseaseRecord"> | string | null
    daysOff?: IntWithAggregatesFilter<"OccupationalDiseaseRecord"> | number
    status?: StringWithAggregatesFilter<"OccupationalDiseaseRecord"> | string
    medicalReportUrl?: StringNullableWithAggregatesFilter<"OccupationalDiseaseRecord"> | string | null
    pcmsoLink?: StringNullableWithAggregatesFilter<"OccupationalDiseaseRecord"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"OccupationalDiseaseRecord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OccupationalDiseaseRecord"> | Date | string
  }

  export type EmployeeCreateInput = {
    id?: string
    name: string
    department?: string | null
    position?: string | null
    hireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ppeRecords?: PpeRecordCreateNestedManyWithoutEmployeeInput
    asoRecords?: AsoRecordCreateNestedManyWithoutEmployeeInput
    trainings?: TrainingRecordCreateNestedManyWithoutEmployeeInput
    accidents?: AccidentRecordCreateNestedManyWithoutEmployeeInput
    diseases?: OccupationalDiseaseRecordCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateInput = {
    id?: string
    name: string
    department?: string | null
    position?: string | null
    hireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ppeRecords?: PpeRecordUncheckedCreateNestedManyWithoutEmployeeInput
    asoRecords?: AsoRecordUncheckedCreateNestedManyWithoutEmployeeInput
    trainings?: TrainingRecordUncheckedCreateNestedManyWithoutEmployeeInput
    accidents?: AccidentRecordUncheckedCreateNestedManyWithoutEmployeeInput
    diseases?: OccupationalDiseaseRecordUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ppeRecords?: PpeRecordUpdateManyWithoutEmployeeNestedInput
    asoRecords?: AsoRecordUpdateManyWithoutEmployeeNestedInput
    trainings?: TrainingRecordUpdateManyWithoutEmployeeNestedInput
    accidents?: AccidentRecordUpdateManyWithoutEmployeeNestedInput
    diseases?: OccupationalDiseaseRecordUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ppeRecords?: PpeRecordUncheckedUpdateManyWithoutEmployeeNestedInput
    asoRecords?: AsoRecordUncheckedUpdateManyWithoutEmployeeNestedInput
    trainings?: TrainingRecordUncheckedUpdateManyWithoutEmployeeNestedInput
    accidents?: AccidentRecordUncheckedUpdateManyWithoutEmployeeNestedInput
    diseases?: OccupationalDiseaseRecordUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateManyInput = {
    id?: string
    name: string
    department?: string | null
    position?: string | null
    hireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingTypeCreateInput = {
    id?: string
    name: string
    description?: string | null
    validityMonths?: number | null
    requiredNrsJson?: string | null
    defaultDuration?: number | null
    defaultLocation?: string | null
    defaultCost?: number | null
    instructorsJson?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trainingRecords?: TrainingRecordCreateNestedManyWithoutTrainingTypeInput
  }

  export type TrainingTypeUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    validityMonths?: number | null
    requiredNrsJson?: string | null
    defaultDuration?: number | null
    defaultLocation?: string | null
    defaultCost?: number | null
    instructorsJson?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trainingRecords?: TrainingRecordUncheckedCreateNestedManyWithoutTrainingTypeInput
  }

  export type TrainingTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    validityMonths?: NullableIntFieldUpdateOperationsInput | number | null
    requiredNrsJson?: NullableStringFieldUpdateOperationsInput | string | null
    defaultDuration?: NullableIntFieldUpdateOperationsInput | number | null
    defaultLocation?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCost?: NullableFloatFieldUpdateOperationsInput | number | null
    instructorsJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingRecords?: TrainingRecordUpdateManyWithoutTrainingTypeNestedInput
  }

  export type TrainingTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    validityMonths?: NullableIntFieldUpdateOperationsInput | number | null
    requiredNrsJson?: NullableStringFieldUpdateOperationsInput | string | null
    defaultDuration?: NullableIntFieldUpdateOperationsInput | number | null
    defaultLocation?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCost?: NullableFloatFieldUpdateOperationsInput | number | null
    instructorsJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingRecords?: TrainingRecordUncheckedUpdateManyWithoutTrainingTypeNestedInput
  }

  export type TrainingTypeCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    validityMonths?: number | null
    requiredNrsJson?: string | null
    defaultDuration?: number | null
    defaultLocation?: string | null
    defaultCost?: number | null
    instructorsJson?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    validityMonths?: NullableIntFieldUpdateOperationsInput | number | null
    requiredNrsJson?: NullableStringFieldUpdateOperationsInput | string | null
    defaultDuration?: NullableIntFieldUpdateOperationsInput | number | null
    defaultLocation?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCost?: NullableFloatFieldUpdateOperationsInput | number | null
    instructorsJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    validityMonths?: NullableIntFieldUpdateOperationsInput | number | null
    requiredNrsJson?: NullableStringFieldUpdateOperationsInput | string | null
    defaultDuration?: NullableIntFieldUpdateOperationsInput | number | null
    defaultLocation?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCost?: NullableFloatFieldUpdateOperationsInput | number | null
    instructorsJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingRecordCreateInput = {
    id?: string
    trainingDate: Date | string
    expiryDate?: Date | string | null
    status?: string
    attendanceListUrl?: string | null
    certificateUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutTrainingsInput
    trainingType: TrainingTypeCreateNestedOneWithoutTrainingRecordsInput
  }

  export type TrainingRecordUncheckedCreateInput = {
    id?: string
    employeeId: string
    trainingTypeId: string
    trainingDate: Date | string
    expiryDate?: Date | string | null
    status?: string
    attendanceListUrl?: string | null
    certificateUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    attendanceListUrl?: NullableStringFieldUpdateOperationsInput | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutTrainingsNestedInput
    trainingType?: TrainingTypeUpdateOneRequiredWithoutTrainingRecordsNestedInput
  }

  export type TrainingRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    trainingTypeId?: StringFieldUpdateOperationsInput | string
    trainingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    attendanceListUrl?: NullableStringFieldUpdateOperationsInput | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingRecordCreateManyInput = {
    id?: string
    employeeId: string
    trainingTypeId: string
    trainingDate: Date | string
    expiryDate?: Date | string | null
    status?: string
    attendanceListUrl?: string | null
    certificateUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    attendanceListUrl?: NullableStringFieldUpdateOperationsInput | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    trainingTypeId?: StringFieldUpdateOperationsInput | string
    trainingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    attendanceListUrl?: NullableStringFieldUpdateOperationsInput | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PpeRecordCreateInput = {
    id?: string
    ppeType: string
    caNumber?: string | null
    deliveryDate: Date | string
    quantity?: number
    returnDate?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutPpeRecordsInput
  }

  export type PpeRecordUncheckedCreateInput = {
    id?: string
    employeeId: string
    ppeType: string
    caNumber?: string | null
    deliveryDate: Date | string
    quantity?: number
    returnDate?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PpeRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ppeType?: StringFieldUpdateOperationsInput | string
    caNumber?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutPpeRecordsNestedInput
  }

  export type PpeRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    ppeType?: StringFieldUpdateOperationsInput | string
    caNumber?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PpeRecordCreateManyInput = {
    id?: string
    employeeId: string
    ppeType: string
    caNumber?: string | null
    deliveryDate: Date | string
    quantity?: number
    returnDate?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PpeRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ppeType?: StringFieldUpdateOperationsInput | string
    caNumber?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PpeRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    ppeType?: StringFieldUpdateOperationsInput | string
    caNumber?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AsoRecordCreateInput = {
    id?: string
    examType: string
    examDate: Date | string
    expiryDate: Date | string
    result: string
    status?: string
    attachmentUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutAsoRecordsInput
  }

  export type AsoRecordUncheckedCreateInput = {
    id?: string
    employeeId: string
    examType: string
    examDate: Date | string
    expiryDate: Date | string
    result: string
    status?: string
    attachmentUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AsoRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    examType?: StringFieldUpdateOperationsInput | string
    examDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    result?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutAsoRecordsNestedInput
  }

  export type AsoRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    examType?: StringFieldUpdateOperationsInput | string
    examDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    result?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AsoRecordCreateManyInput = {
    id?: string
    employeeId: string
    examType: string
    examDate: Date | string
    expiryDate: Date | string
    result: string
    status?: string
    attachmentUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AsoRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    examType?: StringFieldUpdateOperationsInput | string
    examDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    result?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AsoRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    examType?: StringFieldUpdateOperationsInput | string
    examDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    result?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChemicalRecordCreateInput = {
    id?: string
    productName: string
    casNumber?: string | null
    location: string
    quantity: number
    unit: string
    sdsUrl?: string | null
    lastUpdated: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChemicalRecordUncheckedCreateInput = {
    id?: string
    productName: string
    casNumber?: string | null
    location: string
    quantity: number
    unit: string
    sdsUrl?: string | null
    lastUpdated: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChemicalRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    casNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    sdsUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChemicalRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    casNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    sdsUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChemicalRecordCreateManyInput = {
    id?: string
    productName: string
    casNumber?: string | null
    location: string
    quantity: number
    unit: string
    sdsUrl?: string | null
    lastUpdated: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChemicalRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    casNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    sdsUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChemicalRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    casNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    sdsUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JsaRecordCreateInput = {
    id?: string
    taskName: string
    department: string
    analysisDate: Date | string
    reviewDate?: Date | string | null
    status?: string
    attachmentUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    risks?: RiskItemCreateNestedManyWithoutJsaInput
  }

  export type JsaRecordUncheckedCreateInput = {
    id?: string
    taskName: string
    department: string
    analysisDate: Date | string
    reviewDate?: Date | string | null
    status?: string
    attachmentUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    risks?: RiskItemUncheckedCreateNestedManyWithoutJsaInput
  }

  export type JsaRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskName?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    analysisDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    risks?: RiskItemUpdateManyWithoutJsaNestedInput
  }

  export type JsaRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskName?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    analysisDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    risks?: RiskItemUncheckedUpdateManyWithoutJsaNestedInput
  }

  export type JsaRecordCreateManyInput = {
    id?: string
    taskName: string
    department: string
    analysisDate: Date | string
    reviewDate?: Date | string | null
    status?: string
    attachmentUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JsaRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskName?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    analysisDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JsaRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskName?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    analysisDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiskItemCreateInput = {
    id?: string
    description: string
    controls: string
    createdAt?: Date | string
    updatedAt?: Date | string
    jsa: JsaRecordCreateNestedOneWithoutRisksInput
  }

  export type RiskItemUncheckedCreateInput = {
    id?: string
    jsaId: string
    description: string
    controls: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RiskItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    controls?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jsa?: JsaRecordUpdateOneRequiredWithoutRisksNestedInput
  }

  export type RiskItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jsaId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    controls?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiskItemCreateManyInput = {
    id?: string
    jsaId: string
    description: string
    controls: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RiskItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    controls?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiskItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jsaId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    controls?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CipaMeetingCreateInput = {
    id?: string
    date: Date | string
    participantsJson?: string | null
    agenda: string
    status?: string
    minutesUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actionsDefined?: CipaActionCreateNestedManyWithoutMeetingInput
  }

  export type CipaMeetingUncheckedCreateInput = {
    id?: string
    date: Date | string
    participantsJson?: string | null
    agenda: string
    status?: string
    minutesUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actionsDefined?: CipaActionUncheckedCreateNestedManyWithoutMeetingInput
  }

  export type CipaMeetingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    participantsJson?: NullableStringFieldUpdateOperationsInput | string | null
    agenda?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    minutesUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actionsDefined?: CipaActionUpdateManyWithoutMeetingNestedInput
  }

  export type CipaMeetingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    participantsJson?: NullableStringFieldUpdateOperationsInput | string | null
    agenda?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    minutesUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actionsDefined?: CipaActionUncheckedUpdateManyWithoutMeetingNestedInput
  }

  export type CipaMeetingCreateManyInput = {
    id?: string
    date: Date | string
    participantsJson?: string | null
    agenda: string
    status?: string
    minutesUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CipaMeetingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    participantsJson?: NullableStringFieldUpdateOperationsInput | string | null
    agenda?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    minutesUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CipaMeetingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    participantsJson?: NullableStringFieldUpdateOperationsInput | string | null
    agenda?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    minutesUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CipaActionCreateInput = {
    id?: string
    description: string
    responsible: string
    deadline?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    meeting: CipaMeetingCreateNestedOneWithoutActionsDefinedInput
  }

  export type CipaActionUncheckedCreateInput = {
    id?: string
    description: string
    responsible: string
    deadline?: Date | string | null
    status?: string
    meetingId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CipaActionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    responsible?: StringFieldUpdateOperationsInput | string
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meeting?: CipaMeetingUpdateOneRequiredWithoutActionsDefinedNestedInput
  }

  export type CipaActionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    responsible?: StringFieldUpdateOperationsInput | string
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    meetingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CipaActionCreateManyInput = {
    id?: string
    description: string
    responsible: string
    deadline?: Date | string | null
    status?: string
    meetingId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CipaActionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    responsible?: StringFieldUpdateOperationsInput | string
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CipaActionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    responsible?: StringFieldUpdateOperationsInput | string
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    meetingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PreventiveActionCreateInput = {
    id?: string
    description: string
    category: string
    responsible: string
    frequency?: string | null
    dueDate?: Date | string | null
    lastCompletedDate?: Date | string | null
    status?: string
    evidenceUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PreventiveActionUncheckedCreateInput = {
    id?: string
    description: string
    category: string
    responsible: string
    frequency?: string | null
    dueDate?: Date | string | null
    lastCompletedDate?: Date | string | null
    status?: string
    evidenceUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PreventiveActionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    responsible?: StringFieldUpdateOperationsInput | string
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    evidenceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PreventiveActionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    responsible?: StringFieldUpdateOperationsInput | string
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    evidenceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PreventiveActionCreateManyInput = {
    id?: string
    description: string
    category: string
    responsible: string
    frequency?: string | null
    dueDate?: Date | string | null
    lastCompletedDate?: Date | string | null
    status?: string
    evidenceUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PreventiveActionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    responsible?: StringFieldUpdateOperationsInput | string
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    evidenceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PreventiveActionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    responsible?: StringFieldUpdateOperationsInput | string
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    evidenceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentRecordCreateInput = {
    id?: string
    documentType: string
    title: string
    issueDate: Date | string
    expiryDate: Date | string
    responsible: string
    status?: string
    attachmentUrl?: string | null
    observations?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    relatedActions?: DocumentActionCreateNestedManyWithoutDocumentInput
  }

  export type DocumentRecordUncheckedCreateInput = {
    id?: string
    documentType: string
    title: string
    issueDate: Date | string
    expiryDate: Date | string
    responsible: string
    status?: string
    attachmentUrl?: string | null
    observations?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    relatedActions?: DocumentActionUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    responsible?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedActions?: DocumentActionUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    responsible?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedActions?: DocumentActionUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentRecordCreateManyInput = {
    id?: string
    documentType: string
    title: string
    issueDate: Date | string
    expiryDate: Date | string
    responsible: string
    status?: string
    attachmentUrl?: string | null
    observations?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    responsible?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    responsible?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentActionCreateInput = {
    id?: string
    description: string
    responsible: string
    deadline?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    document: DocumentRecordCreateNestedOneWithoutRelatedActionsInput
  }

  export type DocumentActionUncheckedCreateInput = {
    id?: string
    description: string
    responsible: string
    deadline?: Date | string | null
    status?: string
    documentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentActionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    responsible?: StringFieldUpdateOperationsInput | string
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentRecordUpdateOneRequiredWithoutRelatedActionsNestedInput
  }

  export type DocumentActionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    responsible?: StringFieldUpdateOperationsInput | string
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentActionCreateManyInput = {
    id?: string
    description: string
    responsible: string
    deadline?: Date | string | null
    status?: string
    documentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentActionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    responsible?: StringFieldUpdateOperationsInput | string
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentActionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    responsible?: StringFieldUpdateOperationsInput | string
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LawsuitRecordCreateInput = {
    id?: string
    processNumber: string
    plaintiff: string
    subject: string
    status?: string
    filingDate: Date | string
    hearingDate?: Date | string | null
    estimatedCost?: number | null
    finalCost?: number | null
    lawyer?: string | null
    details: string
    relatedNRsJson?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LawsuitRecordUncheckedCreateInput = {
    id?: string
    processNumber: string
    plaintiff: string
    subject: string
    status?: string
    filingDate: Date | string
    hearingDate?: Date | string | null
    estimatedCost?: number | null
    finalCost?: number | null
    lawyer?: string | null
    details: string
    relatedNRsJson?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LawsuitRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    processNumber?: StringFieldUpdateOperationsInput | string
    plaintiff?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    filingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    hearingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    finalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    lawyer?: NullableStringFieldUpdateOperationsInput | string | null
    details?: StringFieldUpdateOperationsInput | string
    relatedNRsJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LawsuitRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    processNumber?: StringFieldUpdateOperationsInput | string
    plaintiff?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    filingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    hearingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    finalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    lawyer?: NullableStringFieldUpdateOperationsInput | string | null
    details?: StringFieldUpdateOperationsInput | string
    relatedNRsJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LawsuitRecordCreateManyInput = {
    id?: string
    processNumber: string
    plaintiff: string
    subject: string
    status?: string
    filingDate: Date | string
    hearingDate?: Date | string | null
    estimatedCost?: number | null
    finalCost?: number | null
    lawyer?: string | null
    details: string
    relatedNRsJson?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LawsuitRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    processNumber?: StringFieldUpdateOperationsInput | string
    plaintiff?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    filingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    hearingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    finalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    lawyer?: NullableStringFieldUpdateOperationsInput | string | null
    details?: StringFieldUpdateOperationsInput | string
    relatedNRsJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LawsuitRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    processNumber?: StringFieldUpdateOperationsInput | string
    plaintiff?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    filingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    hearingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    finalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    lawyer?: NullableStringFieldUpdateOperationsInput | string | null
    details?: StringFieldUpdateOperationsInput | string
    relatedNRsJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccidentRecordCreateInput = {
    id?: string
    date: Date | string
    time?: string | null
    department: string
    location: string
    type: string
    cause: string
    causeDetails?: string | null
    daysOff?: number
    description: string
    cid10Code?: string | null
    catIssued?: boolean
    investigationStatus?: string
    reportUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutAccidentsInput
  }

  export type AccidentRecordUncheckedCreateInput = {
    id?: string
    date: Date | string
    time?: string | null
    employeeId: string
    department: string
    location: string
    type: string
    cause: string
    causeDetails?: string | null
    daysOff?: number
    description: string
    cid10Code?: string | null
    catIssued?: boolean
    investigationStatus?: string
    reportUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccidentRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    department?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    cause?: StringFieldUpdateOperationsInput | string
    causeDetails?: NullableStringFieldUpdateOperationsInput | string | null
    daysOff?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    cid10Code?: NullableStringFieldUpdateOperationsInput | string | null
    catIssued?: BoolFieldUpdateOperationsInput | boolean
    investigationStatus?: StringFieldUpdateOperationsInput | string
    reportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutAccidentsNestedInput
  }

  export type AccidentRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    cause?: StringFieldUpdateOperationsInput | string
    causeDetails?: NullableStringFieldUpdateOperationsInput | string | null
    daysOff?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    cid10Code?: NullableStringFieldUpdateOperationsInput | string | null
    catIssued?: BoolFieldUpdateOperationsInput | boolean
    investigationStatus?: StringFieldUpdateOperationsInput | string
    reportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccidentRecordCreateManyInput = {
    id?: string
    date: Date | string
    time?: string | null
    employeeId: string
    department: string
    location: string
    type: string
    cause: string
    causeDetails?: string | null
    daysOff?: number
    description: string
    cid10Code?: string | null
    catIssued?: boolean
    investigationStatus?: string
    reportUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccidentRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    department?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    cause?: StringFieldUpdateOperationsInput | string
    causeDetails?: NullableStringFieldUpdateOperationsInput | string | null
    daysOff?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    cid10Code?: NullableStringFieldUpdateOperationsInput | string | null
    catIssued?: BoolFieldUpdateOperationsInput | boolean
    investigationStatus?: StringFieldUpdateOperationsInput | string
    reportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccidentRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    cause?: StringFieldUpdateOperationsInput | string
    causeDetails?: NullableStringFieldUpdateOperationsInput | string | null
    daysOff?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    cid10Code?: NullableStringFieldUpdateOperationsInput | string | null
    catIssued?: BoolFieldUpdateOperationsInput | boolean
    investigationStatus?: StringFieldUpdateOperationsInput | string
    reportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OccupationalDiseaseRecordCreateInput = {
    id?: string
    diseaseType: string
    cid10Code: string
    diagnosisDate: Date | string
    relatedTask?: string | null
    daysOff?: number
    status?: string
    medicalReportUrl?: string | null
    pcmsoLink?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutDiseasesInput
  }

  export type OccupationalDiseaseRecordUncheckedCreateInput = {
    id?: string
    employeeId: string
    diseaseType: string
    cid10Code: string
    diagnosisDate: Date | string
    relatedTask?: string | null
    daysOff?: number
    status?: string
    medicalReportUrl?: string | null
    pcmsoLink?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OccupationalDiseaseRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    diseaseType?: StringFieldUpdateOperationsInput | string
    cid10Code?: StringFieldUpdateOperationsInput | string
    diagnosisDate?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedTask?: NullableStringFieldUpdateOperationsInput | string | null
    daysOff?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    medicalReportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pcmsoLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutDiseasesNestedInput
  }

  export type OccupationalDiseaseRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    diseaseType?: StringFieldUpdateOperationsInput | string
    cid10Code?: StringFieldUpdateOperationsInput | string
    diagnosisDate?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedTask?: NullableStringFieldUpdateOperationsInput | string | null
    daysOff?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    medicalReportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pcmsoLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OccupationalDiseaseRecordCreateManyInput = {
    id?: string
    employeeId: string
    diseaseType: string
    cid10Code: string
    diagnosisDate: Date | string
    relatedTask?: string | null
    daysOff?: number
    status?: string
    medicalReportUrl?: string | null
    pcmsoLink?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OccupationalDiseaseRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    diseaseType?: StringFieldUpdateOperationsInput | string
    cid10Code?: StringFieldUpdateOperationsInput | string
    diagnosisDate?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedTask?: NullableStringFieldUpdateOperationsInput | string | null
    daysOff?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    medicalReportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pcmsoLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OccupationalDiseaseRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    diseaseType?: StringFieldUpdateOperationsInput | string
    cid10Code?: StringFieldUpdateOperationsInput | string
    diagnosisDate?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedTask?: NullableStringFieldUpdateOperationsInput | string | null
    daysOff?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    medicalReportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pcmsoLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type PpeRecordListRelationFilter = {
    every?: PpeRecordWhereInput
    some?: PpeRecordWhereInput
    none?: PpeRecordWhereInput
  }

  export type AsoRecordListRelationFilter = {
    every?: AsoRecordWhereInput
    some?: AsoRecordWhereInput
    none?: AsoRecordWhereInput
  }

  export type TrainingRecordListRelationFilter = {
    every?: TrainingRecordWhereInput
    some?: TrainingRecordWhereInput
    none?: TrainingRecordWhereInput
  }

  export type AccidentRecordListRelationFilter = {
    every?: AccidentRecordWhereInput
    some?: AccidentRecordWhereInput
    none?: AccidentRecordWhereInput
  }

  export type OccupationalDiseaseRecordListRelationFilter = {
    every?: OccupationalDiseaseRecordWhereInput
    some?: OccupationalDiseaseRecordWhereInput
    none?: OccupationalDiseaseRecordWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PpeRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AsoRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrainingRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccidentRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OccupationalDiseaseRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    department?: SortOrder
    position?: SortOrder
    hireDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    department?: SortOrder
    position?: SortOrder
    hireDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    department?: SortOrder
    position?: SortOrder
    hireDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type TrainingTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    validityMonths?: SortOrder
    requiredNrsJson?: SortOrder
    defaultDuration?: SortOrder
    defaultLocation?: SortOrder
    defaultCost?: SortOrder
    instructorsJson?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingTypeAvgOrderByAggregateInput = {
    validityMonths?: SortOrder
    defaultDuration?: SortOrder
    defaultCost?: SortOrder
  }

  export type TrainingTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    validityMonths?: SortOrder
    requiredNrsJson?: SortOrder
    defaultDuration?: SortOrder
    defaultLocation?: SortOrder
    defaultCost?: SortOrder
    instructorsJson?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    validityMonths?: SortOrder
    requiredNrsJson?: SortOrder
    defaultDuration?: SortOrder
    defaultLocation?: SortOrder
    defaultCost?: SortOrder
    instructorsJson?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingTypeSumOrderByAggregateInput = {
    validityMonths?: SortOrder
    defaultDuration?: SortOrder
    defaultCost?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EmployeeScalarRelationFilter = {
    is?: EmployeeWhereInput
    isNot?: EmployeeWhereInput
  }

  export type TrainingTypeScalarRelationFilter = {
    is?: TrainingTypeWhereInput
    isNot?: TrainingTypeWhereInput
  }

  export type TrainingRecordCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    trainingTypeId?: SortOrder
    trainingDate?: SortOrder
    expiryDate?: SortOrder
    status?: SortOrder
    attendanceListUrl?: SortOrder
    certificateUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    trainingTypeId?: SortOrder
    trainingDate?: SortOrder
    expiryDate?: SortOrder
    status?: SortOrder
    attendanceListUrl?: SortOrder
    certificateUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingRecordMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    trainingTypeId?: SortOrder
    trainingDate?: SortOrder
    expiryDate?: SortOrder
    status?: SortOrder
    attendanceListUrl?: SortOrder
    certificateUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type PpeRecordCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    ppeType?: SortOrder
    caNumber?: SortOrder
    deliveryDate?: SortOrder
    quantity?: SortOrder
    returnDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PpeRecordAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type PpeRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    ppeType?: SortOrder
    caNumber?: SortOrder
    deliveryDate?: SortOrder
    quantity?: SortOrder
    returnDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PpeRecordMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    ppeType?: SortOrder
    caNumber?: SortOrder
    deliveryDate?: SortOrder
    quantity?: SortOrder
    returnDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PpeRecordSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type AsoRecordCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    examType?: SortOrder
    examDate?: SortOrder
    expiryDate?: SortOrder
    result?: SortOrder
    status?: SortOrder
    attachmentUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AsoRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    examType?: SortOrder
    examDate?: SortOrder
    expiryDate?: SortOrder
    result?: SortOrder
    status?: SortOrder
    attachmentUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AsoRecordMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    examType?: SortOrder
    examDate?: SortOrder
    expiryDate?: SortOrder
    result?: SortOrder
    status?: SortOrder
    attachmentUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ChemicalRecordCountOrderByAggregateInput = {
    id?: SortOrder
    productName?: SortOrder
    casNumber?: SortOrder
    location?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    sdsUrl?: SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChemicalRecordAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type ChemicalRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    productName?: SortOrder
    casNumber?: SortOrder
    location?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    sdsUrl?: SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChemicalRecordMinOrderByAggregateInput = {
    id?: SortOrder
    productName?: SortOrder
    casNumber?: SortOrder
    location?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    sdsUrl?: SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChemicalRecordSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type RiskItemListRelationFilter = {
    every?: RiskItemWhereInput
    some?: RiskItemWhereInput
    none?: RiskItemWhereInput
  }

  export type RiskItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JsaRecordCountOrderByAggregateInput = {
    id?: SortOrder
    taskName?: SortOrder
    department?: SortOrder
    analysisDate?: SortOrder
    reviewDate?: SortOrder
    status?: SortOrder
    attachmentUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JsaRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    taskName?: SortOrder
    department?: SortOrder
    analysisDate?: SortOrder
    reviewDate?: SortOrder
    status?: SortOrder
    attachmentUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JsaRecordMinOrderByAggregateInput = {
    id?: SortOrder
    taskName?: SortOrder
    department?: SortOrder
    analysisDate?: SortOrder
    reviewDate?: SortOrder
    status?: SortOrder
    attachmentUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JsaRecordScalarRelationFilter = {
    is?: JsaRecordWhereInput
    isNot?: JsaRecordWhereInput
  }

  export type RiskItemCountOrderByAggregateInput = {
    id?: SortOrder
    jsaId?: SortOrder
    description?: SortOrder
    controls?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RiskItemMaxOrderByAggregateInput = {
    id?: SortOrder
    jsaId?: SortOrder
    description?: SortOrder
    controls?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RiskItemMinOrderByAggregateInput = {
    id?: SortOrder
    jsaId?: SortOrder
    description?: SortOrder
    controls?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CipaActionListRelationFilter = {
    every?: CipaActionWhereInput
    some?: CipaActionWhereInput
    none?: CipaActionWhereInput
  }

  export type CipaActionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CipaMeetingCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    participantsJson?: SortOrder
    agenda?: SortOrder
    status?: SortOrder
    minutesUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CipaMeetingMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    participantsJson?: SortOrder
    agenda?: SortOrder
    status?: SortOrder
    minutesUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CipaMeetingMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    participantsJson?: SortOrder
    agenda?: SortOrder
    status?: SortOrder
    minutesUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CipaMeetingScalarRelationFilter = {
    is?: CipaMeetingWhereInput
    isNot?: CipaMeetingWhereInput
  }

  export type CipaActionCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    responsible?: SortOrder
    deadline?: SortOrder
    status?: SortOrder
    meetingId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CipaActionMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    responsible?: SortOrder
    deadline?: SortOrder
    status?: SortOrder
    meetingId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CipaActionMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    responsible?: SortOrder
    deadline?: SortOrder
    status?: SortOrder
    meetingId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PreventiveActionCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    category?: SortOrder
    responsible?: SortOrder
    frequency?: SortOrder
    dueDate?: SortOrder
    lastCompletedDate?: SortOrder
    status?: SortOrder
    evidenceUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PreventiveActionMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    category?: SortOrder
    responsible?: SortOrder
    frequency?: SortOrder
    dueDate?: SortOrder
    lastCompletedDate?: SortOrder
    status?: SortOrder
    evidenceUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PreventiveActionMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    category?: SortOrder
    responsible?: SortOrder
    frequency?: SortOrder
    dueDate?: SortOrder
    lastCompletedDate?: SortOrder
    status?: SortOrder
    evidenceUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentActionListRelationFilter = {
    every?: DocumentActionWhereInput
    some?: DocumentActionWhereInput
    none?: DocumentActionWhereInput
  }

  export type DocumentActionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentRecordCountOrderByAggregateInput = {
    id?: SortOrder
    documentType?: SortOrder
    title?: SortOrder
    issueDate?: SortOrder
    expiryDate?: SortOrder
    responsible?: SortOrder
    status?: SortOrder
    attachmentUrl?: SortOrder
    observations?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    documentType?: SortOrder
    title?: SortOrder
    issueDate?: SortOrder
    expiryDate?: SortOrder
    responsible?: SortOrder
    status?: SortOrder
    attachmentUrl?: SortOrder
    observations?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentRecordMinOrderByAggregateInput = {
    id?: SortOrder
    documentType?: SortOrder
    title?: SortOrder
    issueDate?: SortOrder
    expiryDate?: SortOrder
    responsible?: SortOrder
    status?: SortOrder
    attachmentUrl?: SortOrder
    observations?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentRecordScalarRelationFilter = {
    is?: DocumentRecordWhereInput
    isNot?: DocumentRecordWhereInput
  }

  export type DocumentActionCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    responsible?: SortOrder
    deadline?: SortOrder
    status?: SortOrder
    documentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentActionMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    responsible?: SortOrder
    deadline?: SortOrder
    status?: SortOrder
    documentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentActionMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    responsible?: SortOrder
    deadline?: SortOrder
    status?: SortOrder
    documentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LawsuitRecordCountOrderByAggregateInput = {
    id?: SortOrder
    processNumber?: SortOrder
    plaintiff?: SortOrder
    subject?: SortOrder
    status?: SortOrder
    filingDate?: SortOrder
    hearingDate?: SortOrder
    estimatedCost?: SortOrder
    finalCost?: SortOrder
    lawyer?: SortOrder
    details?: SortOrder
    relatedNRsJson?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LawsuitRecordAvgOrderByAggregateInput = {
    estimatedCost?: SortOrder
    finalCost?: SortOrder
  }

  export type LawsuitRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    processNumber?: SortOrder
    plaintiff?: SortOrder
    subject?: SortOrder
    status?: SortOrder
    filingDate?: SortOrder
    hearingDate?: SortOrder
    estimatedCost?: SortOrder
    finalCost?: SortOrder
    lawyer?: SortOrder
    details?: SortOrder
    relatedNRsJson?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LawsuitRecordMinOrderByAggregateInput = {
    id?: SortOrder
    processNumber?: SortOrder
    plaintiff?: SortOrder
    subject?: SortOrder
    status?: SortOrder
    filingDate?: SortOrder
    hearingDate?: SortOrder
    estimatedCost?: SortOrder
    finalCost?: SortOrder
    lawyer?: SortOrder
    details?: SortOrder
    relatedNRsJson?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LawsuitRecordSumOrderByAggregateInput = {
    estimatedCost?: SortOrder
    finalCost?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type AccidentRecordCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    time?: SortOrder
    employeeId?: SortOrder
    department?: SortOrder
    location?: SortOrder
    type?: SortOrder
    cause?: SortOrder
    causeDetails?: SortOrder
    daysOff?: SortOrder
    description?: SortOrder
    cid10Code?: SortOrder
    catIssued?: SortOrder
    investigationStatus?: SortOrder
    reportUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccidentRecordAvgOrderByAggregateInput = {
    daysOff?: SortOrder
  }

  export type AccidentRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    time?: SortOrder
    employeeId?: SortOrder
    department?: SortOrder
    location?: SortOrder
    type?: SortOrder
    cause?: SortOrder
    causeDetails?: SortOrder
    daysOff?: SortOrder
    description?: SortOrder
    cid10Code?: SortOrder
    catIssued?: SortOrder
    investigationStatus?: SortOrder
    reportUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccidentRecordMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    time?: SortOrder
    employeeId?: SortOrder
    department?: SortOrder
    location?: SortOrder
    type?: SortOrder
    cause?: SortOrder
    causeDetails?: SortOrder
    daysOff?: SortOrder
    description?: SortOrder
    cid10Code?: SortOrder
    catIssued?: SortOrder
    investigationStatus?: SortOrder
    reportUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccidentRecordSumOrderByAggregateInput = {
    daysOff?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type OccupationalDiseaseRecordCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    diseaseType?: SortOrder
    cid10Code?: SortOrder
    diagnosisDate?: SortOrder
    relatedTask?: SortOrder
    daysOff?: SortOrder
    status?: SortOrder
    medicalReportUrl?: SortOrder
    pcmsoLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OccupationalDiseaseRecordAvgOrderByAggregateInput = {
    daysOff?: SortOrder
  }

  export type OccupationalDiseaseRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    diseaseType?: SortOrder
    cid10Code?: SortOrder
    diagnosisDate?: SortOrder
    relatedTask?: SortOrder
    daysOff?: SortOrder
    status?: SortOrder
    medicalReportUrl?: SortOrder
    pcmsoLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OccupationalDiseaseRecordMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    diseaseType?: SortOrder
    cid10Code?: SortOrder
    diagnosisDate?: SortOrder
    relatedTask?: SortOrder
    daysOff?: SortOrder
    status?: SortOrder
    medicalReportUrl?: SortOrder
    pcmsoLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OccupationalDiseaseRecordSumOrderByAggregateInput = {
    daysOff?: SortOrder
  }

  export type PpeRecordCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<PpeRecordCreateWithoutEmployeeInput, PpeRecordUncheckedCreateWithoutEmployeeInput> | PpeRecordCreateWithoutEmployeeInput[] | PpeRecordUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PpeRecordCreateOrConnectWithoutEmployeeInput | PpeRecordCreateOrConnectWithoutEmployeeInput[]
    createMany?: PpeRecordCreateManyEmployeeInputEnvelope
    connect?: PpeRecordWhereUniqueInput | PpeRecordWhereUniqueInput[]
  }

  export type AsoRecordCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<AsoRecordCreateWithoutEmployeeInput, AsoRecordUncheckedCreateWithoutEmployeeInput> | AsoRecordCreateWithoutEmployeeInput[] | AsoRecordUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AsoRecordCreateOrConnectWithoutEmployeeInput | AsoRecordCreateOrConnectWithoutEmployeeInput[]
    createMany?: AsoRecordCreateManyEmployeeInputEnvelope
    connect?: AsoRecordWhereUniqueInput | AsoRecordWhereUniqueInput[]
  }

  export type TrainingRecordCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<TrainingRecordCreateWithoutEmployeeInput, TrainingRecordUncheckedCreateWithoutEmployeeInput> | TrainingRecordCreateWithoutEmployeeInput[] | TrainingRecordUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: TrainingRecordCreateOrConnectWithoutEmployeeInput | TrainingRecordCreateOrConnectWithoutEmployeeInput[]
    createMany?: TrainingRecordCreateManyEmployeeInputEnvelope
    connect?: TrainingRecordWhereUniqueInput | TrainingRecordWhereUniqueInput[]
  }

  export type AccidentRecordCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<AccidentRecordCreateWithoutEmployeeInput, AccidentRecordUncheckedCreateWithoutEmployeeInput> | AccidentRecordCreateWithoutEmployeeInput[] | AccidentRecordUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AccidentRecordCreateOrConnectWithoutEmployeeInput | AccidentRecordCreateOrConnectWithoutEmployeeInput[]
    createMany?: AccidentRecordCreateManyEmployeeInputEnvelope
    connect?: AccidentRecordWhereUniqueInput | AccidentRecordWhereUniqueInput[]
  }

  export type OccupationalDiseaseRecordCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<OccupationalDiseaseRecordCreateWithoutEmployeeInput, OccupationalDiseaseRecordUncheckedCreateWithoutEmployeeInput> | OccupationalDiseaseRecordCreateWithoutEmployeeInput[] | OccupationalDiseaseRecordUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: OccupationalDiseaseRecordCreateOrConnectWithoutEmployeeInput | OccupationalDiseaseRecordCreateOrConnectWithoutEmployeeInput[]
    createMany?: OccupationalDiseaseRecordCreateManyEmployeeInputEnvelope
    connect?: OccupationalDiseaseRecordWhereUniqueInput | OccupationalDiseaseRecordWhereUniqueInput[]
  }

  export type PpeRecordUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<PpeRecordCreateWithoutEmployeeInput, PpeRecordUncheckedCreateWithoutEmployeeInput> | PpeRecordCreateWithoutEmployeeInput[] | PpeRecordUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PpeRecordCreateOrConnectWithoutEmployeeInput | PpeRecordCreateOrConnectWithoutEmployeeInput[]
    createMany?: PpeRecordCreateManyEmployeeInputEnvelope
    connect?: PpeRecordWhereUniqueInput | PpeRecordWhereUniqueInput[]
  }

  export type AsoRecordUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<AsoRecordCreateWithoutEmployeeInput, AsoRecordUncheckedCreateWithoutEmployeeInput> | AsoRecordCreateWithoutEmployeeInput[] | AsoRecordUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AsoRecordCreateOrConnectWithoutEmployeeInput | AsoRecordCreateOrConnectWithoutEmployeeInput[]
    createMany?: AsoRecordCreateManyEmployeeInputEnvelope
    connect?: AsoRecordWhereUniqueInput | AsoRecordWhereUniqueInput[]
  }

  export type TrainingRecordUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<TrainingRecordCreateWithoutEmployeeInput, TrainingRecordUncheckedCreateWithoutEmployeeInput> | TrainingRecordCreateWithoutEmployeeInput[] | TrainingRecordUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: TrainingRecordCreateOrConnectWithoutEmployeeInput | TrainingRecordCreateOrConnectWithoutEmployeeInput[]
    createMany?: TrainingRecordCreateManyEmployeeInputEnvelope
    connect?: TrainingRecordWhereUniqueInput | TrainingRecordWhereUniqueInput[]
  }

  export type AccidentRecordUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<AccidentRecordCreateWithoutEmployeeInput, AccidentRecordUncheckedCreateWithoutEmployeeInput> | AccidentRecordCreateWithoutEmployeeInput[] | AccidentRecordUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AccidentRecordCreateOrConnectWithoutEmployeeInput | AccidentRecordCreateOrConnectWithoutEmployeeInput[]
    createMany?: AccidentRecordCreateManyEmployeeInputEnvelope
    connect?: AccidentRecordWhereUniqueInput | AccidentRecordWhereUniqueInput[]
  }

  export type OccupationalDiseaseRecordUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<OccupationalDiseaseRecordCreateWithoutEmployeeInput, OccupationalDiseaseRecordUncheckedCreateWithoutEmployeeInput> | OccupationalDiseaseRecordCreateWithoutEmployeeInput[] | OccupationalDiseaseRecordUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: OccupationalDiseaseRecordCreateOrConnectWithoutEmployeeInput | OccupationalDiseaseRecordCreateOrConnectWithoutEmployeeInput[]
    createMany?: OccupationalDiseaseRecordCreateManyEmployeeInputEnvelope
    connect?: OccupationalDiseaseRecordWhereUniqueInput | OccupationalDiseaseRecordWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type PpeRecordUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<PpeRecordCreateWithoutEmployeeInput, PpeRecordUncheckedCreateWithoutEmployeeInput> | PpeRecordCreateWithoutEmployeeInput[] | PpeRecordUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PpeRecordCreateOrConnectWithoutEmployeeInput | PpeRecordCreateOrConnectWithoutEmployeeInput[]
    upsert?: PpeRecordUpsertWithWhereUniqueWithoutEmployeeInput | PpeRecordUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: PpeRecordCreateManyEmployeeInputEnvelope
    set?: PpeRecordWhereUniqueInput | PpeRecordWhereUniqueInput[]
    disconnect?: PpeRecordWhereUniqueInput | PpeRecordWhereUniqueInput[]
    delete?: PpeRecordWhereUniqueInput | PpeRecordWhereUniqueInput[]
    connect?: PpeRecordWhereUniqueInput | PpeRecordWhereUniqueInput[]
    update?: PpeRecordUpdateWithWhereUniqueWithoutEmployeeInput | PpeRecordUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: PpeRecordUpdateManyWithWhereWithoutEmployeeInput | PpeRecordUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: PpeRecordScalarWhereInput | PpeRecordScalarWhereInput[]
  }

  export type AsoRecordUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<AsoRecordCreateWithoutEmployeeInput, AsoRecordUncheckedCreateWithoutEmployeeInput> | AsoRecordCreateWithoutEmployeeInput[] | AsoRecordUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AsoRecordCreateOrConnectWithoutEmployeeInput | AsoRecordCreateOrConnectWithoutEmployeeInput[]
    upsert?: AsoRecordUpsertWithWhereUniqueWithoutEmployeeInput | AsoRecordUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: AsoRecordCreateManyEmployeeInputEnvelope
    set?: AsoRecordWhereUniqueInput | AsoRecordWhereUniqueInput[]
    disconnect?: AsoRecordWhereUniqueInput | AsoRecordWhereUniqueInput[]
    delete?: AsoRecordWhereUniqueInput | AsoRecordWhereUniqueInput[]
    connect?: AsoRecordWhereUniqueInput | AsoRecordWhereUniqueInput[]
    update?: AsoRecordUpdateWithWhereUniqueWithoutEmployeeInput | AsoRecordUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: AsoRecordUpdateManyWithWhereWithoutEmployeeInput | AsoRecordUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: AsoRecordScalarWhereInput | AsoRecordScalarWhereInput[]
  }

  export type TrainingRecordUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<TrainingRecordCreateWithoutEmployeeInput, TrainingRecordUncheckedCreateWithoutEmployeeInput> | TrainingRecordCreateWithoutEmployeeInput[] | TrainingRecordUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: TrainingRecordCreateOrConnectWithoutEmployeeInput | TrainingRecordCreateOrConnectWithoutEmployeeInput[]
    upsert?: TrainingRecordUpsertWithWhereUniqueWithoutEmployeeInput | TrainingRecordUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: TrainingRecordCreateManyEmployeeInputEnvelope
    set?: TrainingRecordWhereUniqueInput | TrainingRecordWhereUniqueInput[]
    disconnect?: TrainingRecordWhereUniqueInput | TrainingRecordWhereUniqueInput[]
    delete?: TrainingRecordWhereUniqueInput | TrainingRecordWhereUniqueInput[]
    connect?: TrainingRecordWhereUniqueInput | TrainingRecordWhereUniqueInput[]
    update?: TrainingRecordUpdateWithWhereUniqueWithoutEmployeeInput | TrainingRecordUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: TrainingRecordUpdateManyWithWhereWithoutEmployeeInput | TrainingRecordUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: TrainingRecordScalarWhereInput | TrainingRecordScalarWhereInput[]
  }

  export type AccidentRecordUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<AccidentRecordCreateWithoutEmployeeInput, AccidentRecordUncheckedCreateWithoutEmployeeInput> | AccidentRecordCreateWithoutEmployeeInput[] | AccidentRecordUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AccidentRecordCreateOrConnectWithoutEmployeeInput | AccidentRecordCreateOrConnectWithoutEmployeeInput[]
    upsert?: AccidentRecordUpsertWithWhereUniqueWithoutEmployeeInput | AccidentRecordUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: AccidentRecordCreateManyEmployeeInputEnvelope
    set?: AccidentRecordWhereUniqueInput | AccidentRecordWhereUniqueInput[]
    disconnect?: AccidentRecordWhereUniqueInput | AccidentRecordWhereUniqueInput[]
    delete?: AccidentRecordWhereUniqueInput | AccidentRecordWhereUniqueInput[]
    connect?: AccidentRecordWhereUniqueInput | AccidentRecordWhereUniqueInput[]
    update?: AccidentRecordUpdateWithWhereUniqueWithoutEmployeeInput | AccidentRecordUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: AccidentRecordUpdateManyWithWhereWithoutEmployeeInput | AccidentRecordUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: AccidentRecordScalarWhereInput | AccidentRecordScalarWhereInput[]
  }

  export type OccupationalDiseaseRecordUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<OccupationalDiseaseRecordCreateWithoutEmployeeInput, OccupationalDiseaseRecordUncheckedCreateWithoutEmployeeInput> | OccupationalDiseaseRecordCreateWithoutEmployeeInput[] | OccupationalDiseaseRecordUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: OccupationalDiseaseRecordCreateOrConnectWithoutEmployeeInput | OccupationalDiseaseRecordCreateOrConnectWithoutEmployeeInput[]
    upsert?: OccupationalDiseaseRecordUpsertWithWhereUniqueWithoutEmployeeInput | OccupationalDiseaseRecordUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: OccupationalDiseaseRecordCreateManyEmployeeInputEnvelope
    set?: OccupationalDiseaseRecordWhereUniqueInput | OccupationalDiseaseRecordWhereUniqueInput[]
    disconnect?: OccupationalDiseaseRecordWhereUniqueInput | OccupationalDiseaseRecordWhereUniqueInput[]
    delete?: OccupationalDiseaseRecordWhereUniqueInput | OccupationalDiseaseRecordWhereUniqueInput[]
    connect?: OccupationalDiseaseRecordWhereUniqueInput | OccupationalDiseaseRecordWhereUniqueInput[]
    update?: OccupationalDiseaseRecordUpdateWithWhereUniqueWithoutEmployeeInput | OccupationalDiseaseRecordUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: OccupationalDiseaseRecordUpdateManyWithWhereWithoutEmployeeInput | OccupationalDiseaseRecordUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: OccupationalDiseaseRecordScalarWhereInput | OccupationalDiseaseRecordScalarWhereInput[]
  }

  export type PpeRecordUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<PpeRecordCreateWithoutEmployeeInput, PpeRecordUncheckedCreateWithoutEmployeeInput> | PpeRecordCreateWithoutEmployeeInput[] | PpeRecordUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PpeRecordCreateOrConnectWithoutEmployeeInput | PpeRecordCreateOrConnectWithoutEmployeeInput[]
    upsert?: PpeRecordUpsertWithWhereUniqueWithoutEmployeeInput | PpeRecordUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: PpeRecordCreateManyEmployeeInputEnvelope
    set?: PpeRecordWhereUniqueInput | PpeRecordWhereUniqueInput[]
    disconnect?: PpeRecordWhereUniqueInput | PpeRecordWhereUniqueInput[]
    delete?: PpeRecordWhereUniqueInput | PpeRecordWhereUniqueInput[]
    connect?: PpeRecordWhereUniqueInput | PpeRecordWhereUniqueInput[]
    update?: PpeRecordUpdateWithWhereUniqueWithoutEmployeeInput | PpeRecordUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: PpeRecordUpdateManyWithWhereWithoutEmployeeInput | PpeRecordUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: PpeRecordScalarWhereInput | PpeRecordScalarWhereInput[]
  }

  export type AsoRecordUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<AsoRecordCreateWithoutEmployeeInput, AsoRecordUncheckedCreateWithoutEmployeeInput> | AsoRecordCreateWithoutEmployeeInput[] | AsoRecordUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AsoRecordCreateOrConnectWithoutEmployeeInput | AsoRecordCreateOrConnectWithoutEmployeeInput[]
    upsert?: AsoRecordUpsertWithWhereUniqueWithoutEmployeeInput | AsoRecordUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: AsoRecordCreateManyEmployeeInputEnvelope
    set?: AsoRecordWhereUniqueInput | AsoRecordWhereUniqueInput[]
    disconnect?: AsoRecordWhereUniqueInput | AsoRecordWhereUniqueInput[]
    delete?: AsoRecordWhereUniqueInput | AsoRecordWhereUniqueInput[]
    connect?: AsoRecordWhereUniqueInput | AsoRecordWhereUniqueInput[]
    update?: AsoRecordUpdateWithWhereUniqueWithoutEmployeeInput | AsoRecordUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: AsoRecordUpdateManyWithWhereWithoutEmployeeInput | AsoRecordUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: AsoRecordScalarWhereInput | AsoRecordScalarWhereInput[]
  }

  export type TrainingRecordUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<TrainingRecordCreateWithoutEmployeeInput, TrainingRecordUncheckedCreateWithoutEmployeeInput> | TrainingRecordCreateWithoutEmployeeInput[] | TrainingRecordUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: TrainingRecordCreateOrConnectWithoutEmployeeInput | TrainingRecordCreateOrConnectWithoutEmployeeInput[]
    upsert?: TrainingRecordUpsertWithWhereUniqueWithoutEmployeeInput | TrainingRecordUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: TrainingRecordCreateManyEmployeeInputEnvelope
    set?: TrainingRecordWhereUniqueInput | TrainingRecordWhereUniqueInput[]
    disconnect?: TrainingRecordWhereUniqueInput | TrainingRecordWhereUniqueInput[]
    delete?: TrainingRecordWhereUniqueInput | TrainingRecordWhereUniqueInput[]
    connect?: TrainingRecordWhereUniqueInput | TrainingRecordWhereUniqueInput[]
    update?: TrainingRecordUpdateWithWhereUniqueWithoutEmployeeInput | TrainingRecordUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: TrainingRecordUpdateManyWithWhereWithoutEmployeeInput | TrainingRecordUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: TrainingRecordScalarWhereInput | TrainingRecordScalarWhereInput[]
  }

  export type AccidentRecordUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<AccidentRecordCreateWithoutEmployeeInput, AccidentRecordUncheckedCreateWithoutEmployeeInput> | AccidentRecordCreateWithoutEmployeeInput[] | AccidentRecordUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AccidentRecordCreateOrConnectWithoutEmployeeInput | AccidentRecordCreateOrConnectWithoutEmployeeInput[]
    upsert?: AccidentRecordUpsertWithWhereUniqueWithoutEmployeeInput | AccidentRecordUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: AccidentRecordCreateManyEmployeeInputEnvelope
    set?: AccidentRecordWhereUniqueInput | AccidentRecordWhereUniqueInput[]
    disconnect?: AccidentRecordWhereUniqueInput | AccidentRecordWhereUniqueInput[]
    delete?: AccidentRecordWhereUniqueInput | AccidentRecordWhereUniqueInput[]
    connect?: AccidentRecordWhereUniqueInput | AccidentRecordWhereUniqueInput[]
    update?: AccidentRecordUpdateWithWhereUniqueWithoutEmployeeInput | AccidentRecordUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: AccidentRecordUpdateManyWithWhereWithoutEmployeeInput | AccidentRecordUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: AccidentRecordScalarWhereInput | AccidentRecordScalarWhereInput[]
  }

  export type OccupationalDiseaseRecordUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<OccupationalDiseaseRecordCreateWithoutEmployeeInput, OccupationalDiseaseRecordUncheckedCreateWithoutEmployeeInput> | OccupationalDiseaseRecordCreateWithoutEmployeeInput[] | OccupationalDiseaseRecordUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: OccupationalDiseaseRecordCreateOrConnectWithoutEmployeeInput | OccupationalDiseaseRecordCreateOrConnectWithoutEmployeeInput[]
    upsert?: OccupationalDiseaseRecordUpsertWithWhereUniqueWithoutEmployeeInput | OccupationalDiseaseRecordUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: OccupationalDiseaseRecordCreateManyEmployeeInputEnvelope
    set?: OccupationalDiseaseRecordWhereUniqueInput | OccupationalDiseaseRecordWhereUniqueInput[]
    disconnect?: OccupationalDiseaseRecordWhereUniqueInput | OccupationalDiseaseRecordWhereUniqueInput[]
    delete?: OccupationalDiseaseRecordWhereUniqueInput | OccupationalDiseaseRecordWhereUniqueInput[]
    connect?: OccupationalDiseaseRecordWhereUniqueInput | OccupationalDiseaseRecordWhereUniqueInput[]
    update?: OccupationalDiseaseRecordUpdateWithWhereUniqueWithoutEmployeeInput | OccupationalDiseaseRecordUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: OccupationalDiseaseRecordUpdateManyWithWhereWithoutEmployeeInput | OccupationalDiseaseRecordUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: OccupationalDiseaseRecordScalarWhereInput | OccupationalDiseaseRecordScalarWhereInput[]
  }

  export type TrainingRecordCreateNestedManyWithoutTrainingTypeInput = {
    create?: XOR<TrainingRecordCreateWithoutTrainingTypeInput, TrainingRecordUncheckedCreateWithoutTrainingTypeInput> | TrainingRecordCreateWithoutTrainingTypeInput[] | TrainingRecordUncheckedCreateWithoutTrainingTypeInput[]
    connectOrCreate?: TrainingRecordCreateOrConnectWithoutTrainingTypeInput | TrainingRecordCreateOrConnectWithoutTrainingTypeInput[]
    createMany?: TrainingRecordCreateManyTrainingTypeInputEnvelope
    connect?: TrainingRecordWhereUniqueInput | TrainingRecordWhereUniqueInput[]
  }

  export type TrainingRecordUncheckedCreateNestedManyWithoutTrainingTypeInput = {
    create?: XOR<TrainingRecordCreateWithoutTrainingTypeInput, TrainingRecordUncheckedCreateWithoutTrainingTypeInput> | TrainingRecordCreateWithoutTrainingTypeInput[] | TrainingRecordUncheckedCreateWithoutTrainingTypeInput[]
    connectOrCreate?: TrainingRecordCreateOrConnectWithoutTrainingTypeInput | TrainingRecordCreateOrConnectWithoutTrainingTypeInput[]
    createMany?: TrainingRecordCreateManyTrainingTypeInputEnvelope
    connect?: TrainingRecordWhereUniqueInput | TrainingRecordWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TrainingRecordUpdateManyWithoutTrainingTypeNestedInput = {
    create?: XOR<TrainingRecordCreateWithoutTrainingTypeInput, TrainingRecordUncheckedCreateWithoutTrainingTypeInput> | TrainingRecordCreateWithoutTrainingTypeInput[] | TrainingRecordUncheckedCreateWithoutTrainingTypeInput[]
    connectOrCreate?: TrainingRecordCreateOrConnectWithoutTrainingTypeInput | TrainingRecordCreateOrConnectWithoutTrainingTypeInput[]
    upsert?: TrainingRecordUpsertWithWhereUniqueWithoutTrainingTypeInput | TrainingRecordUpsertWithWhereUniqueWithoutTrainingTypeInput[]
    createMany?: TrainingRecordCreateManyTrainingTypeInputEnvelope
    set?: TrainingRecordWhereUniqueInput | TrainingRecordWhereUniqueInput[]
    disconnect?: TrainingRecordWhereUniqueInput | TrainingRecordWhereUniqueInput[]
    delete?: TrainingRecordWhereUniqueInput | TrainingRecordWhereUniqueInput[]
    connect?: TrainingRecordWhereUniqueInput | TrainingRecordWhereUniqueInput[]
    update?: TrainingRecordUpdateWithWhereUniqueWithoutTrainingTypeInput | TrainingRecordUpdateWithWhereUniqueWithoutTrainingTypeInput[]
    updateMany?: TrainingRecordUpdateManyWithWhereWithoutTrainingTypeInput | TrainingRecordUpdateManyWithWhereWithoutTrainingTypeInput[]
    deleteMany?: TrainingRecordScalarWhereInput | TrainingRecordScalarWhereInput[]
  }

  export type TrainingRecordUncheckedUpdateManyWithoutTrainingTypeNestedInput = {
    create?: XOR<TrainingRecordCreateWithoutTrainingTypeInput, TrainingRecordUncheckedCreateWithoutTrainingTypeInput> | TrainingRecordCreateWithoutTrainingTypeInput[] | TrainingRecordUncheckedCreateWithoutTrainingTypeInput[]
    connectOrCreate?: TrainingRecordCreateOrConnectWithoutTrainingTypeInput | TrainingRecordCreateOrConnectWithoutTrainingTypeInput[]
    upsert?: TrainingRecordUpsertWithWhereUniqueWithoutTrainingTypeInput | TrainingRecordUpsertWithWhereUniqueWithoutTrainingTypeInput[]
    createMany?: TrainingRecordCreateManyTrainingTypeInputEnvelope
    set?: TrainingRecordWhereUniqueInput | TrainingRecordWhereUniqueInput[]
    disconnect?: TrainingRecordWhereUniqueInput | TrainingRecordWhereUniqueInput[]
    delete?: TrainingRecordWhereUniqueInput | TrainingRecordWhereUniqueInput[]
    connect?: TrainingRecordWhereUniqueInput | TrainingRecordWhereUniqueInput[]
    update?: TrainingRecordUpdateWithWhereUniqueWithoutTrainingTypeInput | TrainingRecordUpdateWithWhereUniqueWithoutTrainingTypeInput[]
    updateMany?: TrainingRecordUpdateManyWithWhereWithoutTrainingTypeInput | TrainingRecordUpdateManyWithWhereWithoutTrainingTypeInput[]
    deleteMany?: TrainingRecordScalarWhereInput | TrainingRecordScalarWhereInput[]
  }

  export type EmployeeCreateNestedOneWithoutTrainingsInput = {
    create?: XOR<EmployeeCreateWithoutTrainingsInput, EmployeeUncheckedCreateWithoutTrainingsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutTrainingsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type TrainingTypeCreateNestedOneWithoutTrainingRecordsInput = {
    create?: XOR<TrainingTypeCreateWithoutTrainingRecordsInput, TrainingTypeUncheckedCreateWithoutTrainingRecordsInput>
    connectOrCreate?: TrainingTypeCreateOrConnectWithoutTrainingRecordsInput
    connect?: TrainingTypeWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutTrainingsNestedInput = {
    create?: XOR<EmployeeCreateWithoutTrainingsInput, EmployeeUncheckedCreateWithoutTrainingsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutTrainingsInput
    upsert?: EmployeeUpsertWithoutTrainingsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutTrainingsInput, EmployeeUpdateWithoutTrainingsInput>, EmployeeUncheckedUpdateWithoutTrainingsInput>
  }

  export type TrainingTypeUpdateOneRequiredWithoutTrainingRecordsNestedInput = {
    create?: XOR<TrainingTypeCreateWithoutTrainingRecordsInput, TrainingTypeUncheckedCreateWithoutTrainingRecordsInput>
    connectOrCreate?: TrainingTypeCreateOrConnectWithoutTrainingRecordsInput
    upsert?: TrainingTypeUpsertWithoutTrainingRecordsInput
    connect?: TrainingTypeWhereUniqueInput
    update?: XOR<XOR<TrainingTypeUpdateToOneWithWhereWithoutTrainingRecordsInput, TrainingTypeUpdateWithoutTrainingRecordsInput>, TrainingTypeUncheckedUpdateWithoutTrainingRecordsInput>
  }

  export type EmployeeCreateNestedOneWithoutPpeRecordsInput = {
    create?: XOR<EmployeeCreateWithoutPpeRecordsInput, EmployeeUncheckedCreateWithoutPpeRecordsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutPpeRecordsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EmployeeUpdateOneRequiredWithoutPpeRecordsNestedInput = {
    create?: XOR<EmployeeCreateWithoutPpeRecordsInput, EmployeeUncheckedCreateWithoutPpeRecordsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutPpeRecordsInput
    upsert?: EmployeeUpsertWithoutPpeRecordsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutPpeRecordsInput, EmployeeUpdateWithoutPpeRecordsInput>, EmployeeUncheckedUpdateWithoutPpeRecordsInput>
  }

  export type EmployeeCreateNestedOneWithoutAsoRecordsInput = {
    create?: XOR<EmployeeCreateWithoutAsoRecordsInput, EmployeeUncheckedCreateWithoutAsoRecordsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAsoRecordsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutAsoRecordsNestedInput = {
    create?: XOR<EmployeeCreateWithoutAsoRecordsInput, EmployeeUncheckedCreateWithoutAsoRecordsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAsoRecordsInput
    upsert?: EmployeeUpsertWithoutAsoRecordsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutAsoRecordsInput, EmployeeUpdateWithoutAsoRecordsInput>, EmployeeUncheckedUpdateWithoutAsoRecordsInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RiskItemCreateNestedManyWithoutJsaInput = {
    create?: XOR<RiskItemCreateWithoutJsaInput, RiskItemUncheckedCreateWithoutJsaInput> | RiskItemCreateWithoutJsaInput[] | RiskItemUncheckedCreateWithoutJsaInput[]
    connectOrCreate?: RiskItemCreateOrConnectWithoutJsaInput | RiskItemCreateOrConnectWithoutJsaInput[]
    createMany?: RiskItemCreateManyJsaInputEnvelope
    connect?: RiskItemWhereUniqueInput | RiskItemWhereUniqueInput[]
  }

  export type RiskItemUncheckedCreateNestedManyWithoutJsaInput = {
    create?: XOR<RiskItemCreateWithoutJsaInput, RiskItemUncheckedCreateWithoutJsaInput> | RiskItemCreateWithoutJsaInput[] | RiskItemUncheckedCreateWithoutJsaInput[]
    connectOrCreate?: RiskItemCreateOrConnectWithoutJsaInput | RiskItemCreateOrConnectWithoutJsaInput[]
    createMany?: RiskItemCreateManyJsaInputEnvelope
    connect?: RiskItemWhereUniqueInput | RiskItemWhereUniqueInput[]
  }

  export type RiskItemUpdateManyWithoutJsaNestedInput = {
    create?: XOR<RiskItemCreateWithoutJsaInput, RiskItemUncheckedCreateWithoutJsaInput> | RiskItemCreateWithoutJsaInput[] | RiskItemUncheckedCreateWithoutJsaInput[]
    connectOrCreate?: RiskItemCreateOrConnectWithoutJsaInput | RiskItemCreateOrConnectWithoutJsaInput[]
    upsert?: RiskItemUpsertWithWhereUniqueWithoutJsaInput | RiskItemUpsertWithWhereUniqueWithoutJsaInput[]
    createMany?: RiskItemCreateManyJsaInputEnvelope
    set?: RiskItemWhereUniqueInput | RiskItemWhereUniqueInput[]
    disconnect?: RiskItemWhereUniqueInput | RiskItemWhereUniqueInput[]
    delete?: RiskItemWhereUniqueInput | RiskItemWhereUniqueInput[]
    connect?: RiskItemWhereUniqueInput | RiskItemWhereUniqueInput[]
    update?: RiskItemUpdateWithWhereUniqueWithoutJsaInput | RiskItemUpdateWithWhereUniqueWithoutJsaInput[]
    updateMany?: RiskItemUpdateManyWithWhereWithoutJsaInput | RiskItemUpdateManyWithWhereWithoutJsaInput[]
    deleteMany?: RiskItemScalarWhereInput | RiskItemScalarWhereInput[]
  }

  export type RiskItemUncheckedUpdateManyWithoutJsaNestedInput = {
    create?: XOR<RiskItemCreateWithoutJsaInput, RiskItemUncheckedCreateWithoutJsaInput> | RiskItemCreateWithoutJsaInput[] | RiskItemUncheckedCreateWithoutJsaInput[]
    connectOrCreate?: RiskItemCreateOrConnectWithoutJsaInput | RiskItemCreateOrConnectWithoutJsaInput[]
    upsert?: RiskItemUpsertWithWhereUniqueWithoutJsaInput | RiskItemUpsertWithWhereUniqueWithoutJsaInput[]
    createMany?: RiskItemCreateManyJsaInputEnvelope
    set?: RiskItemWhereUniqueInput | RiskItemWhereUniqueInput[]
    disconnect?: RiskItemWhereUniqueInput | RiskItemWhereUniqueInput[]
    delete?: RiskItemWhereUniqueInput | RiskItemWhereUniqueInput[]
    connect?: RiskItemWhereUniqueInput | RiskItemWhereUniqueInput[]
    update?: RiskItemUpdateWithWhereUniqueWithoutJsaInput | RiskItemUpdateWithWhereUniqueWithoutJsaInput[]
    updateMany?: RiskItemUpdateManyWithWhereWithoutJsaInput | RiskItemUpdateManyWithWhereWithoutJsaInput[]
    deleteMany?: RiskItemScalarWhereInput | RiskItemScalarWhereInput[]
  }

  export type JsaRecordCreateNestedOneWithoutRisksInput = {
    create?: XOR<JsaRecordCreateWithoutRisksInput, JsaRecordUncheckedCreateWithoutRisksInput>
    connectOrCreate?: JsaRecordCreateOrConnectWithoutRisksInput
    connect?: JsaRecordWhereUniqueInput
  }

  export type JsaRecordUpdateOneRequiredWithoutRisksNestedInput = {
    create?: XOR<JsaRecordCreateWithoutRisksInput, JsaRecordUncheckedCreateWithoutRisksInput>
    connectOrCreate?: JsaRecordCreateOrConnectWithoutRisksInput
    upsert?: JsaRecordUpsertWithoutRisksInput
    connect?: JsaRecordWhereUniqueInput
    update?: XOR<XOR<JsaRecordUpdateToOneWithWhereWithoutRisksInput, JsaRecordUpdateWithoutRisksInput>, JsaRecordUncheckedUpdateWithoutRisksInput>
  }

  export type CipaActionCreateNestedManyWithoutMeetingInput = {
    create?: XOR<CipaActionCreateWithoutMeetingInput, CipaActionUncheckedCreateWithoutMeetingInput> | CipaActionCreateWithoutMeetingInput[] | CipaActionUncheckedCreateWithoutMeetingInput[]
    connectOrCreate?: CipaActionCreateOrConnectWithoutMeetingInput | CipaActionCreateOrConnectWithoutMeetingInput[]
    createMany?: CipaActionCreateManyMeetingInputEnvelope
    connect?: CipaActionWhereUniqueInput | CipaActionWhereUniqueInput[]
  }

  export type CipaActionUncheckedCreateNestedManyWithoutMeetingInput = {
    create?: XOR<CipaActionCreateWithoutMeetingInput, CipaActionUncheckedCreateWithoutMeetingInput> | CipaActionCreateWithoutMeetingInput[] | CipaActionUncheckedCreateWithoutMeetingInput[]
    connectOrCreate?: CipaActionCreateOrConnectWithoutMeetingInput | CipaActionCreateOrConnectWithoutMeetingInput[]
    createMany?: CipaActionCreateManyMeetingInputEnvelope
    connect?: CipaActionWhereUniqueInput | CipaActionWhereUniqueInput[]
  }

  export type CipaActionUpdateManyWithoutMeetingNestedInput = {
    create?: XOR<CipaActionCreateWithoutMeetingInput, CipaActionUncheckedCreateWithoutMeetingInput> | CipaActionCreateWithoutMeetingInput[] | CipaActionUncheckedCreateWithoutMeetingInput[]
    connectOrCreate?: CipaActionCreateOrConnectWithoutMeetingInput | CipaActionCreateOrConnectWithoutMeetingInput[]
    upsert?: CipaActionUpsertWithWhereUniqueWithoutMeetingInput | CipaActionUpsertWithWhereUniqueWithoutMeetingInput[]
    createMany?: CipaActionCreateManyMeetingInputEnvelope
    set?: CipaActionWhereUniqueInput | CipaActionWhereUniqueInput[]
    disconnect?: CipaActionWhereUniqueInput | CipaActionWhereUniqueInput[]
    delete?: CipaActionWhereUniqueInput | CipaActionWhereUniqueInput[]
    connect?: CipaActionWhereUniqueInput | CipaActionWhereUniqueInput[]
    update?: CipaActionUpdateWithWhereUniqueWithoutMeetingInput | CipaActionUpdateWithWhereUniqueWithoutMeetingInput[]
    updateMany?: CipaActionUpdateManyWithWhereWithoutMeetingInput | CipaActionUpdateManyWithWhereWithoutMeetingInput[]
    deleteMany?: CipaActionScalarWhereInput | CipaActionScalarWhereInput[]
  }

  export type CipaActionUncheckedUpdateManyWithoutMeetingNestedInput = {
    create?: XOR<CipaActionCreateWithoutMeetingInput, CipaActionUncheckedCreateWithoutMeetingInput> | CipaActionCreateWithoutMeetingInput[] | CipaActionUncheckedCreateWithoutMeetingInput[]
    connectOrCreate?: CipaActionCreateOrConnectWithoutMeetingInput | CipaActionCreateOrConnectWithoutMeetingInput[]
    upsert?: CipaActionUpsertWithWhereUniqueWithoutMeetingInput | CipaActionUpsertWithWhereUniqueWithoutMeetingInput[]
    createMany?: CipaActionCreateManyMeetingInputEnvelope
    set?: CipaActionWhereUniqueInput | CipaActionWhereUniqueInput[]
    disconnect?: CipaActionWhereUniqueInput | CipaActionWhereUniqueInput[]
    delete?: CipaActionWhereUniqueInput | CipaActionWhereUniqueInput[]
    connect?: CipaActionWhereUniqueInput | CipaActionWhereUniqueInput[]
    update?: CipaActionUpdateWithWhereUniqueWithoutMeetingInput | CipaActionUpdateWithWhereUniqueWithoutMeetingInput[]
    updateMany?: CipaActionUpdateManyWithWhereWithoutMeetingInput | CipaActionUpdateManyWithWhereWithoutMeetingInput[]
    deleteMany?: CipaActionScalarWhereInput | CipaActionScalarWhereInput[]
  }

  export type CipaMeetingCreateNestedOneWithoutActionsDefinedInput = {
    create?: XOR<CipaMeetingCreateWithoutActionsDefinedInput, CipaMeetingUncheckedCreateWithoutActionsDefinedInput>
    connectOrCreate?: CipaMeetingCreateOrConnectWithoutActionsDefinedInput
    connect?: CipaMeetingWhereUniqueInput
  }

  export type CipaMeetingUpdateOneRequiredWithoutActionsDefinedNestedInput = {
    create?: XOR<CipaMeetingCreateWithoutActionsDefinedInput, CipaMeetingUncheckedCreateWithoutActionsDefinedInput>
    connectOrCreate?: CipaMeetingCreateOrConnectWithoutActionsDefinedInput
    upsert?: CipaMeetingUpsertWithoutActionsDefinedInput
    connect?: CipaMeetingWhereUniqueInput
    update?: XOR<XOR<CipaMeetingUpdateToOneWithWhereWithoutActionsDefinedInput, CipaMeetingUpdateWithoutActionsDefinedInput>, CipaMeetingUncheckedUpdateWithoutActionsDefinedInput>
  }

  export type DocumentActionCreateNestedManyWithoutDocumentInput = {
    create?: XOR<DocumentActionCreateWithoutDocumentInput, DocumentActionUncheckedCreateWithoutDocumentInput> | DocumentActionCreateWithoutDocumentInput[] | DocumentActionUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentActionCreateOrConnectWithoutDocumentInput | DocumentActionCreateOrConnectWithoutDocumentInput[]
    createMany?: DocumentActionCreateManyDocumentInputEnvelope
    connect?: DocumentActionWhereUniqueInput | DocumentActionWhereUniqueInput[]
  }

  export type DocumentActionUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<DocumentActionCreateWithoutDocumentInput, DocumentActionUncheckedCreateWithoutDocumentInput> | DocumentActionCreateWithoutDocumentInput[] | DocumentActionUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentActionCreateOrConnectWithoutDocumentInput | DocumentActionCreateOrConnectWithoutDocumentInput[]
    createMany?: DocumentActionCreateManyDocumentInputEnvelope
    connect?: DocumentActionWhereUniqueInput | DocumentActionWhereUniqueInput[]
  }

  export type DocumentActionUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<DocumentActionCreateWithoutDocumentInput, DocumentActionUncheckedCreateWithoutDocumentInput> | DocumentActionCreateWithoutDocumentInput[] | DocumentActionUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentActionCreateOrConnectWithoutDocumentInput | DocumentActionCreateOrConnectWithoutDocumentInput[]
    upsert?: DocumentActionUpsertWithWhereUniqueWithoutDocumentInput | DocumentActionUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: DocumentActionCreateManyDocumentInputEnvelope
    set?: DocumentActionWhereUniqueInput | DocumentActionWhereUniqueInput[]
    disconnect?: DocumentActionWhereUniqueInput | DocumentActionWhereUniqueInput[]
    delete?: DocumentActionWhereUniqueInput | DocumentActionWhereUniqueInput[]
    connect?: DocumentActionWhereUniqueInput | DocumentActionWhereUniqueInput[]
    update?: DocumentActionUpdateWithWhereUniqueWithoutDocumentInput | DocumentActionUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: DocumentActionUpdateManyWithWhereWithoutDocumentInput | DocumentActionUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: DocumentActionScalarWhereInput | DocumentActionScalarWhereInput[]
  }

  export type DocumentActionUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<DocumentActionCreateWithoutDocumentInput, DocumentActionUncheckedCreateWithoutDocumentInput> | DocumentActionCreateWithoutDocumentInput[] | DocumentActionUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentActionCreateOrConnectWithoutDocumentInput | DocumentActionCreateOrConnectWithoutDocumentInput[]
    upsert?: DocumentActionUpsertWithWhereUniqueWithoutDocumentInput | DocumentActionUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: DocumentActionCreateManyDocumentInputEnvelope
    set?: DocumentActionWhereUniqueInput | DocumentActionWhereUniqueInput[]
    disconnect?: DocumentActionWhereUniqueInput | DocumentActionWhereUniqueInput[]
    delete?: DocumentActionWhereUniqueInput | DocumentActionWhereUniqueInput[]
    connect?: DocumentActionWhereUniqueInput | DocumentActionWhereUniqueInput[]
    update?: DocumentActionUpdateWithWhereUniqueWithoutDocumentInput | DocumentActionUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: DocumentActionUpdateManyWithWhereWithoutDocumentInput | DocumentActionUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: DocumentActionScalarWhereInput | DocumentActionScalarWhereInput[]
  }

  export type DocumentRecordCreateNestedOneWithoutRelatedActionsInput = {
    create?: XOR<DocumentRecordCreateWithoutRelatedActionsInput, DocumentRecordUncheckedCreateWithoutRelatedActionsInput>
    connectOrCreate?: DocumentRecordCreateOrConnectWithoutRelatedActionsInput
    connect?: DocumentRecordWhereUniqueInput
  }

  export type DocumentRecordUpdateOneRequiredWithoutRelatedActionsNestedInput = {
    create?: XOR<DocumentRecordCreateWithoutRelatedActionsInput, DocumentRecordUncheckedCreateWithoutRelatedActionsInput>
    connectOrCreate?: DocumentRecordCreateOrConnectWithoutRelatedActionsInput
    upsert?: DocumentRecordUpsertWithoutRelatedActionsInput
    connect?: DocumentRecordWhereUniqueInput
    update?: XOR<XOR<DocumentRecordUpdateToOneWithWhereWithoutRelatedActionsInput, DocumentRecordUpdateWithoutRelatedActionsInput>, DocumentRecordUncheckedUpdateWithoutRelatedActionsInput>
  }

  export type EmployeeCreateNestedOneWithoutAccidentsInput = {
    create?: XOR<EmployeeCreateWithoutAccidentsInput, EmployeeUncheckedCreateWithoutAccidentsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAccidentsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EmployeeUpdateOneRequiredWithoutAccidentsNestedInput = {
    create?: XOR<EmployeeCreateWithoutAccidentsInput, EmployeeUncheckedCreateWithoutAccidentsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAccidentsInput
    upsert?: EmployeeUpsertWithoutAccidentsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutAccidentsInput, EmployeeUpdateWithoutAccidentsInput>, EmployeeUncheckedUpdateWithoutAccidentsInput>
  }

  export type EmployeeCreateNestedOneWithoutDiseasesInput = {
    create?: XOR<EmployeeCreateWithoutDiseasesInput, EmployeeUncheckedCreateWithoutDiseasesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutDiseasesInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutDiseasesNestedInput = {
    create?: XOR<EmployeeCreateWithoutDiseasesInput, EmployeeUncheckedCreateWithoutDiseasesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutDiseasesInput
    upsert?: EmployeeUpsertWithoutDiseasesInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutDiseasesInput, EmployeeUpdateWithoutDiseasesInput>, EmployeeUncheckedUpdateWithoutDiseasesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type PpeRecordCreateWithoutEmployeeInput = {
    id?: string
    ppeType: string
    caNumber?: string | null
    deliveryDate: Date | string
    quantity?: number
    returnDate?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PpeRecordUncheckedCreateWithoutEmployeeInput = {
    id?: string
    ppeType: string
    caNumber?: string | null
    deliveryDate: Date | string
    quantity?: number
    returnDate?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PpeRecordCreateOrConnectWithoutEmployeeInput = {
    where: PpeRecordWhereUniqueInput
    create: XOR<PpeRecordCreateWithoutEmployeeInput, PpeRecordUncheckedCreateWithoutEmployeeInput>
  }

  export type PpeRecordCreateManyEmployeeInputEnvelope = {
    data: PpeRecordCreateManyEmployeeInput | PpeRecordCreateManyEmployeeInput[]
  }

  export type AsoRecordCreateWithoutEmployeeInput = {
    id?: string
    examType: string
    examDate: Date | string
    expiryDate: Date | string
    result: string
    status?: string
    attachmentUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AsoRecordUncheckedCreateWithoutEmployeeInput = {
    id?: string
    examType: string
    examDate: Date | string
    expiryDate: Date | string
    result: string
    status?: string
    attachmentUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AsoRecordCreateOrConnectWithoutEmployeeInput = {
    where: AsoRecordWhereUniqueInput
    create: XOR<AsoRecordCreateWithoutEmployeeInput, AsoRecordUncheckedCreateWithoutEmployeeInput>
  }

  export type AsoRecordCreateManyEmployeeInputEnvelope = {
    data: AsoRecordCreateManyEmployeeInput | AsoRecordCreateManyEmployeeInput[]
  }

  export type TrainingRecordCreateWithoutEmployeeInput = {
    id?: string
    trainingDate: Date | string
    expiryDate?: Date | string | null
    status?: string
    attendanceListUrl?: string | null
    certificateUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trainingType: TrainingTypeCreateNestedOneWithoutTrainingRecordsInput
  }

  export type TrainingRecordUncheckedCreateWithoutEmployeeInput = {
    id?: string
    trainingTypeId: string
    trainingDate: Date | string
    expiryDate?: Date | string | null
    status?: string
    attendanceListUrl?: string | null
    certificateUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingRecordCreateOrConnectWithoutEmployeeInput = {
    where: TrainingRecordWhereUniqueInput
    create: XOR<TrainingRecordCreateWithoutEmployeeInput, TrainingRecordUncheckedCreateWithoutEmployeeInput>
  }

  export type TrainingRecordCreateManyEmployeeInputEnvelope = {
    data: TrainingRecordCreateManyEmployeeInput | TrainingRecordCreateManyEmployeeInput[]
  }

  export type AccidentRecordCreateWithoutEmployeeInput = {
    id?: string
    date: Date | string
    time?: string | null
    department: string
    location: string
    type: string
    cause: string
    causeDetails?: string | null
    daysOff?: number
    description: string
    cid10Code?: string | null
    catIssued?: boolean
    investigationStatus?: string
    reportUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccidentRecordUncheckedCreateWithoutEmployeeInput = {
    id?: string
    date: Date | string
    time?: string | null
    department: string
    location: string
    type: string
    cause: string
    causeDetails?: string | null
    daysOff?: number
    description: string
    cid10Code?: string | null
    catIssued?: boolean
    investigationStatus?: string
    reportUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccidentRecordCreateOrConnectWithoutEmployeeInput = {
    where: AccidentRecordWhereUniqueInput
    create: XOR<AccidentRecordCreateWithoutEmployeeInput, AccidentRecordUncheckedCreateWithoutEmployeeInput>
  }

  export type AccidentRecordCreateManyEmployeeInputEnvelope = {
    data: AccidentRecordCreateManyEmployeeInput | AccidentRecordCreateManyEmployeeInput[]
  }

  export type OccupationalDiseaseRecordCreateWithoutEmployeeInput = {
    id?: string
    diseaseType: string
    cid10Code: string
    diagnosisDate: Date | string
    relatedTask?: string | null
    daysOff?: number
    status?: string
    medicalReportUrl?: string | null
    pcmsoLink?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OccupationalDiseaseRecordUncheckedCreateWithoutEmployeeInput = {
    id?: string
    diseaseType: string
    cid10Code: string
    diagnosisDate: Date | string
    relatedTask?: string | null
    daysOff?: number
    status?: string
    medicalReportUrl?: string | null
    pcmsoLink?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OccupationalDiseaseRecordCreateOrConnectWithoutEmployeeInput = {
    where: OccupationalDiseaseRecordWhereUniqueInput
    create: XOR<OccupationalDiseaseRecordCreateWithoutEmployeeInput, OccupationalDiseaseRecordUncheckedCreateWithoutEmployeeInput>
  }

  export type OccupationalDiseaseRecordCreateManyEmployeeInputEnvelope = {
    data: OccupationalDiseaseRecordCreateManyEmployeeInput | OccupationalDiseaseRecordCreateManyEmployeeInput[]
  }

  export type PpeRecordUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: PpeRecordWhereUniqueInput
    update: XOR<PpeRecordUpdateWithoutEmployeeInput, PpeRecordUncheckedUpdateWithoutEmployeeInput>
    create: XOR<PpeRecordCreateWithoutEmployeeInput, PpeRecordUncheckedCreateWithoutEmployeeInput>
  }

  export type PpeRecordUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: PpeRecordWhereUniqueInput
    data: XOR<PpeRecordUpdateWithoutEmployeeInput, PpeRecordUncheckedUpdateWithoutEmployeeInput>
  }

  export type PpeRecordUpdateManyWithWhereWithoutEmployeeInput = {
    where: PpeRecordScalarWhereInput
    data: XOR<PpeRecordUpdateManyMutationInput, PpeRecordUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type PpeRecordScalarWhereInput = {
    AND?: PpeRecordScalarWhereInput | PpeRecordScalarWhereInput[]
    OR?: PpeRecordScalarWhereInput[]
    NOT?: PpeRecordScalarWhereInput | PpeRecordScalarWhereInput[]
    id?: StringFilter<"PpeRecord"> | string
    employeeId?: StringFilter<"PpeRecord"> | string
    ppeType?: StringFilter<"PpeRecord"> | string
    caNumber?: StringNullableFilter<"PpeRecord"> | string | null
    deliveryDate?: DateTimeFilter<"PpeRecord"> | Date | string
    quantity?: IntFilter<"PpeRecord"> | number
    returnDate?: DateTimeNullableFilter<"PpeRecord"> | Date | string | null
    status?: StringFilter<"PpeRecord"> | string
    createdAt?: DateTimeFilter<"PpeRecord"> | Date | string
    updatedAt?: DateTimeFilter<"PpeRecord"> | Date | string
  }

  export type AsoRecordUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: AsoRecordWhereUniqueInput
    update: XOR<AsoRecordUpdateWithoutEmployeeInput, AsoRecordUncheckedUpdateWithoutEmployeeInput>
    create: XOR<AsoRecordCreateWithoutEmployeeInput, AsoRecordUncheckedCreateWithoutEmployeeInput>
  }

  export type AsoRecordUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: AsoRecordWhereUniqueInput
    data: XOR<AsoRecordUpdateWithoutEmployeeInput, AsoRecordUncheckedUpdateWithoutEmployeeInput>
  }

  export type AsoRecordUpdateManyWithWhereWithoutEmployeeInput = {
    where: AsoRecordScalarWhereInput
    data: XOR<AsoRecordUpdateManyMutationInput, AsoRecordUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type AsoRecordScalarWhereInput = {
    AND?: AsoRecordScalarWhereInput | AsoRecordScalarWhereInput[]
    OR?: AsoRecordScalarWhereInput[]
    NOT?: AsoRecordScalarWhereInput | AsoRecordScalarWhereInput[]
    id?: StringFilter<"AsoRecord"> | string
    employeeId?: StringFilter<"AsoRecord"> | string
    examType?: StringFilter<"AsoRecord"> | string
    examDate?: DateTimeFilter<"AsoRecord"> | Date | string
    expiryDate?: DateTimeFilter<"AsoRecord"> | Date | string
    result?: StringFilter<"AsoRecord"> | string
    status?: StringFilter<"AsoRecord"> | string
    attachmentUrl?: StringNullableFilter<"AsoRecord"> | string | null
    createdAt?: DateTimeFilter<"AsoRecord"> | Date | string
    updatedAt?: DateTimeFilter<"AsoRecord"> | Date | string
  }

  export type TrainingRecordUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: TrainingRecordWhereUniqueInput
    update: XOR<TrainingRecordUpdateWithoutEmployeeInput, TrainingRecordUncheckedUpdateWithoutEmployeeInput>
    create: XOR<TrainingRecordCreateWithoutEmployeeInput, TrainingRecordUncheckedCreateWithoutEmployeeInput>
  }

  export type TrainingRecordUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: TrainingRecordWhereUniqueInput
    data: XOR<TrainingRecordUpdateWithoutEmployeeInput, TrainingRecordUncheckedUpdateWithoutEmployeeInput>
  }

  export type TrainingRecordUpdateManyWithWhereWithoutEmployeeInput = {
    where: TrainingRecordScalarWhereInput
    data: XOR<TrainingRecordUpdateManyMutationInput, TrainingRecordUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type TrainingRecordScalarWhereInput = {
    AND?: TrainingRecordScalarWhereInput | TrainingRecordScalarWhereInput[]
    OR?: TrainingRecordScalarWhereInput[]
    NOT?: TrainingRecordScalarWhereInput | TrainingRecordScalarWhereInput[]
    id?: StringFilter<"TrainingRecord"> | string
    employeeId?: StringFilter<"TrainingRecord"> | string
    trainingTypeId?: StringFilter<"TrainingRecord"> | string
    trainingDate?: DateTimeFilter<"TrainingRecord"> | Date | string
    expiryDate?: DateTimeNullableFilter<"TrainingRecord"> | Date | string | null
    status?: StringFilter<"TrainingRecord"> | string
    attendanceListUrl?: StringNullableFilter<"TrainingRecord"> | string | null
    certificateUrl?: StringNullableFilter<"TrainingRecord"> | string | null
    createdAt?: DateTimeFilter<"TrainingRecord"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingRecord"> | Date | string
  }

  export type AccidentRecordUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: AccidentRecordWhereUniqueInput
    update: XOR<AccidentRecordUpdateWithoutEmployeeInput, AccidentRecordUncheckedUpdateWithoutEmployeeInput>
    create: XOR<AccidentRecordCreateWithoutEmployeeInput, AccidentRecordUncheckedCreateWithoutEmployeeInput>
  }

  export type AccidentRecordUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: AccidentRecordWhereUniqueInput
    data: XOR<AccidentRecordUpdateWithoutEmployeeInput, AccidentRecordUncheckedUpdateWithoutEmployeeInput>
  }

  export type AccidentRecordUpdateManyWithWhereWithoutEmployeeInput = {
    where: AccidentRecordScalarWhereInput
    data: XOR<AccidentRecordUpdateManyMutationInput, AccidentRecordUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type AccidentRecordScalarWhereInput = {
    AND?: AccidentRecordScalarWhereInput | AccidentRecordScalarWhereInput[]
    OR?: AccidentRecordScalarWhereInput[]
    NOT?: AccidentRecordScalarWhereInput | AccidentRecordScalarWhereInput[]
    id?: StringFilter<"AccidentRecord"> | string
    date?: DateTimeFilter<"AccidentRecord"> | Date | string
    time?: StringNullableFilter<"AccidentRecord"> | string | null
    employeeId?: StringFilter<"AccidentRecord"> | string
    department?: StringFilter<"AccidentRecord"> | string
    location?: StringFilter<"AccidentRecord"> | string
    type?: StringFilter<"AccidentRecord"> | string
    cause?: StringFilter<"AccidentRecord"> | string
    causeDetails?: StringNullableFilter<"AccidentRecord"> | string | null
    daysOff?: IntFilter<"AccidentRecord"> | number
    description?: StringFilter<"AccidentRecord"> | string
    cid10Code?: StringNullableFilter<"AccidentRecord"> | string | null
    catIssued?: BoolFilter<"AccidentRecord"> | boolean
    investigationStatus?: StringFilter<"AccidentRecord"> | string
    reportUrl?: StringNullableFilter<"AccidentRecord"> | string | null
    createdAt?: DateTimeFilter<"AccidentRecord"> | Date | string
    updatedAt?: DateTimeFilter<"AccidentRecord"> | Date | string
  }

  export type OccupationalDiseaseRecordUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: OccupationalDiseaseRecordWhereUniqueInput
    update: XOR<OccupationalDiseaseRecordUpdateWithoutEmployeeInput, OccupationalDiseaseRecordUncheckedUpdateWithoutEmployeeInput>
    create: XOR<OccupationalDiseaseRecordCreateWithoutEmployeeInput, OccupationalDiseaseRecordUncheckedCreateWithoutEmployeeInput>
  }

  export type OccupationalDiseaseRecordUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: OccupationalDiseaseRecordWhereUniqueInput
    data: XOR<OccupationalDiseaseRecordUpdateWithoutEmployeeInput, OccupationalDiseaseRecordUncheckedUpdateWithoutEmployeeInput>
  }

  export type OccupationalDiseaseRecordUpdateManyWithWhereWithoutEmployeeInput = {
    where: OccupationalDiseaseRecordScalarWhereInput
    data: XOR<OccupationalDiseaseRecordUpdateManyMutationInput, OccupationalDiseaseRecordUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type OccupationalDiseaseRecordScalarWhereInput = {
    AND?: OccupationalDiseaseRecordScalarWhereInput | OccupationalDiseaseRecordScalarWhereInput[]
    OR?: OccupationalDiseaseRecordScalarWhereInput[]
    NOT?: OccupationalDiseaseRecordScalarWhereInput | OccupationalDiseaseRecordScalarWhereInput[]
    id?: StringFilter<"OccupationalDiseaseRecord"> | string
    employeeId?: StringFilter<"OccupationalDiseaseRecord"> | string
    diseaseType?: StringFilter<"OccupationalDiseaseRecord"> | string
    cid10Code?: StringFilter<"OccupationalDiseaseRecord"> | string
    diagnosisDate?: DateTimeFilter<"OccupationalDiseaseRecord"> | Date | string
    relatedTask?: StringNullableFilter<"OccupationalDiseaseRecord"> | string | null
    daysOff?: IntFilter<"OccupationalDiseaseRecord"> | number
    status?: StringFilter<"OccupationalDiseaseRecord"> | string
    medicalReportUrl?: StringNullableFilter<"OccupationalDiseaseRecord"> | string | null
    pcmsoLink?: StringNullableFilter<"OccupationalDiseaseRecord"> | string | null
    createdAt?: DateTimeFilter<"OccupationalDiseaseRecord"> | Date | string
    updatedAt?: DateTimeFilter<"OccupationalDiseaseRecord"> | Date | string
  }

  export type TrainingRecordCreateWithoutTrainingTypeInput = {
    id?: string
    trainingDate: Date | string
    expiryDate?: Date | string | null
    status?: string
    attendanceListUrl?: string | null
    certificateUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutTrainingsInput
  }

  export type TrainingRecordUncheckedCreateWithoutTrainingTypeInput = {
    id?: string
    employeeId: string
    trainingDate: Date | string
    expiryDate?: Date | string | null
    status?: string
    attendanceListUrl?: string | null
    certificateUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingRecordCreateOrConnectWithoutTrainingTypeInput = {
    where: TrainingRecordWhereUniqueInput
    create: XOR<TrainingRecordCreateWithoutTrainingTypeInput, TrainingRecordUncheckedCreateWithoutTrainingTypeInput>
  }

  export type TrainingRecordCreateManyTrainingTypeInputEnvelope = {
    data: TrainingRecordCreateManyTrainingTypeInput | TrainingRecordCreateManyTrainingTypeInput[]
  }

  export type TrainingRecordUpsertWithWhereUniqueWithoutTrainingTypeInput = {
    where: TrainingRecordWhereUniqueInput
    update: XOR<TrainingRecordUpdateWithoutTrainingTypeInput, TrainingRecordUncheckedUpdateWithoutTrainingTypeInput>
    create: XOR<TrainingRecordCreateWithoutTrainingTypeInput, TrainingRecordUncheckedCreateWithoutTrainingTypeInput>
  }

  export type TrainingRecordUpdateWithWhereUniqueWithoutTrainingTypeInput = {
    where: TrainingRecordWhereUniqueInput
    data: XOR<TrainingRecordUpdateWithoutTrainingTypeInput, TrainingRecordUncheckedUpdateWithoutTrainingTypeInput>
  }

  export type TrainingRecordUpdateManyWithWhereWithoutTrainingTypeInput = {
    where: TrainingRecordScalarWhereInput
    data: XOR<TrainingRecordUpdateManyMutationInput, TrainingRecordUncheckedUpdateManyWithoutTrainingTypeInput>
  }

  export type EmployeeCreateWithoutTrainingsInput = {
    id?: string
    name: string
    department?: string | null
    position?: string | null
    hireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ppeRecords?: PpeRecordCreateNestedManyWithoutEmployeeInput
    asoRecords?: AsoRecordCreateNestedManyWithoutEmployeeInput
    accidents?: AccidentRecordCreateNestedManyWithoutEmployeeInput
    diseases?: OccupationalDiseaseRecordCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutTrainingsInput = {
    id?: string
    name: string
    department?: string | null
    position?: string | null
    hireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ppeRecords?: PpeRecordUncheckedCreateNestedManyWithoutEmployeeInput
    asoRecords?: AsoRecordUncheckedCreateNestedManyWithoutEmployeeInput
    accidents?: AccidentRecordUncheckedCreateNestedManyWithoutEmployeeInput
    diseases?: OccupationalDiseaseRecordUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutTrainingsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutTrainingsInput, EmployeeUncheckedCreateWithoutTrainingsInput>
  }

  export type TrainingTypeCreateWithoutTrainingRecordsInput = {
    id?: string
    name: string
    description?: string | null
    validityMonths?: number | null
    requiredNrsJson?: string | null
    defaultDuration?: number | null
    defaultLocation?: string | null
    defaultCost?: number | null
    instructorsJson?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingTypeUncheckedCreateWithoutTrainingRecordsInput = {
    id?: string
    name: string
    description?: string | null
    validityMonths?: number | null
    requiredNrsJson?: string | null
    defaultDuration?: number | null
    defaultLocation?: string | null
    defaultCost?: number | null
    instructorsJson?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingTypeCreateOrConnectWithoutTrainingRecordsInput = {
    where: TrainingTypeWhereUniqueInput
    create: XOR<TrainingTypeCreateWithoutTrainingRecordsInput, TrainingTypeUncheckedCreateWithoutTrainingRecordsInput>
  }

  export type EmployeeUpsertWithoutTrainingsInput = {
    update: XOR<EmployeeUpdateWithoutTrainingsInput, EmployeeUncheckedUpdateWithoutTrainingsInput>
    create: XOR<EmployeeCreateWithoutTrainingsInput, EmployeeUncheckedCreateWithoutTrainingsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutTrainingsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutTrainingsInput, EmployeeUncheckedUpdateWithoutTrainingsInput>
  }

  export type EmployeeUpdateWithoutTrainingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ppeRecords?: PpeRecordUpdateManyWithoutEmployeeNestedInput
    asoRecords?: AsoRecordUpdateManyWithoutEmployeeNestedInput
    accidents?: AccidentRecordUpdateManyWithoutEmployeeNestedInput
    diseases?: OccupationalDiseaseRecordUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutTrainingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ppeRecords?: PpeRecordUncheckedUpdateManyWithoutEmployeeNestedInput
    asoRecords?: AsoRecordUncheckedUpdateManyWithoutEmployeeNestedInput
    accidents?: AccidentRecordUncheckedUpdateManyWithoutEmployeeNestedInput
    diseases?: OccupationalDiseaseRecordUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type TrainingTypeUpsertWithoutTrainingRecordsInput = {
    update: XOR<TrainingTypeUpdateWithoutTrainingRecordsInput, TrainingTypeUncheckedUpdateWithoutTrainingRecordsInput>
    create: XOR<TrainingTypeCreateWithoutTrainingRecordsInput, TrainingTypeUncheckedCreateWithoutTrainingRecordsInput>
    where?: TrainingTypeWhereInput
  }

  export type TrainingTypeUpdateToOneWithWhereWithoutTrainingRecordsInput = {
    where?: TrainingTypeWhereInput
    data: XOR<TrainingTypeUpdateWithoutTrainingRecordsInput, TrainingTypeUncheckedUpdateWithoutTrainingRecordsInput>
  }

  export type TrainingTypeUpdateWithoutTrainingRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    validityMonths?: NullableIntFieldUpdateOperationsInput | number | null
    requiredNrsJson?: NullableStringFieldUpdateOperationsInput | string | null
    defaultDuration?: NullableIntFieldUpdateOperationsInput | number | null
    defaultLocation?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCost?: NullableFloatFieldUpdateOperationsInput | number | null
    instructorsJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingTypeUncheckedUpdateWithoutTrainingRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    validityMonths?: NullableIntFieldUpdateOperationsInput | number | null
    requiredNrsJson?: NullableStringFieldUpdateOperationsInput | string | null
    defaultDuration?: NullableIntFieldUpdateOperationsInput | number | null
    defaultLocation?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCost?: NullableFloatFieldUpdateOperationsInput | number | null
    instructorsJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateWithoutPpeRecordsInput = {
    id?: string
    name: string
    department?: string | null
    position?: string | null
    hireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    asoRecords?: AsoRecordCreateNestedManyWithoutEmployeeInput
    trainings?: TrainingRecordCreateNestedManyWithoutEmployeeInput
    accidents?: AccidentRecordCreateNestedManyWithoutEmployeeInput
    diseases?: OccupationalDiseaseRecordCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutPpeRecordsInput = {
    id?: string
    name: string
    department?: string | null
    position?: string | null
    hireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    asoRecords?: AsoRecordUncheckedCreateNestedManyWithoutEmployeeInput
    trainings?: TrainingRecordUncheckedCreateNestedManyWithoutEmployeeInput
    accidents?: AccidentRecordUncheckedCreateNestedManyWithoutEmployeeInput
    diseases?: OccupationalDiseaseRecordUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutPpeRecordsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutPpeRecordsInput, EmployeeUncheckedCreateWithoutPpeRecordsInput>
  }

  export type EmployeeUpsertWithoutPpeRecordsInput = {
    update: XOR<EmployeeUpdateWithoutPpeRecordsInput, EmployeeUncheckedUpdateWithoutPpeRecordsInput>
    create: XOR<EmployeeCreateWithoutPpeRecordsInput, EmployeeUncheckedCreateWithoutPpeRecordsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutPpeRecordsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutPpeRecordsInput, EmployeeUncheckedUpdateWithoutPpeRecordsInput>
  }

  export type EmployeeUpdateWithoutPpeRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    asoRecords?: AsoRecordUpdateManyWithoutEmployeeNestedInput
    trainings?: TrainingRecordUpdateManyWithoutEmployeeNestedInput
    accidents?: AccidentRecordUpdateManyWithoutEmployeeNestedInput
    diseases?: OccupationalDiseaseRecordUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutPpeRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    asoRecords?: AsoRecordUncheckedUpdateManyWithoutEmployeeNestedInput
    trainings?: TrainingRecordUncheckedUpdateManyWithoutEmployeeNestedInput
    accidents?: AccidentRecordUncheckedUpdateManyWithoutEmployeeNestedInput
    diseases?: OccupationalDiseaseRecordUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateWithoutAsoRecordsInput = {
    id?: string
    name: string
    department?: string | null
    position?: string | null
    hireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ppeRecords?: PpeRecordCreateNestedManyWithoutEmployeeInput
    trainings?: TrainingRecordCreateNestedManyWithoutEmployeeInput
    accidents?: AccidentRecordCreateNestedManyWithoutEmployeeInput
    diseases?: OccupationalDiseaseRecordCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutAsoRecordsInput = {
    id?: string
    name: string
    department?: string | null
    position?: string | null
    hireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ppeRecords?: PpeRecordUncheckedCreateNestedManyWithoutEmployeeInput
    trainings?: TrainingRecordUncheckedCreateNestedManyWithoutEmployeeInput
    accidents?: AccidentRecordUncheckedCreateNestedManyWithoutEmployeeInput
    diseases?: OccupationalDiseaseRecordUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutAsoRecordsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutAsoRecordsInput, EmployeeUncheckedCreateWithoutAsoRecordsInput>
  }

  export type EmployeeUpsertWithoutAsoRecordsInput = {
    update: XOR<EmployeeUpdateWithoutAsoRecordsInput, EmployeeUncheckedUpdateWithoutAsoRecordsInput>
    create: XOR<EmployeeCreateWithoutAsoRecordsInput, EmployeeUncheckedCreateWithoutAsoRecordsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutAsoRecordsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutAsoRecordsInput, EmployeeUncheckedUpdateWithoutAsoRecordsInput>
  }

  export type EmployeeUpdateWithoutAsoRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ppeRecords?: PpeRecordUpdateManyWithoutEmployeeNestedInput
    trainings?: TrainingRecordUpdateManyWithoutEmployeeNestedInput
    accidents?: AccidentRecordUpdateManyWithoutEmployeeNestedInput
    diseases?: OccupationalDiseaseRecordUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutAsoRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ppeRecords?: PpeRecordUncheckedUpdateManyWithoutEmployeeNestedInput
    trainings?: TrainingRecordUncheckedUpdateManyWithoutEmployeeNestedInput
    accidents?: AccidentRecordUncheckedUpdateManyWithoutEmployeeNestedInput
    diseases?: OccupationalDiseaseRecordUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type RiskItemCreateWithoutJsaInput = {
    id?: string
    description: string
    controls: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RiskItemUncheckedCreateWithoutJsaInput = {
    id?: string
    description: string
    controls: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RiskItemCreateOrConnectWithoutJsaInput = {
    where: RiskItemWhereUniqueInput
    create: XOR<RiskItemCreateWithoutJsaInput, RiskItemUncheckedCreateWithoutJsaInput>
  }

  export type RiskItemCreateManyJsaInputEnvelope = {
    data: RiskItemCreateManyJsaInput | RiskItemCreateManyJsaInput[]
  }

  export type RiskItemUpsertWithWhereUniqueWithoutJsaInput = {
    where: RiskItemWhereUniqueInput
    update: XOR<RiskItemUpdateWithoutJsaInput, RiskItemUncheckedUpdateWithoutJsaInput>
    create: XOR<RiskItemCreateWithoutJsaInput, RiskItemUncheckedCreateWithoutJsaInput>
  }

  export type RiskItemUpdateWithWhereUniqueWithoutJsaInput = {
    where: RiskItemWhereUniqueInput
    data: XOR<RiskItemUpdateWithoutJsaInput, RiskItemUncheckedUpdateWithoutJsaInput>
  }

  export type RiskItemUpdateManyWithWhereWithoutJsaInput = {
    where: RiskItemScalarWhereInput
    data: XOR<RiskItemUpdateManyMutationInput, RiskItemUncheckedUpdateManyWithoutJsaInput>
  }

  export type RiskItemScalarWhereInput = {
    AND?: RiskItemScalarWhereInput | RiskItemScalarWhereInput[]
    OR?: RiskItemScalarWhereInput[]
    NOT?: RiskItemScalarWhereInput | RiskItemScalarWhereInput[]
    id?: StringFilter<"RiskItem"> | string
    jsaId?: StringFilter<"RiskItem"> | string
    description?: StringFilter<"RiskItem"> | string
    controls?: StringFilter<"RiskItem"> | string
    createdAt?: DateTimeFilter<"RiskItem"> | Date | string
    updatedAt?: DateTimeFilter<"RiskItem"> | Date | string
  }

  export type JsaRecordCreateWithoutRisksInput = {
    id?: string
    taskName: string
    department: string
    analysisDate: Date | string
    reviewDate?: Date | string | null
    status?: string
    attachmentUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JsaRecordUncheckedCreateWithoutRisksInput = {
    id?: string
    taskName: string
    department: string
    analysisDate: Date | string
    reviewDate?: Date | string | null
    status?: string
    attachmentUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JsaRecordCreateOrConnectWithoutRisksInput = {
    where: JsaRecordWhereUniqueInput
    create: XOR<JsaRecordCreateWithoutRisksInput, JsaRecordUncheckedCreateWithoutRisksInput>
  }

  export type JsaRecordUpsertWithoutRisksInput = {
    update: XOR<JsaRecordUpdateWithoutRisksInput, JsaRecordUncheckedUpdateWithoutRisksInput>
    create: XOR<JsaRecordCreateWithoutRisksInput, JsaRecordUncheckedCreateWithoutRisksInput>
    where?: JsaRecordWhereInput
  }

  export type JsaRecordUpdateToOneWithWhereWithoutRisksInput = {
    where?: JsaRecordWhereInput
    data: XOR<JsaRecordUpdateWithoutRisksInput, JsaRecordUncheckedUpdateWithoutRisksInput>
  }

  export type JsaRecordUpdateWithoutRisksInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskName?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    analysisDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JsaRecordUncheckedUpdateWithoutRisksInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskName?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    analysisDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CipaActionCreateWithoutMeetingInput = {
    id?: string
    description: string
    responsible: string
    deadline?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CipaActionUncheckedCreateWithoutMeetingInput = {
    id?: string
    description: string
    responsible: string
    deadline?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CipaActionCreateOrConnectWithoutMeetingInput = {
    where: CipaActionWhereUniqueInput
    create: XOR<CipaActionCreateWithoutMeetingInput, CipaActionUncheckedCreateWithoutMeetingInput>
  }

  export type CipaActionCreateManyMeetingInputEnvelope = {
    data: CipaActionCreateManyMeetingInput | CipaActionCreateManyMeetingInput[]
  }

  export type CipaActionUpsertWithWhereUniqueWithoutMeetingInput = {
    where: CipaActionWhereUniqueInput
    update: XOR<CipaActionUpdateWithoutMeetingInput, CipaActionUncheckedUpdateWithoutMeetingInput>
    create: XOR<CipaActionCreateWithoutMeetingInput, CipaActionUncheckedCreateWithoutMeetingInput>
  }

  export type CipaActionUpdateWithWhereUniqueWithoutMeetingInput = {
    where: CipaActionWhereUniqueInput
    data: XOR<CipaActionUpdateWithoutMeetingInput, CipaActionUncheckedUpdateWithoutMeetingInput>
  }

  export type CipaActionUpdateManyWithWhereWithoutMeetingInput = {
    where: CipaActionScalarWhereInput
    data: XOR<CipaActionUpdateManyMutationInput, CipaActionUncheckedUpdateManyWithoutMeetingInput>
  }

  export type CipaActionScalarWhereInput = {
    AND?: CipaActionScalarWhereInput | CipaActionScalarWhereInput[]
    OR?: CipaActionScalarWhereInput[]
    NOT?: CipaActionScalarWhereInput | CipaActionScalarWhereInput[]
    id?: StringFilter<"CipaAction"> | string
    description?: StringFilter<"CipaAction"> | string
    responsible?: StringFilter<"CipaAction"> | string
    deadline?: DateTimeNullableFilter<"CipaAction"> | Date | string | null
    status?: StringFilter<"CipaAction"> | string
    meetingId?: StringFilter<"CipaAction"> | string
    createdAt?: DateTimeFilter<"CipaAction"> | Date | string
    updatedAt?: DateTimeFilter<"CipaAction"> | Date | string
  }

  export type CipaMeetingCreateWithoutActionsDefinedInput = {
    id?: string
    date: Date | string
    participantsJson?: string | null
    agenda: string
    status?: string
    minutesUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CipaMeetingUncheckedCreateWithoutActionsDefinedInput = {
    id?: string
    date: Date | string
    participantsJson?: string | null
    agenda: string
    status?: string
    minutesUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CipaMeetingCreateOrConnectWithoutActionsDefinedInput = {
    where: CipaMeetingWhereUniqueInput
    create: XOR<CipaMeetingCreateWithoutActionsDefinedInput, CipaMeetingUncheckedCreateWithoutActionsDefinedInput>
  }

  export type CipaMeetingUpsertWithoutActionsDefinedInput = {
    update: XOR<CipaMeetingUpdateWithoutActionsDefinedInput, CipaMeetingUncheckedUpdateWithoutActionsDefinedInput>
    create: XOR<CipaMeetingCreateWithoutActionsDefinedInput, CipaMeetingUncheckedCreateWithoutActionsDefinedInput>
    where?: CipaMeetingWhereInput
  }

  export type CipaMeetingUpdateToOneWithWhereWithoutActionsDefinedInput = {
    where?: CipaMeetingWhereInput
    data: XOR<CipaMeetingUpdateWithoutActionsDefinedInput, CipaMeetingUncheckedUpdateWithoutActionsDefinedInput>
  }

  export type CipaMeetingUpdateWithoutActionsDefinedInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    participantsJson?: NullableStringFieldUpdateOperationsInput | string | null
    agenda?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    minutesUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CipaMeetingUncheckedUpdateWithoutActionsDefinedInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    participantsJson?: NullableStringFieldUpdateOperationsInput | string | null
    agenda?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    minutesUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentActionCreateWithoutDocumentInput = {
    id?: string
    description: string
    responsible: string
    deadline?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentActionUncheckedCreateWithoutDocumentInput = {
    id?: string
    description: string
    responsible: string
    deadline?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentActionCreateOrConnectWithoutDocumentInput = {
    where: DocumentActionWhereUniqueInput
    create: XOR<DocumentActionCreateWithoutDocumentInput, DocumentActionUncheckedCreateWithoutDocumentInput>
  }

  export type DocumentActionCreateManyDocumentInputEnvelope = {
    data: DocumentActionCreateManyDocumentInput | DocumentActionCreateManyDocumentInput[]
  }

  export type DocumentActionUpsertWithWhereUniqueWithoutDocumentInput = {
    where: DocumentActionWhereUniqueInput
    update: XOR<DocumentActionUpdateWithoutDocumentInput, DocumentActionUncheckedUpdateWithoutDocumentInput>
    create: XOR<DocumentActionCreateWithoutDocumentInput, DocumentActionUncheckedCreateWithoutDocumentInput>
  }

  export type DocumentActionUpdateWithWhereUniqueWithoutDocumentInput = {
    where: DocumentActionWhereUniqueInput
    data: XOR<DocumentActionUpdateWithoutDocumentInput, DocumentActionUncheckedUpdateWithoutDocumentInput>
  }

  export type DocumentActionUpdateManyWithWhereWithoutDocumentInput = {
    where: DocumentActionScalarWhereInput
    data: XOR<DocumentActionUpdateManyMutationInput, DocumentActionUncheckedUpdateManyWithoutDocumentInput>
  }

  export type DocumentActionScalarWhereInput = {
    AND?: DocumentActionScalarWhereInput | DocumentActionScalarWhereInput[]
    OR?: DocumentActionScalarWhereInput[]
    NOT?: DocumentActionScalarWhereInput | DocumentActionScalarWhereInput[]
    id?: StringFilter<"DocumentAction"> | string
    description?: StringFilter<"DocumentAction"> | string
    responsible?: StringFilter<"DocumentAction"> | string
    deadline?: DateTimeNullableFilter<"DocumentAction"> | Date | string | null
    status?: StringFilter<"DocumentAction"> | string
    documentId?: StringFilter<"DocumentAction"> | string
    createdAt?: DateTimeFilter<"DocumentAction"> | Date | string
    updatedAt?: DateTimeFilter<"DocumentAction"> | Date | string
  }

  export type DocumentRecordCreateWithoutRelatedActionsInput = {
    id?: string
    documentType: string
    title: string
    issueDate: Date | string
    expiryDate: Date | string
    responsible: string
    status?: string
    attachmentUrl?: string | null
    observations?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentRecordUncheckedCreateWithoutRelatedActionsInput = {
    id?: string
    documentType: string
    title: string
    issueDate: Date | string
    expiryDate: Date | string
    responsible: string
    status?: string
    attachmentUrl?: string | null
    observations?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentRecordCreateOrConnectWithoutRelatedActionsInput = {
    where: DocumentRecordWhereUniqueInput
    create: XOR<DocumentRecordCreateWithoutRelatedActionsInput, DocumentRecordUncheckedCreateWithoutRelatedActionsInput>
  }

  export type DocumentRecordUpsertWithoutRelatedActionsInput = {
    update: XOR<DocumentRecordUpdateWithoutRelatedActionsInput, DocumentRecordUncheckedUpdateWithoutRelatedActionsInput>
    create: XOR<DocumentRecordCreateWithoutRelatedActionsInput, DocumentRecordUncheckedCreateWithoutRelatedActionsInput>
    where?: DocumentRecordWhereInput
  }

  export type DocumentRecordUpdateToOneWithWhereWithoutRelatedActionsInput = {
    where?: DocumentRecordWhereInput
    data: XOR<DocumentRecordUpdateWithoutRelatedActionsInput, DocumentRecordUncheckedUpdateWithoutRelatedActionsInput>
  }

  export type DocumentRecordUpdateWithoutRelatedActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    responsible?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentRecordUncheckedUpdateWithoutRelatedActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    responsible?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateWithoutAccidentsInput = {
    id?: string
    name: string
    department?: string | null
    position?: string | null
    hireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ppeRecords?: PpeRecordCreateNestedManyWithoutEmployeeInput
    asoRecords?: AsoRecordCreateNestedManyWithoutEmployeeInput
    trainings?: TrainingRecordCreateNestedManyWithoutEmployeeInput
    diseases?: OccupationalDiseaseRecordCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutAccidentsInput = {
    id?: string
    name: string
    department?: string | null
    position?: string | null
    hireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ppeRecords?: PpeRecordUncheckedCreateNestedManyWithoutEmployeeInput
    asoRecords?: AsoRecordUncheckedCreateNestedManyWithoutEmployeeInput
    trainings?: TrainingRecordUncheckedCreateNestedManyWithoutEmployeeInput
    diseases?: OccupationalDiseaseRecordUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutAccidentsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutAccidentsInput, EmployeeUncheckedCreateWithoutAccidentsInput>
  }

  export type EmployeeUpsertWithoutAccidentsInput = {
    update: XOR<EmployeeUpdateWithoutAccidentsInput, EmployeeUncheckedUpdateWithoutAccidentsInput>
    create: XOR<EmployeeCreateWithoutAccidentsInput, EmployeeUncheckedCreateWithoutAccidentsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutAccidentsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutAccidentsInput, EmployeeUncheckedUpdateWithoutAccidentsInput>
  }

  export type EmployeeUpdateWithoutAccidentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ppeRecords?: PpeRecordUpdateManyWithoutEmployeeNestedInput
    asoRecords?: AsoRecordUpdateManyWithoutEmployeeNestedInput
    trainings?: TrainingRecordUpdateManyWithoutEmployeeNestedInput
    diseases?: OccupationalDiseaseRecordUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutAccidentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ppeRecords?: PpeRecordUncheckedUpdateManyWithoutEmployeeNestedInput
    asoRecords?: AsoRecordUncheckedUpdateManyWithoutEmployeeNestedInput
    trainings?: TrainingRecordUncheckedUpdateManyWithoutEmployeeNestedInput
    diseases?: OccupationalDiseaseRecordUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateWithoutDiseasesInput = {
    id?: string
    name: string
    department?: string | null
    position?: string | null
    hireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ppeRecords?: PpeRecordCreateNestedManyWithoutEmployeeInput
    asoRecords?: AsoRecordCreateNestedManyWithoutEmployeeInput
    trainings?: TrainingRecordCreateNestedManyWithoutEmployeeInput
    accidents?: AccidentRecordCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutDiseasesInput = {
    id?: string
    name: string
    department?: string | null
    position?: string | null
    hireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ppeRecords?: PpeRecordUncheckedCreateNestedManyWithoutEmployeeInput
    asoRecords?: AsoRecordUncheckedCreateNestedManyWithoutEmployeeInput
    trainings?: TrainingRecordUncheckedCreateNestedManyWithoutEmployeeInput
    accidents?: AccidentRecordUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutDiseasesInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutDiseasesInput, EmployeeUncheckedCreateWithoutDiseasesInput>
  }

  export type EmployeeUpsertWithoutDiseasesInput = {
    update: XOR<EmployeeUpdateWithoutDiseasesInput, EmployeeUncheckedUpdateWithoutDiseasesInput>
    create: XOR<EmployeeCreateWithoutDiseasesInput, EmployeeUncheckedCreateWithoutDiseasesInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutDiseasesInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutDiseasesInput, EmployeeUncheckedUpdateWithoutDiseasesInput>
  }

  export type EmployeeUpdateWithoutDiseasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ppeRecords?: PpeRecordUpdateManyWithoutEmployeeNestedInput
    asoRecords?: AsoRecordUpdateManyWithoutEmployeeNestedInput
    trainings?: TrainingRecordUpdateManyWithoutEmployeeNestedInput
    accidents?: AccidentRecordUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutDiseasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ppeRecords?: PpeRecordUncheckedUpdateManyWithoutEmployeeNestedInput
    asoRecords?: AsoRecordUncheckedUpdateManyWithoutEmployeeNestedInput
    trainings?: TrainingRecordUncheckedUpdateManyWithoutEmployeeNestedInput
    accidents?: AccidentRecordUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type PpeRecordCreateManyEmployeeInput = {
    id?: string
    ppeType: string
    caNumber?: string | null
    deliveryDate: Date | string
    quantity?: number
    returnDate?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AsoRecordCreateManyEmployeeInput = {
    id?: string
    examType: string
    examDate: Date | string
    expiryDate: Date | string
    result: string
    status?: string
    attachmentUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingRecordCreateManyEmployeeInput = {
    id?: string
    trainingTypeId: string
    trainingDate: Date | string
    expiryDate?: Date | string | null
    status?: string
    attendanceListUrl?: string | null
    certificateUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccidentRecordCreateManyEmployeeInput = {
    id?: string
    date: Date | string
    time?: string | null
    department: string
    location: string
    type: string
    cause: string
    causeDetails?: string | null
    daysOff?: number
    description: string
    cid10Code?: string | null
    catIssued?: boolean
    investigationStatus?: string
    reportUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OccupationalDiseaseRecordCreateManyEmployeeInput = {
    id?: string
    diseaseType: string
    cid10Code: string
    diagnosisDate: Date | string
    relatedTask?: string | null
    daysOff?: number
    status?: string
    medicalReportUrl?: string | null
    pcmsoLink?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PpeRecordUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    ppeType?: StringFieldUpdateOperationsInput | string
    caNumber?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PpeRecordUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    ppeType?: StringFieldUpdateOperationsInput | string
    caNumber?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PpeRecordUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    ppeType?: StringFieldUpdateOperationsInput | string
    caNumber?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AsoRecordUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    examType?: StringFieldUpdateOperationsInput | string
    examDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    result?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AsoRecordUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    examType?: StringFieldUpdateOperationsInput | string
    examDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    result?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AsoRecordUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    examType?: StringFieldUpdateOperationsInput | string
    examDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    result?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingRecordUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    attendanceListUrl?: NullableStringFieldUpdateOperationsInput | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingType?: TrainingTypeUpdateOneRequiredWithoutTrainingRecordsNestedInput
  }

  export type TrainingRecordUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingTypeId?: StringFieldUpdateOperationsInput | string
    trainingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    attendanceListUrl?: NullableStringFieldUpdateOperationsInput | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingRecordUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingTypeId?: StringFieldUpdateOperationsInput | string
    trainingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    attendanceListUrl?: NullableStringFieldUpdateOperationsInput | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccidentRecordUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    department?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    cause?: StringFieldUpdateOperationsInput | string
    causeDetails?: NullableStringFieldUpdateOperationsInput | string | null
    daysOff?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    cid10Code?: NullableStringFieldUpdateOperationsInput | string | null
    catIssued?: BoolFieldUpdateOperationsInput | boolean
    investigationStatus?: StringFieldUpdateOperationsInput | string
    reportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccidentRecordUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    department?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    cause?: StringFieldUpdateOperationsInput | string
    causeDetails?: NullableStringFieldUpdateOperationsInput | string | null
    daysOff?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    cid10Code?: NullableStringFieldUpdateOperationsInput | string | null
    catIssued?: BoolFieldUpdateOperationsInput | boolean
    investigationStatus?: StringFieldUpdateOperationsInput | string
    reportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccidentRecordUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    department?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    cause?: StringFieldUpdateOperationsInput | string
    causeDetails?: NullableStringFieldUpdateOperationsInput | string | null
    daysOff?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    cid10Code?: NullableStringFieldUpdateOperationsInput | string | null
    catIssued?: BoolFieldUpdateOperationsInput | boolean
    investigationStatus?: StringFieldUpdateOperationsInput | string
    reportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OccupationalDiseaseRecordUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    diseaseType?: StringFieldUpdateOperationsInput | string
    cid10Code?: StringFieldUpdateOperationsInput | string
    diagnosisDate?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedTask?: NullableStringFieldUpdateOperationsInput | string | null
    daysOff?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    medicalReportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pcmsoLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OccupationalDiseaseRecordUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    diseaseType?: StringFieldUpdateOperationsInput | string
    cid10Code?: StringFieldUpdateOperationsInput | string
    diagnosisDate?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedTask?: NullableStringFieldUpdateOperationsInput | string | null
    daysOff?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    medicalReportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pcmsoLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OccupationalDiseaseRecordUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    diseaseType?: StringFieldUpdateOperationsInput | string
    cid10Code?: StringFieldUpdateOperationsInput | string
    diagnosisDate?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedTask?: NullableStringFieldUpdateOperationsInput | string | null
    daysOff?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    medicalReportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pcmsoLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingRecordCreateManyTrainingTypeInput = {
    id?: string
    employeeId: string
    trainingDate: Date | string
    expiryDate?: Date | string | null
    status?: string
    attendanceListUrl?: string | null
    certificateUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingRecordUpdateWithoutTrainingTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    attendanceListUrl?: NullableStringFieldUpdateOperationsInput | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutTrainingsNestedInput
  }

  export type TrainingRecordUncheckedUpdateWithoutTrainingTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    trainingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    attendanceListUrl?: NullableStringFieldUpdateOperationsInput | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingRecordUncheckedUpdateManyWithoutTrainingTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    trainingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    attendanceListUrl?: NullableStringFieldUpdateOperationsInput | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiskItemCreateManyJsaInput = {
    id?: string
    description: string
    controls: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RiskItemUpdateWithoutJsaInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    controls?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiskItemUncheckedUpdateWithoutJsaInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    controls?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiskItemUncheckedUpdateManyWithoutJsaInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    controls?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CipaActionCreateManyMeetingInput = {
    id?: string
    description: string
    responsible: string
    deadline?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CipaActionUpdateWithoutMeetingInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    responsible?: StringFieldUpdateOperationsInput | string
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CipaActionUncheckedUpdateWithoutMeetingInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    responsible?: StringFieldUpdateOperationsInput | string
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CipaActionUncheckedUpdateManyWithoutMeetingInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    responsible?: StringFieldUpdateOperationsInput | string
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentActionCreateManyDocumentInput = {
    id?: string
    description: string
    responsible: string
    deadline?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentActionUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    responsible?: StringFieldUpdateOperationsInput | string
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentActionUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    responsible?: StringFieldUpdateOperationsInput | string
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentActionUncheckedUpdateManyWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    responsible?: StringFieldUpdateOperationsInput | string
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}